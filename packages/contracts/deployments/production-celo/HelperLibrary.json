{
  "address": "0x218Cb1a3A23C8F20223701b19BEfcfE55909773C",
  "abi": [
    {
      "inputs": [],
      "name": "ZERO_ADDRESS",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZERO_AMOUNT",
      "type": "error"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "netIncome",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalFees",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lastUpdate",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "lastFeeRecipient",
              "type": "address"
            },
            {
              "internalType": "int96",
              "name": "lastIncomeRate",
              "type": "int96"
            },
            {
              "internalType": "address",
              "name": "lastManagerFeeRecipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "protocolFees",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "managerFees",
              "type": "uint256"
            }
          ],
          "internalType": "struct IGoodCollectiveSuperApp.Stats",
          "name": "stats",
          "type": "tuple"
        },
        {
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "ISuperToken"
        }
      ],
      "name": "getRealtimeStats",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "netIncome",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalFees",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "protocolFees",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "managerFees",
          "type": "uint256"
        },
        {
          "internalType": "int96",
          "name": "incomeFlowRate",
          "type": "int96"
        },
        {
          "internalType": "int96",
          "name": "feeRate",
          "type": "int96"
        },
        {
          "internalType": "int96",
          "name": "managerFeeRate",
          "type": "int96"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xcea06e588fa5381aee300c25402d1437e149a99627e3ca4314fd6a14ebc4faf6",
  "receipt": {
    "to": null,
    "from": "0x5128E3C1f8846724cc1007Af9b4189713922E4BB",
    "contractAddress": "0xd4Edb5f3e7359fFD69616dAF1C45a74f8DF5441F",
    "transactionIndex": 0,
    "gasUsed": "1440414",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x92f5a2e020aa6361e04e1bc697a14f4951588738a1bc91e6d777a0b0ddd80d92",
    "transactionHash": "0xcea06e588fa5381aee300c25402d1437e149a99627e3ca4314fd6a14ebc4faf6",
    "logs": [],
    "blockNumber": 42927725,
    "cumulativeGasUsed": "1440414",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "6f82686e69397477fabaad38bbde318d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_AMOUNT\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"netIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lastFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"int96\",\"name\":\"lastIncomeRate\",\"type\":\"int96\"},{\"internalType\":\"address\",\"name\":\"lastManagerFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"protocolFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managerFees\",\"type\":\"uint256\"}],\"internalType\":\"struct IGoodCollectiveSuperApp.Stats\",\"name\":\"stats\",\"type\":\"tuple\"},{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"ISuperToken\"}],\"name\":\"getRealtimeStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managerFees\",\"type\":\"uint256\"},{\"internalType\":\"int96\",\"name\":\"incomeFlowRate\",\"type\":\"int96\"},{\"internalType\":\"int96\",\"name\":\"feeRate\",\"type\":\"int96\"},{\"internalType\":\"int96\",\"name\":\"managerFeeRate\",\"type\":\"int96\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/utils/HelperLibrary.sol\":\"HelperLibrary\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":0},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\\n     */\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\\n     */\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n}\\n\",\"keccak256\":\"0x79e6094047e40d49efa3c725b7a1519e16c28c46944884b5f6d0fbe89b450f03\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperfluidToken,\\n    IConstantFlowAgreementV1\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\n/**\\n * @title Constant flow agreement v1 library\\n * @author Superfluid\\n * @dev for working with the constant flow agreement within solidity\\n * @dev the first set of functions are each for callAgreement()\\n * @dev the second set of functions are each for use in callAgreementWithContext()\\n */\\nlibrary CFAv1Library {\\n\\n    /**\\n     * @dev Initialization data\\n     * @param host Superfluid host for calling agreements\\n     * @param cfa Constant Flow Agreement contract\\n     */\\n    struct InitData {\\n        ISuperfluid host;\\n        IConstantFlowAgreementV1 cfa;\\n    }\\n\\n    /**\\n     * @dev Create flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal {\\n        createFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal {\\n        updateFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Update flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlow(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal {\\n        deleteFlow(cfaLibrary, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlow(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Update flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowByOperatorWithCtx(\\n            cfaLibrary,\\n            ctx,\\n            sender,\\n            receiver,\\n            token,\\n            flowRate,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates a flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates a flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowByOperatorWithCtx(\\n            cfaLibrary,\\n            ctx,\\n            sender,\\n            receiver,\\n            token,\\n            flowRate,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowByOperator(cfaLibrary, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowByOperatorWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the permissions of a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\\n     */\\n    function updateFlowOperatorPermissions(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissions,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the permissions of a flow operator with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\\n     */\\n    function updateFlowOperatorPermissionsWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissions,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Grants full, unlimited permission to a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Grants full, unlimited permission to a flow operator with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function authorizeFlowOperatorWithFullControlWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes all permissions from a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes all permissions from a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function revokeFlowOperatorWithFullControlWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x8e090c93d97520fbca57f31ab1aaa4484c1683b2e5b57384c75fcdcab2df17e2\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperToken,\\n    IConstantFlowAgreementV1,\\n    IInstantDistributionAgreementV1\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\n/**\\n * @title Library for Token Centric Interface\\n * @author Superfluid\\n * @dev Set `using for ISuperToken` in including file, and call any of these functions on an instance\\n * of ISuperToken.\\n * Note that it is important to \\\"warm up\\\" the cache and cache the host, cfa, ida before calling,\\n * this is only applicable to Foundry tests where the vm.expectRevert() will not work as expected.\\n */\\nlibrary SuperTokenV1Library {\\n    /** CFA BASE CRUD ************************************* */\\n\\n    /**\\n     * @dev Create flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        return createFlow(token, receiver, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData // userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Update flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        return updateFlow(token, receiver, flowRate, new bytes(0));\\n    }\\n\\n\\n    /**\\n     * @dev Update flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Delete flow without userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver)\\n        internal returns (bool)\\n    {\\n        return deleteFlow(token, sender, receiver, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The userdata passed along with call\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** CFA ACL ************************************* */\\n\\n    /**\\n     * @dev Update permissions for flow operator\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     */\\n    function setFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (token, flowOperator, permissionsBitmask, flowRateAllowance, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function setMaxFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function revokeFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     */\\n    function increaseFlowRateAllowance(ISuperToken token, address flowOperator, int96 addedFlowRateAllowance)\\n        internal\\n        returns (bool)\\n    {\\n        return increaseFlowRateAllowance(token, flowOperator, addedFlowRateAllowance, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function increaseFlowRateAllowance(\\n        ISuperToken token,\\n        address flowOperator,\\n        int96 addedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(cfa.increaseFlowRateAllowance, (token, flowOperator, addedFlowRateAllowance, new bytes(0))),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is decreased\\n     * @param subtractedFlowRateAllowance amount to decrease allowance by\\n     */\\n    function decreaseFlowRateAllowance(ISuperToken token, address flowOperator, int96 subtractedFlowRateAllowance)\\n        internal\\n        returns (bool)\\n    {\\n        return decreaseFlowRateAllowance(token, flowOperator, subtractedFlowRateAllowance, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is decreased\\n     * @param subtractedFlowRateAllowance amount to decrease allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function decreaseFlowRateAllowance(\\n        ISuperToken token,\\n        address flowOperator,\\n        int96 subtractedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.decreaseFlowRateAllowance, (token, flowOperator, subtractedFlowRateAllowance, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator and adds the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param permissionsToAdd The permissions to add for the flow operator\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     */\\n    function increaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToAdd,\\n        int96 addedFlowRateAllowance\\n    ) internal returns (bool) {\\n        return\\n            increaseFlowRateAllowanceWithPermissions(\\n                token,\\n                flowOperator,\\n                permissionsToAdd,\\n                addedFlowRateAllowance,\\n                new bytes(0)\\n            );\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator and adds the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param permissionsToAdd The permissions to add for the flow operator\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function increaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToAdd,\\n        int96 addedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.increaseFlowRateAllowanceWithPermissions,\\n                (token, flowOperator, permissionsToAdd, addedFlowRateAllowance, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator and removes the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is subtracted\\n     * @param permissionsToRemove The permissions to remove for the flow operator\\n     * @param subtractedFlowRateAllowance amount to subtract allowance by\\n     */\\n    function decreaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToRemove,\\n        int96 subtractedFlowRateAllowance\\n    ) internal returns (bool) {\\n        return decreaseFlowRateAllowanceWithPermissions(\\n            token, flowOperator, permissionsToRemove, subtractedFlowRateAllowance, new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator and removes the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is subtracted\\n     * @param permissionsToRemove The permissions to remove for the flow operator\\n     * @param subtractedFlowRateAllowance amount to subtract allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function decreaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToRemove,\\n        int96 subtractedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.decreaseFlowRateAllowanceWithPermissions,\\n                (token, flowOperator, permissionsToRemove, subtractedFlowRateAllowance, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator in callback\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function setFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissionsBitmask,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function setMaxFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n    * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n\\n    /**\\n     * @dev Creates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        return createFlowFrom(token, sender, receiver, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Updates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        return updateFlowFrom(token, sender, receiver, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n     /**\\n     * @dev Deletes flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver\\n    ) internal returns (bool) {\\n        return deleteFlowFrom(token, sender, receiver, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /** CFA With CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function createFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Create flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function createFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow with context\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The receiver of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function deleteFlowWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function deleteFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /** CFA VIEW FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev get flow rate between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return flowRate The flow rate\\n     */\\n    function getFlowRate(ISuperToken token, address sender, address receiver)\\n        internal view returns(int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (, flowRate, , ) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get flow info between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return lastUpdated Timestamp of flow creation or last flowrate change\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlowInfo(ISuperToken token, address sender, address receiver)\\n        internal view\\n        returns(uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (lastUpdated, flowRate, deposit, owedDeposit) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get net flow rate for given account for given token\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return flowRate The net flow rate of the account\\n     */\\n    function getNetFlowRate(ISuperToken token, address account)\\n        internal view returns (int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getNetFlow(token, account);\\n    }\\n\\n    /**\\n     * @dev get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return lastUpdated Timestamp of the last change of the net flow\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getNetFlowInfo(ISuperToken token, address account)\\n        internal view\\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getAccountFlowInfo(token, account);\\n    }\\n\\n    /**\\n     * @dev calculate buffer for a flow rate\\n     * @param token The token used in flow\\n     * @param flowRate The flowrate to calculate the needed buffer for\\n     * @return bufferAmount The buffer amount based on flowRate, liquidationPeriod and minimum deposit\\n     */\\n    function getBufferAmountByFlowRate(ISuperToken token, int96 flowRate) internal view\\n        returns (uint256 bufferAmount)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getDepositRequiredForFlowRate(token, flowRate);\\n    }\\n\\n    /**\\n     * @dev get existing flow permissions\\n     * @param token The token used in flow\\n     * @param sender sender of a flow\\n     * @param flowOperator the address we are checking permissions of for sender & token\\n     * @return allowCreate is true if the flowOperator can create flows\\n     * @return allowUpdate is true if the flowOperator can update flows\\n     * @return allowDelete is true if the flowOperator can delete flows\\n     * @return flowRateAllowance The flow rate allowance the flowOperator is granted (only goes down)\\n     */\\n    function getFlowPermissions(ISuperToken token, address sender, address flowOperator)\\n        internal view\\n        returns (bool allowCreate, bool allowUpdate, bool allowDelete, int96 flowRateAllowance)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        uint8 permissionsBitmask;\\n        (, permissionsBitmask, flowRateAllowance) = cfa.getFlowOperatorData(token, sender, flowOperator);\\n        allowCreate = permissionsBitmask & 1 == 1;\\n        allowUpdate = permissionsBitmask >> 1 & 1 == 1;\\n        allowDelete = permissionsBitmask >> 2 & 1 == 1;\\n    }\\n\\n\\n     /** IDA VIEW FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Gets an index by its ID and publisher.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @return exist True if the index exists.\\n     * @return indexValue Total value of the index.\\n     * @return totalUnitsApproved Units of the index approved by subscribers.\\n     * @return totalUnitsPending Units of teh index not yet approved by subscribers.\\n     */\\n    function getIndex(ISuperToken token, address publisher, uint32 indexId)\\n        internal view\\n        returns (bool exist, uint128 indexValue, uint128 totalUnitsApproved, uint128 totalUnitsPending)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getIndex(token, publisher, indexId);\\n    }\\n\\n    /**\\n     * @dev Calculates the distribution amount based on the amount of tokens desired to distribute.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount of tokens desired to distribute.\\n     * @return actualAmount Amount to be distributed with correct rounding.\\n     * @return newIndexValue The index value after the distribution would be called.\\n     */\\n    function calculateDistribution(ISuperToken token, address publisher, uint32 indexId, uint256 amount)\\n        internal view\\n        returns (uint256 actualAmount, uint128 newIndexValue)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.calculateDistribution(token, publisher, indexId, amount);\\n    }\\n\\n    /**\\n     * @dev List all subscriptions of an address\\n     * @param token Super token used in the indexes listed.\\n     * @param subscriber Subscriber address.\\n     * @return publishers Publishers of the indices.\\n     * @return indexIds IDs of the indices.\\n     * @return unitsList Units owned of the indices.\\n     */\\n    function listSubscriptions(\\n        ISuperToken token,\\n        address subscriber\\n    )\\n        internal view\\n        returns (\\n            address[] memory publishers,\\n            uint32[] memory indexIds,\\n            uint128[] memory unitsList\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.listSubscriptions(token, subscriber);\\n    }\\n\\n    /**\\n     * @dev Gets subscription by publisher, index id, and subscriber.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber to the index.\\n     * @return exist True if the subscription exists.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscription(ISuperToken token, address publisher, uint32 indexId, address subscriber)\\n        internal view\\n        returns (bool exist, bool approved, uint128 units, uint256 pendingDistribution)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscription(token, publisher, indexId, subscriber);\\n    }\\n\\n    /*\\n     * @dev Gets subscription by the agreement ID.\\n     * @param token Super Token used with the index.\\n     * @param agreementId Agreement ID, unique to the subscriber and index ID.\\n     * @return publisher Publisher of the index.\\n     * @return indexId ID of the index.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscriptionByID(ISuperToken token, bytes32 agreementId)\\n        internal view\\n        returns (\\n            address publisher,\\n            uint32 indexId,\\n            bool approved,\\n            uint128 units,\\n            uint256 pendingDistribution\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscriptionByID(token, agreementId);\\n    }\\n\\n\\n    /** IDA BASE FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Creates a new index.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        return createIndex(token, indexId, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates a new index with userData.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates an index value. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue\\n    ) internal returns (bool) {\\n        return updateIndexValue(token, indexId, indexValue, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates an index value with userData. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of\\n     * passing the new total index value, you pass the amount of tokens desired to be distributed. \\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount - total number of tokens desired to be distributed \\n     * NOTE in many cases, there can be some precision loss \\n     This may cause a slight difference in the amount param specified and the actual amount distributed. \\n     See below for math:\\n     //indexDelta = amount the index will be updated by during an internal call to _updateIndex().\\n     It is calculated like so:\\n     indexDelta = amount / totalUnits \\n     (see the distribute() implementatation in ./agreements/InstantDistributionAgreement.sol)\\n     * NOTE Solidity does not support floating point numbers\\n     So the indexDelta will be rounded down to the nearest integer. \\n     This will create a 'remainder' amount of tokens that will not be distributed \\n     (we'll call this the 'distribution modulo')\\n     distributionModulo = amount - indexDelta * totalUnits\\n     * NOTE due to rounding, there may be a small amount of tokens left in the publisher's account\\n     This amount is equal to the 'distributionModulo' value\\n     //\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        return distribute(token, indexId, amount, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex` (w user data). Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        return approveSubscription(token, publisher, indexId, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index with user data. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        return revokeSubscription(token, publisher, indexId, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber holds\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units\\n    ) internal returns (bool) {\\n        return updateSubscriptionUnits(token, indexId, subscriber, units, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n        return deleteSubscription(token, publisher, indexId, subscriber, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero. This takes arbitrary userdata.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n        return claim(token, publisher, indexId, subscriber, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** IDA WITH CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Creates a new index with ctx.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function createIndexWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates an index value with ctx. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * Meant for usage in super app callbakcs\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param ctx from super app callback\\n     */\\n    function updateIndexValueWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`.Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param ctx from super app callback\\n     */\\n    function distributeWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function approveSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function revokeSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param ctx from super app callback\\n     */\\n    function updateSubscriptionUnitsWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero.\\n     * Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param ctx from super app callback\\n     */\\n    function deleteSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param ctx from super app callback\\n     */\\n    function claimWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    // ************** private helpers **************\\n\\n    // @note We must use hardcoded constants here because:\\n    // Only direct number constants and references to such constants are supported by inline assembly.\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.host\\\")\\n    bytes32 private constant _HOST_SLOT = 0x65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.cfa\\\")\\n    bytes32 private constant _CFA_SLOT = 0xb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.ida\\\");\\n    bytes32 private constant _IDA_SLOT = 0xa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb;\\n\\n    // gets the host and cfa addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndCFA(ISuperToken token) private\\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"))));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n            // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_CFA_SLOT, cfa)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndIDA(ISuperToken token) private\\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\"))));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n            // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_IDA_SLOT, ida)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n\\n    // gets the host and cfa addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndCFA(ISuperToken token) private view\\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"))));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndIDA(ISuperToken token) private view\\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\"))));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n}\\n\",\"keccak256\":\"0xfc49f4845cf277b157b838edfe4bdade6b680253581e6b892bc1975e9ea9445c\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Constant Flow Agreement interface\\n * @author Superfluid\\n */\\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error CFA_ACL_NO_SENDER_CREATE();               // 0x4b993136\\n    error CFA_ACL_NO_SENDER_UPDATE();               // 0xedfa0d3b\\n    error CFA_ACL_OPERATOR_NO_CREATE_PERMISSIONS(); // 0xa3eab6ac\\n    error CFA_ACL_OPERATOR_NO_UPDATE_PERMISSIONS(); // 0xac434b5f\\n    error CFA_ACL_OPERATOR_NO_DELETE_PERMISSIONS(); // 0xe30f1bff\\n    error CFA_ACL_FLOW_RATE_ALLOWANCE_EXCEEDED();   // 0xa0645c1f\\n    error CFA_ACL_UNCLEAN_PERMISSIONS();            // 0x7939d66c\\n    error CFA_ACL_NO_SENDER_FLOW_OPERATOR();        // 0xb0ed394d\\n    error CFA_ACL_NO_NEGATIVE_ALLOWANCE();          // 0x86e0377d\\n    error CFA_FLOW_ALREADY_EXISTS();                // 0x801b6863\\n    error CFA_FLOW_DOES_NOT_EXIST();                // 0x5a32bf24\\n    error CFA_INSUFFICIENT_BALANCE();               // 0xea76c9b3\\n    error CFA_ZERO_ADDRESS_SENDER();                // 0x1ce9b067\\n    error CFA_ZERO_ADDRESS_RECEIVER();              // 0x78e02b2a\\n    error CFA_HOOK_OUT_OF_GAS();                    // 0x9f76430b\\n    error CFA_DEPOSIT_TOO_BIG();                    // 0x752c2b9c\\n    error CFA_FLOW_RATE_TOO_BIG();                  // 0x0c9c55c1\\n    error CFA_NON_CRITICAL_SENDER();                // 0xce11b5d1\\n    error CFA_INVALID_FLOW_RATE();                  // 0x91acad16\\n    error CFA_NO_SELF_FLOW();                       // 0xa47338ef\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\");\\n    }\\n\\n    /**\\n     * @notice Get the maximum flow rate allowed with the deposit\\n     * @dev The deposit is clipped and rounded down\\n     * @param deposit Deposit amount used for creating the flow\\n     * @return flowRate The maximum flow rate\\n     */\\n    function getMaximumFlowRateFromDeposit(\\n        ISuperfluidToken token,\\n        uint256 deposit)\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Get the deposit required for creating the flow\\n     * @dev Calculates the deposit based on the liquidationPeriod and flowRate\\n     * @param flowRate Flow rate to be tested\\n     * @return deposit The deposit amount based on flowRate and liquidationPeriod\\n     * @custom:note\\n     * - if calculated deposit (flowRate * liquidationPeriod) is less\\n     *   than the minimum deposit, we use the minimum deposit otherwise\\n     *   we use the calculated deposit\\n     */\\n    function getDepositRequiredForFlowRate(\\n        ISuperfluidToken token,\\n        int96 flowRate)\\n        external view virtual\\n        returns (uint256 deposit);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on host.getNow()\\n     * @param account The account we are interested in\\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\\n     * @return timestamp The value of host.getNow()\\n     */\\n    function isPatricianPeriodNow(\\n        ISuperfluidToken token,\\n        address account)\\n        external view virtual\\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on timestamp\\n     * @param account The account we are interested in\\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\\n     * @return bool Whether it is currently the patrician period dictated by governance\\n     */\\n    function isPatricianPeriod(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 timestamp\\n    )\\n        public view virtual\\n        returns (bool);\\n\\n    /**\\n     * @dev msgSender from `ctx` updates permissions for the `flowOperator` with `flowRateAllowance`\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissions A bitmask representation of the granted permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowOperatorPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice msgSender from `ctx` increases flow rate allowance for the `flowOperator` by `addedFlowRateAllowance`\\n     * @dev if `addedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param addedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function increaseFlowRateAllowance(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        int96 addedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` decreases flow rate allowance for the `flowOperator` by `subtractedFlowRateAllowance`\\n     * @dev if `subtractedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param subtractedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function decreaseFlowRateAllowance(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        int96 subtractedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` increases flow rate allowance for the `flowOperator` by `addedFlowRateAllowance`\\n     * @dev if `addedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissionsToAdd A bitmask representation of the granted permissions to add as a delta\\n     * @param addedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function increaseFlowRateAllowanceWithPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissionsToAdd,\\n        int96 addedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` decreases flow rate allowance for the `flowOperator` by `subtractedFlowRateAllowance`\\n     * @dev if `subtractedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissionsToRemove A bitmask representation of the granted permissions to remove as a delta\\n     * @param subtractedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function decreaseFlowRateAllowanceWithPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissionsToRemove,\\n        int96 subtractedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` grants `flowOperator` all permissions with flowRateAllowance as type(int96).max\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n     /**\\n     * @notice msgSender from `ctx` revokes `flowOperator` create/update/delete permissions\\n     * @dev `permissions` and `flowRateAllowance` will both be set to 0\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Get the permissions of a flow operator between `sender` and `flowOperator` for `token`\\n     * @param token Super token address\\n     * @param sender The permission granter address\\n     * @param flowOperator The permission grantee address\\n     * @return flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorData(\\n       ISuperfluidToken token,\\n       address sender,\\n       address flowOperator\\n    )\\n        public view virtual\\n        returns (\\n            bytes32 flowOperatorId,\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Get flow operator using flowOperatorId\\n     * @param token Super token address\\n     * @param flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorDataByID(\\n       ISuperfluidToken token,\\n       bytes32 flowOperatorId\\n    )\\n        external view virtual\\n        returns (\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Create a flow betwen ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks\\n     * - AgreementCreated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note\\n     * - A deposit is taken as safety margin for the solvency agents\\n     * - A extra gas fee may be taken to pay for solvency agent liquidations\\n     */\\n    function createFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Create a flow between sender and receiver\\n    * @dev A flow created by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function createFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Update the flow rate between ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks\\n     * - AgreementUpdated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note\\n     * - Only the flow sender may update the flow rate\\n     * - Even if the flow rate is zero, the flow is not deleted\\n     * from the system\\n     * - Deposit amount will be adjusted accordingly\\n     * - No new gas fee is charged\\n     */\\n    function updateFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Update a flow between sender and receiver\\n    * @dev A flow updated by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function updateFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Get the flow data between `sender` and `receiver` of `token`\\n     * @param token Super token address\\n     * @param sender Flow receiver\\n     * @param receiver Flow sender\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @notice Get flow data using agreementId\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The deposit amount of the flow\\n     * @return owedDeposit The owed deposit amount of the flow\\n     */\\n    function getFlowByID(\\n       ISuperfluidToken token,\\n       bytes32 agreementId\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @dev Get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return timestamp Timestamp of when a flow was last updated for account\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getAccountFlowInfo(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @dev Get the net flow rate of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return flowRate Net flow rate\\n     */\\n    function getNetFlow(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     *\\n     * @custom:callbacks\\n     * - AgreementTerminated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note\\n     * - Both flow sender and receiver may delete the flow\\n     * - If Sender account is insolvent or in critical state, a solvency agent may\\n     *   also terminate the agreement\\n     * - Gas fee may be returned to the sender\\n     */\\n    function deleteFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev A flow deleted by an approved flow operator (see above for details on callbacks)\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     */\\n    function deleteFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Flow operator updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param flowOperator Flow operator address\\n     * @param permissions Octo bitmask representation of permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    event FlowOperatorUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    );\\n\\n    /**\\n     * @dev Flow updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param receiver Flow recipient address\\n     * @param flowRate Flow rate in amount per second for this flow\\n     * @param totalSenderFlowRate Total flow rate in amount per second for the sender\\n     * @param totalReceiverFlowRate Total flow rate in amount per second for the receiver\\n     * @param userData The user provided data\\n     *\\n     */\\n    event FlowUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed receiver,\\n        int96 flowRate,\\n        int256 totalSenderFlowRate,\\n        int256 totalReceiverFlowRate,\\n        bytes userData\\n    );\\n\\n    /**\\n     * @dev Flow updated extension event\\n     * @param flowOperator Flow operator address - the Context.msgSender\\n     * @param deposit The deposit amount for the stream\\n     */\\n    event FlowUpdatedExtension(\\n        address indexed flowOperator,\\n        uint256 deposit\\n    );\\n}\\n\",\"keccak256\":\"0xbbd5d7daa0206a39d15d349f69e6771d670c03fb394d65999f49db4fa21aeb0d\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Instant Distribution Agreement interface\\n * @author Superfluid\\n *\\n * @notice \\n *   - A publisher can create as many as indices as possibly identifiable with `indexId`.\\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\\n *       Despite knowing sha-3 collision is only theoretical.\\n *   - A publisher can create a subscription to an index for any subscriber.\\n *   - A subscription consists of:\\n *     - The index it subscribes to.\\n *     - Number of units subscribed.\\n *   - An index consists of:\\n *     - Current value as `uint128 indexValue`.\\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\\n *   - A publisher can update an index with a new value that doesn't decrease.\\n *   - A publisher can update a subscription with any number of units.\\n *   - A publisher or a subscriber can delete a subscription and reset its units to zero.\\n *   - A subscriber must approve the index in order to receive distributions from the publisher\\n *     each time the index is updated.\\n *     - The amount distributed is $$\\\\Delta{index} * units$$\\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\\n *     - the subscriber approves the subscription (side effect),\\n *     - the publisher updates the subscription (side effect),\\n *     - the subscriber deletes the subscription even if it is never approved (side effect),\\n *     - or the subscriber can explicitly claim them.\\n */\\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error IDA_INDEX_SHOULD_GROW();             // 0xcfdca725\\n    error IDA_OPERATION_NOT_ALLOWED();         // 0x92da6d17\\n    error IDA_INDEX_ALREADY_EXISTS();          // 0x5c02a517\\n    error IDA_INDEX_DOES_NOT_EXIST();          // 0xedeaa63b\\n    error IDA_SUBSCRIPTION_DOES_NOT_EXIST();   // 0xb6c8c980\\n    error IDA_SUBSCRIPTION_ALREADY_APPROVED(); // 0x3eb2f849\\n    error IDA_SUBSCRIPTION_IS_NOT_APPROVED();  // 0x37412573\\n    error IDA_INSUFFICIENT_BALANCE();          // 0x16e759bb\\n    error IDA_ZERO_ADDRESS_SUBSCRIBER();       // 0xc90a4674\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\");\\n    }\\n\\n    /**************************************************************************\\n     * Index operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Create a new index for the publisher\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function createIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n    * @dev Index created event\\n    * @param token Super token address\\n    * @param publisher Index creator and publisher\\n    * @param indexId The specified indexId of the newly created index\\n    * @param userData The user provided data\\n    */\\n    event IndexCreated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Query the data of a index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @return exist Does the index exist\\n     * @return indexValue Value of the current index\\n     * @return totalUnitsApproved Total units approved for the index\\n     * @return totalUnitsPending Total units pending approval for the index\\n     */\\n    function getIndex(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                uint128 indexValue,\\n                uint128 totalUnitsApproved,\\n                uint128 totalUnitsPending);\\n\\n    /**\\n     * @dev Calculate actual distribution amount\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @return actualAmount The amount to be distributed after ensuring no rounding errors\\n     * @return newIndexValue The index value given the desired amount of tokens to be distributed\\n     */\\n    function calculateDistribution(\\n       ISuperfluidToken token,\\n       address publisher,\\n       uint32 indexId,\\n       uint256 amount)\\n           external view\\n           virtual\\n           returns(\\n               uint256 actualAmount,\\n               uint128 newIndexValue);\\n\\n    /**\\n     * @dev Update index value of an index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param indexValue Value of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function updateIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index updated event\\n      * @param token Super token address\\n      * @param publisher Index updater and publisher\\n      * @param indexId The specified indexId of the updated index\\n      * @param oldIndexValue The previous index value\\n      * @param newIndexValue The updated index value\\n      * @param totalUnitsPending The total units pending when the indexValue was updated\\n      * @param totalUnitsApproved The total units approved when the indexValue was updated\\n      * @param userData The user provided data\\n      */\\n    event IndexUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        uint128 oldIndexValue,\\n        uint128 newIndexValue,\\n        uint128 totalUnitsPending,\\n        uint128 totalUnitsApproved,\\n        bytes userData);\\n\\n    /**\\n     * @dev Distribute tokens through the index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:note \\n     * - This is a convenient version of updateIndex. It adds to the index\\n     *   a delta that equals to `amount / totalUnits`\\n     * - The actual amount distributed could be obtained via\\n     *   `calculateDistribution`. This is due to precision error with index\\n     *   value and units data range\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function distribute(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n\\n    /**************************************************************************\\n     * Subscription operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Approve the subscription of an index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     */\\n    function approveSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index subscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The approved subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexSubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n\\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionApproved(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n    * @notice Revoke the subscription of an index\\n    * @dev \\\"Unapproves\\\" the subscription and moves approved units to pending\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function revokeSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n         external\\n         virtual\\n         returns(bytes memory newCtx);\\n    /**\\n      * @dev Index unsubscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The unsubscribed subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexUnsubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionRevoked(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Update the nuber of units of a subscription\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @param units Number of units of the subscription\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function updateSubscription(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n      * @dev Index units updated event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event IndexUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription units updated event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param indexId The specified indexId\\n      * @param publisher Index publisher\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint128 units,\\n        bytes userData);\\n\\n    /**\\n     * @dev Get data of a subscription\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @return exist Does the subscription exist?\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @notice Get data of a subscription by agreement ID\\n     * @dev indexId (agreementId) is the keccak256 hash of encodePacked(\\\"publisher\\\", publisher, indexId)\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return publisher The publisher of the index\\n     * @return indexId Id of the index\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscriptionByID(\\n        ISuperfluidToken token,\\n        bytes32 agreementId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address publisher,\\n                uint32 indexId,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @dev List subscriptions of an user\\n     * @param token Super token address\\n     * @param subscriber The subscriber's address\\n     * @return publishers Publishers of the subcriptions\\n     * @return indexIds Indexes of the subscriptions\\n     * @return unitsList Units of the subscriptions\\n     */\\n    function listSubscriptions(\\n        ISuperfluidToken token,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address[] memory publishers,\\n                uint32[] memory indexIds,\\n                uint128[] memory unitsList);\\n\\n    /**\\n     * @dev Delete the subscription of an user\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber's address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if the subscriber called it\\n     *   - AgreementTerminated callback to the publsiher:\\n     *      - agreementId is for the subscription\\n     * - if the publisher called it\\n     *   - AgreementTerminated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function deleteSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n    * @dev Claim pending distributions\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param subscriber The subscriber's address\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:note The subscription should not be approved yet\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function claim(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n        external\\n        virtual\\n        returns(bytes memory newCtx);\\n    \\n    /**\\n      * @dev Index distribution claimed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param amount The pending amount claimed\\n      */\\n    event IndexDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint256 amount);\\n    \\n    /**\\n      * @dev Subscription distribution claimed event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param amount The pending amount claimed\\n      */\\n    event SubscriptionDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint256 amount);\\n\\n}\\n\",\"keccak256\":\"0xac0ea75673feea931d1129ffff440390a0dd3a8f8cfa60fdb1481342652dc348\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\n/**\\n * @title Super app definitions library\\n * @author Superfluid\\n */\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppCallbackLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n\\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n\\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\\n    }\\n}\\n\\n/**\\n * @title Context definitions library\\n * @author Superfluid\\n */\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appCallbackLevel, uint8 callType)\\n    {\\n        appCallbackLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appCallbackLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appCallbackLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\n/**\\n * @title Flow Operator definitions library\\n  * @author Superfluid\\n */\\nlibrary FlowOperatorDefinitions {\\n   uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\\n   uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\\n   uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\\n   uint8 constant internal AUTHORIZE_FULL_CONTROL =\\n       AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\\n   uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\\n   uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\\n   uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\\n\\n   function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\\n       return (\\n           permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\\n               | AUTHORIZE_FLOW_OPERATOR_UPDATE\\n               | AUTHORIZE_FLOW_OPERATOR_DELETE)\\n           ) == uint8(0);\\n   }\\n}\\n\\n/**\\n * @title Batch operation library\\n * @author Superfluid\\n */\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev ERC777.send batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationSend(\\n     *     abi.decode(data, (address recipient, uint256 amount, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC777_SEND = 3;\\n    /**\\n     * @dev ERC20.increaseAllowance batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationIncreaseAllowance(\\n     *     abi.decode(data, (address account, address spender, uint256 addedValue))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_INCREASE_ALLOWANCE = 4;\\n    /**\\n     * @dev ERC20.decreaseAllowance batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDecreaseAllowance(\\n     *     abi.decode(data, (address account, address spender, uint256 subtractedValue))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_DECREASE_ALLOWANCE = 5;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes callData, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\n/**\\n * @title Superfluid governance configs library\\n * @author Superfluid\\n */\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\\\");\\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32)\\n    {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n\\n    function decodePPPConfig(uint256 pppConfig) internal pure\\n        returns (uint256 liquidationPeriod, uint256 patricianPeriod)\\n    {\\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\\n        patricianPeriod = pppConfig & type(uint32).max;\\n    }\\n}\\n\",\"keccak256\":\"0xdb22b7d9ef9c3bcf5b5ec64b965d371ed0fa8493486d45e5cb7f52718baec7d8\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantInflowNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\n\\ninterface IConstantInflowNFT is IFlowNFTBase {\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n    error CIF_NFT_ONLY_CONSTANT_OUTFLOW(); // 0xe81ef57a\\n\\n    /**************************************************************************\\n     * Write Functions\\n     *************************************************************************/\\n\\n    /// @notice The mint function emits the \\\"mint\\\" `Transfer` event.\\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\\n    /// is to inform clients that search for events.\\n    /// @param to the flow receiver (inflow NFT receiver)\\n    /// @param newTokenId the new token id\\n    function mint(address to, uint256 newTokenId) external;\\n\\n    /// @notice This burn function emits the \\\"burn\\\" `Transfer` event.\\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\\n    /// is to inform clients that search for events.\\n    /// @param tokenId desired token id to burn\\n    function burn(uint256 tokenId) external;\\n}\\n\",\"keccak256\":\"0xb219bf31e236fe6c2968ecf0f6c3eb24cb6774aaf4fcc83252e9b06bba718f33\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantOutflowNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\n\\ninterface IConstantOutflowNFT is IFlowNFTBase {\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n\\n    error COF_NFT_INVALID_SUPER_TOKEN();            // 0x6de98774\\n    error COF_NFT_MINT_TO_AND_FLOW_RECEIVER_SAME(); // 0x0d1d1161\\n    error COF_NFT_MINT_TO_ZERO_ADDRESS();           // 0x43d05e51\\n    error COF_NFT_ONLY_CONSTANT_INFLOW();           // 0xa495a718\\n    error COF_NFT_ONLY_FLOW_AGREEMENTS();           // 0xd367b64f\\n    error COF_NFT_TOKEN_ALREADY_EXISTS();           // 0xe2480183\\n\\n\\n    /**************************************************************************\\n     * Write Functions\\n     *************************************************************************/\\n\\n    /// @notice The onCreate function is called when a new flow is created.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onCreate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n\\n    /// @notice The onUpdate function is called when a flow is updated.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onUpdate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n\\n    /// @notice The onDelete function is called when a flow is deleted.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onDelete(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n}\\n\",\"keccak256\":\"0x15799c1552fa7aad4c1a7197451cd02422a6c768b236ab2904e72f7158a4a2c2\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IFlowNFTBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\ninterface IFlowNFTBase is IERC721Metadata {\\n    // FlowNFTData struct storage packing:\\n    // b = bits\\n    // WORD 1: | superToken      | FREE\\n    //         | 160b            | 96b\\n    // WORD 2: | flowSender      | FREE\\n    //         | 160b            | 96b\\n    // WORD 3: | flowReceiver    | flowStartDate | FREE\\n    //         | 160b            | 32b           | 64b\\n    struct FlowNFTData {\\n        address superToken;\\n        address flowSender;\\n        address flowReceiver;\\n        uint32 flowStartDate;\\n    }\\n\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n\\n    error CFA_NFT_APPROVE_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();   // 0xa3352582\\n    error CFA_NFT_APPROVE_TO_CALLER();                              // 0xd3c77329\\n    error CFA_NFT_APPROVE_TO_CURRENT_OWNER();                       // 0xe4790b25\\n    error CFA_NFT_INVALID_TOKEN_ID();                               // 0xeab95e3b\\n    error CFA_NFT_ONLY_SUPER_TOKEN_FACTORY();                       // 0xebb7505b\\n    error CFA_NFT_TRANSFER_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();  // 0x2551d606\\n    error CFA_NFT_TRANSFER_FROM_INCORRECT_OWNER();                  // 0x5a26c744\\n    error CFA_NFT_TRANSFER_IS_NOT_ALLOWED();                        // 0xaa747eca\\n    error CFA_NFT_TRANSFER_TO_ZERO_ADDRESS();                       // 0xde06d21e\\n\\n    /**************************************************************************\\n     * Events\\n     *************************************************************************/\\n\\n    /// @notice Informs third-party platforms that NFT metadata should be updated\\n    /// @dev This event comes from https://eips.ethereum.org/EIPS/eip-4906\\n    /// @param tokenId the id of the token that should have its metadata updated\\n    event MetadataUpdate(uint256 tokenId);\\n\\n    /**************************************************************************\\n     * View\\n     *************************************************************************/\\n\\n    /// @notice An external function for querying flow data by `tokenId``\\n    /// @param tokenId the token id\\n    /// @return flowData the flow data associated with `tokenId`\\n    function flowDataByTokenId(\\n        uint256 tokenId\\n    ) external view returns (FlowNFTData memory flowData);\\n\\n    /// @notice An external function for computing the deterministic tokenId\\n    /// @dev tokenId = uint256(keccak256(abi.encode(block.chainId, superToken, flowSender, flowReceiver)))\\n    /// @param superToken the super token\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    /// @return tokenId the tokenId\\n    function getTokenId(\\n        address superToken,\\n        address flowSender,\\n        address flowReceiver\\n    ) external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Write\\n     *************************************************************************/\\n\\n    function initialize(\\n        string memory nftName,\\n        string memory nftSymbol\\n    ) external; // initializer;\\n\\n    function triggerMetadataUpdate(uint256 tokenId) external;\\n}\\n\",\"keccak256\":\"0xa1600ee907288d7852678cc43f995498a039710a4f025a8785de288c4a4ceced\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IPoolAdminNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\n// TODO\\n// solhint-disable-next-line no-empty-blocks\\ninterface IPoolAdminNFT {}\\n\",\"keccak256\":\"0xa821859afd2405819b70daa367c47fc08d71b4d601effc527542862068a07403\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IPoolMemberNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\n// TODO\\n// solhint-disable-next-line no-empty-blocks\\ninterface IPoolMemberNFT {}\\n\",\"keccak256\":\"0xba6dc0dcbd8be4a96ab5f25f90977b7c71aa1eb15df1d6835ebe2b4bb46a3045\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Super agreement interface\\n * @author Superfluid\\n */\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Get the type of the agreement class\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class\\n     * @param account Account the state belongs to\\n     * @param time Time used for the calculation\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\\n     * @return deposit Account deposit amount of this agreement\\n     * @return owedDeposit Account owed deposit amount of this agreement\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\",\"keccak256\":\"0xba0407c47917aee8b6e7cea745332d2f7244cc3b91d249426f0105b365feb0ee\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\n/**\\n * @title SuperApp interface\\n * @author Superfluid\\n * @dev Be aware of the app being jailed, when the word permitted is used.\\n */\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * @custom:note \\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass arbitary information to\\n    *         the after-hook callback.\\n    *\\n    * @custom:note \\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\",\"keccak256\":\"0x9a1cbf6d6037aac2381e8e66a2ad89e9afe6f89b290c21cb587ff6b06d137ee2\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IConstantOutflowNFT } from \\\"./IConstantOutflowNFT.sol\\\";\\nimport { IConstantInflowNFT } from \\\"./IConstantInflowNFT.sol\\\";\\n\\n/**\\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\\n * @author Superfluid\\n */\\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_CALLER_IS_NOT_OPERATOR_FOR_HOLDER();       // 0xf7f02227\\n    error SUPER_TOKEN_NOT_ERC777_TOKENS_RECIPIENT();             // 0xfe737d05\\n    error SUPER_TOKEN_INFLATIONARY_DEFLATIONARY_NOT_SUPPORTED(); // 0xe3e13698\\n    error SUPER_TOKEN_NO_UNDERLYING_TOKEN();                     // 0xf79cf656\\n    error SUPER_TOKEN_ONLY_SELF();                               // 0x7ffa6648\\n    error SUPER_TOKEN_ONLY_HOST();                               // 0x98f73704\\n    error SUPER_TOKEN_ONLY_GOV_OWNER();                          // 0xd9c7ed08\\n    error SUPER_TOKEN_APPROVE_FROM_ZERO_ADDRESS();               // 0x81638627\\n    error SUPER_TOKEN_APPROVE_TO_ZERO_ADDRESS();                 // 0xdf070274\\n    error SUPER_TOKEN_BURN_FROM_ZERO_ADDRESS();                  // 0xba2ab184\\n    error SUPER_TOKEN_MINT_TO_ZERO_ADDRESS();                    // 0x0d243157\\n    error SUPER_TOKEN_TRANSFER_FROM_ZERO_ADDRESS();              // 0xeecd6c9b\\n    error SUPER_TOKEN_TRANSFER_TO_ZERO_ADDRESS();                // 0xe219bd39\\n    error SUPER_TOKEN_NFT_PROXY_ADDRESS_CHANGED();               // 0x6bef249d\\n\\n    /**\\n     * @dev Initialize the contract\\n     */\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**************************************************************************\\n    * Immutable variables\\n    *************************************************************************/\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CONSTANT_OUTFLOW_NFT() external view returns (IConstantOutflowNFT);\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CONSTANT_INFLOW_NFT() external view returns (IConstantInflowNFT);\\n\\n    /**************************************************************************\\n    * TokenInfo & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * @custom:note SuperToken always uses 18 decimals.\\n     *\\n     * This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(TokenInfo) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     *         zero by default.\\n     *\\n     * @notice This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:note Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * @custom:emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     *         allowance mechanism. `amount` is then deducted from the caller's\\n     *         allowance.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     *         means all token operations (creation, movement and destruction) must have\\n     *         amounts that are a multiple of this number.\\n     *\\n     * @custom:note For super token contracts, this value is always 1\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\\n     *      the corresponding functions will be called with `userData` and empty\\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata userData) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply and transfers the underlying token to the caller's account.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `userData` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata userData) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * @custom:emits an {AuthorizedOperator} event.\\n     *\\n     * @custom:requirements\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * @custom:emits a {RevokedOperator} event.\\n     *\\n     * @custom:requirements\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `userData` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `userData` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     * If `userData` is not empty, the `tokensReceived` hook is invoked according to ERC777 semantics.\\n     *\\n     * @custom:modifiers\\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    * If `userData` is not empty, the `tokensToSend` hook is invoked according to ERC777 semantics.\\n    *\\n    * @custom:modifiers\\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n   /**\\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\\n    * spend tokens of `sender`.\\n    *\\n    * @custom:modifiers\\n    *  - onlySelf\\n    */\\n   function selfTransferFrom(\\n        address sender,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n   ) external;\\n\\n   /**\\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\\n    * `account`.\\n    *\\n    * @custom:modifiers\\n    *  - onlySelf\\n    */\\n   function selfApproveFor(\\n        address account,\\n        address spender,\\n        uint256 amount\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to receive upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param userData User data for the TokensRecipient callback\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     *\\n     * @custom:warning\\n     * - there is potential of reentrancy IF the \\\"to\\\" account is a registered ERC777 recipient.\\n     * @custom:requirements\\n     * - if `userData` is NOT empty AND `to` is a contract, it MUST be a registered ERC777 recipient\\n     *   otherwise it reverts.\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata userData) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20 and transfer immediately\\n     * @param to The account to receive downgraded tokens\\n     * @param amount Number of tokens to be downgraded (in 18 decimals)\\n     */\\n    function downgradeTo(address to, uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are downgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    function operationIncreaseAllowance(\\n        address account,\\n        address spender,\\n        uint256 addedValue\\n    ) external;\\n\\n    function operationDecreaseAllowance(\\n        address account,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transferFrom by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC777 send by host contract.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    * @param userData Arbitrary user inputted data\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationSend(\\n        address spender,\\n        address recipient,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n    // Flow NFT events\\n    /**\\n     * @dev Constant Outflow NFT proxy created event\\n     * @param constantOutflowNFT constant outflow nft address\\n     */\\n    event ConstantOutflowNFTCreated(\\n        IConstantOutflowNFT indexed constantOutflowNFT\\n    );\\n\\n    /**\\n     * @dev Constant Inflow NFT proxy created event\\n     * @param constantInflowNFT constant inflow nft address\\n     */\\n    event ConstantInflowNFTCreated(\\n        IConstantInflowNFT indexed constantInflowNFT\\n    );\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\",\"keccak256\":\"0xa8a3d0d97b11244bb58331dc53b8152c03337b5e7907182b15bcfcfae355cdd7\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { IERC20, ERC20WithTokenInfo } from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\n\\n/**\\n * @title Super token factory interface\\n * @author Superfluid\\n */\\ninterface ISuperTokenFactory {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_FACTORY_ALREADY_EXISTS();                 // 0x91d67972\\n    error SUPER_TOKEN_FACTORY_DOES_NOT_EXIST();                 // 0x872cac48\\n    error SUPER_TOKEN_FACTORY_UNINITIALIZED();                  // 0x1b39b9b4\\n    error SUPER_TOKEN_FACTORY_ONLY_HOST();                      // 0x478b8e83\\n    error SUPER_TOKEN_FACTORY_NON_UPGRADEABLE_IS_DEPRECATED();  // 0xc4901a43\\n    error SUPER_TOKEN_FACTORY_ZERO_ADDRESS();                   // 0x305c9e82\\n\\n    /**************************************************************************\\n    * Immutable Variables\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @notice Get the canonical super token logic.\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABLE\\n    }\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     */\\n    function createERC20Wrapper(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        ERC20WithTokenInfo underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Creates a wrapper super token AND sets it in the canonical list OR reverts if it already exists\\n     * @dev salt for create2 is the keccak256 hash of abi.encode(address(_underlyingToken))\\n     * @param _underlyingToken Underlying ERC20 token\\n     * @return ISuperToken the created supertoken\\n     */\\n    function createCanonicalERC20Wrapper(ERC20WithTokenInfo _underlyingToken)\\n        external\\n        returns (ISuperToken);\\n\\n    /**\\n     * @notice Computes/Retrieves wrapper super token address given the underlying token address\\n     * @dev We return from our canonical list if it already exists, otherwise we compute it\\n     * @dev note that this function only computes addresses for SEMI_UPGRADABLE SuperTokens\\n     * @param _underlyingToken Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     * @return isDeployed whether the super token is deployed AND set in the canonical mapping\\n     */\\n    function computeCanonicalERC20WrapperAddress(address _underlyingToken)\\n        external\\n        view\\n        returns (address superTokenAddress, bool isDeployed);\\n\\n    /**\\n     * @notice Gets the canonical ERC20 wrapper super token address given the underlying token address\\n     * @dev We return the address if it exists and the zero address otherwise\\n     * @param _underlyingTokenAddress Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     */\\n    function getCanonicalERC20Wrapper(address _underlyingTokenAddress)\\n        external\\n        view\\n        returns (address superTokenAddress);\\n\\n    /**\\n     * @dev Creates a new custom super token\\n     * @param customSuperTokenProxy address of the custom supertoken proxy\\n     */\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    /**\\n      * @dev Super token logic created event\\n      * @param tokenLogic Token logic address\\n      */\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    /**\\n      * @dev Super token created event\\n      * @param token Newly created super token address\\n      */\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    /**\\n      * @dev Custom super token created event\\n      * @param token Newly created custom super token address\\n      */\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\",\"keccak256\":\"0xbfc7fbef20c707e64adabe969ea6db4d6c26a56155961a8bf46b7e55a16a046d\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\n// ISuperfluid.sol can also be used as an umbrella-import for everything Superfluid, hence we should have these unused\\n// import.\\n//\\n// solhint-disable no-unused-import\\n\\n/// Global definitions\\nimport {\\n    SuperAppDefinitions,\\n    ContextDefinitions,\\n    FlowOperatorDefinitions,\\n    BatchOperation,\\n    SuperfluidGovernanceConfigs\\n} from \\\"./Definitions.sol\\\";\\n/// Super token related interfaces:\\n/// Note: CustomSuperTokenBase is not included for people building CustomSuperToken.\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { TokenInfo, ERC20WithTokenInfo } from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperTokenFactory } from \\\"./ISuperTokenFactory.sol\\\";\\nimport { ISETH } from \\\"../tokens/ISETH.sol\\\";\\n/// Superfluid/ERC20x NFTs\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\nimport { IConstantOutflowNFT } from \\\"./IConstantOutflowNFT.sol\\\";\\nimport { IConstantInflowNFT } from \\\"./IConstantInflowNFT.sol\\\";\\nimport { IPoolAdminNFT } from \\\"./IPoolAdminNFT.sol\\\";\\nimport { IPoolMemberNFT } from \\\"./IPoolMemberNFT.sol\\\";\\n/// Superfluid agreement interfaces:\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { IConstantFlowAgreementV1 } from \\\"../agreements/IConstantFlowAgreementV1.sol\\\";\\nimport { IInstantDistributionAgreementV1 } from \\\"../agreements/IInstantDistributionAgreementV1.sol\\\";\\n/// Superfluid App interfaces:\\nimport { ISuperApp } from \\\"./ISuperApp.sol\\\";\\n/// Superfluid governance\\nimport { ISuperfluidGovernance } from \\\"./ISuperfluidGovernance.sol\\\";\\n\\n/**\\n * @title Host interface\\n * @author Superfluid\\n * @notice This is the central contract of the system where super agreement, super app\\n * and super token features are connected.\\n *\\n * The Superfluid host contract is also the entry point for the protocol users,\\n * where batch call and meta transaction are provided for UX improvements.\\n *\\n */\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    // Superfluid Custom Errors\\n    error HOST_AGREEMENT_CALLBACK_IS_NOT_ACTION();              // 0xef4295f6\\n    error HOST_CANNOT_DOWNGRADE_TO_NON_UPGRADEABLE();           // 0x474e7641\\n    error HOST_CALL_AGREEMENT_WITH_CTX_FROM_WRONG_ADDRESS();    // 0x0cd0ebc2\\n    error HOST_CALL_APP_ACTION_WITH_CTX_FROM_WRONG_ADDRESS();   // 0x473f7bd4\\n    error HOST_INVALID_CONFIG_WORD();                           // 0xf4c802a4\\n    error HOST_MAX_256_AGREEMENTS();                            // 0x7c281a78\\n    error HOST_NON_UPGRADEABLE();                               // 0x14f72c9f\\n    error HOST_NON_ZERO_LENGTH_PLACEHOLDER_CTX();               // 0x67e9985b\\n    error HOST_ONLY_GOVERNANCE();                               // 0xc5d22a4e\\n    error HOST_UNKNOWN_BATCH_CALL_OPERATION_TYPE();             // 0xb4770115\\n    error HOST_AGREEMENT_ALREADY_REGISTERED();                  // 0xdc9ddba8\\n    error HOST_AGREEMENT_IS_NOT_REGISTERED();                   // 0x1c9e9bea\\n    error HOST_MUST_BE_CONTRACT();                              // 0xd4f6b30c\\n    error HOST_ONLY_LISTED_AGREEMENT();                         // 0x619c5359\\n    error HOST_NEED_MORE_GAS();                                 // 0xd4f5d496\\n\\n    // App Related Custom Errors\\n    // uses SuperAppDefinitions' App Jail Reasons as _code\\n    error APP_RULE(uint256 _code);                              // 0xa85ba64f\\n\\n    error HOST_INVALID_OR_EXPIRED_SUPER_APP_REGISTRATION_KEY(); // 0x19ab84d1\\n    error HOST_NOT_A_SUPER_APP();                               // 0x163cbe43\\n    error HOST_NO_APP_REGISTRATION_PERMISSIONS();               // 0x5b93ebf0\\n    error HOST_RECEIVER_IS_NOT_SUPER_APP();                     // 0x96aa315e\\n    error HOST_SENDER_IS_NOT_SUPER_APP();                       // 0xbacfdc40\\n    error HOST_SOURCE_APP_NEEDS_HIGHER_APP_LEVEL();             // 0x44725270\\n    error HOST_SUPER_APP_IS_JAILED();                           // 0x02384b64\\n    error HOST_SUPER_APP_ALREADY_REGISTERED();                  // 0x01b0a935\\n    error HOST_UNAUTHORIZED_SUPER_APP_FACTORY();                // 0x289533c5\\n\\n    /**************************************************************************\\n     * Time\\n     *\\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\\n     * > Neo: Then why can't I see what happens to her?\\n     * > The Oracle: We can never see past the choices we don't understand.\\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\\n     *************************************************************************/\\n\\n    function getNow() external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governance address of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n    /**\\n     * @dev Governance replaced event\\n     * @param oldGov Address of the old governance contract\\n     * @param newGov Address of the new governance contract\\n     */\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic Initial agreement class code\\n     *\\n     * @custom:modifiers\\n     * - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class registered event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type registered\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * @custom:modifiers\\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class updated event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type updated\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n\\n    /**\\n    * @notice Check if the agreement type is whitelisted\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @notice Get agreement class\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @notice Create a new bitmask by adding a agreement class to it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @notice Create a new bitmask by removing a agreement class from it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n    /**\\n     * @dev SuperToken factory updated event\\n     * @param newFactory Address of the new factory\\n     */\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n\\n    /**\\n     * @notice Update the super token logic to the latest (canonical) implementation\\n     * if `newLogicOverride` is zero, or to `newLogicOverride` otherwise.\\n     * or to the provided implementation `.\\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\\n     */\\n    function updateSuperTokenLogic(ISuperToken token, address newLogicOverride) external;\\n    /**\\n     * @notice Update the super token logic to the provided one\\n     * @dev newLogic must implement UUPSProxiable with matching proxiableUUID\\n     */\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares itself as a super app.\\n     * @custom:deprecated you should use `registerAppWithKey` or `registerAppByFactory` instead,\\n     * because app registration is currently governance permissioned on mainnets.\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     */\\n    function registerApp(uint256 configWord) external;\\n    /**\\n     * @dev App registered event\\n     * @param app Address of jailed app\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev Message sender declares itself as a super app.\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.\\n     * @notice See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     * On testnets or in dev environment, a placeholder (e.g. empty string) can be used.\\n     * While the message sender must be the super app itself, the transaction sender (tx.origin)\\n     * must be the deployer account the registration key was issued for.\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares app as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @notice On mainnet deployments, only factory contracts pre-authorized by governance can use this.\\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app callbacklevel\\n     * @param app Super app address\\n     */\\n    function getAppCallbackLevel(ISuperApp app) external view returns(uint8 appCallbackLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The target super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app is allowed to call the target app as downstream app\\n     * @param app Super app address\\n     * @param targetApp The target super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app credit and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev (For agreements) StaticCall the app before callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return cbdata            Data returned from the callback.\\n     */\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory cbdata);\\n\\n    /**\\n     * @dev (For agreements) Call the app after callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return newCtx            The current context of the transaction.\\n     */\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Create a new callback stack\\n     * @param  ctx                     The current ctx, it will be validated.\\n     * @param  app                     The super app.\\n     * @param  appCreditGranted        App credit granted so far.\\n     * @param  appCreditUsed           App credit used so far.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appCreditGranted,\\n        int256 appCreditUsed,\\n        ISuperfluidToken appCreditToken\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Pop from the current app callback stack\\n     * @param  ctx                     The ctx that was pushed before the callback stack.\\n     * @param  appCreditUsedDelta      App credit used by the app.\\n     * @return newCtx                  The current context of the transaction.\\n     *\\n     * @custom:security\\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\\n     */\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appCreditUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Use app credit.\\n     * @param  ctx                      The current ctx, it will be validated.\\n     * @param  appCreditUsedMore        See app credit for more details.\\n     * @return newCtx                   The current context of the transaction.\\n     */\\n    function ctxUseCredit(\\n        bytes calldata ctx,\\n        int256 appCreditUsedMore\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Jail the app.\\n     * @param  app                     The super app.\\n     * @param  reason                  Jail reason code.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Jail event for the app\\n     * @param app Address of jailed app\\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param agreementClass The agreement address you are calling\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        //isAgreement(agreementClass)\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @notice Call app action\\n     * @dev Main use case is calling app action in a batch call via the host\\n     * @param callData The contextual call data\\n     *\\n     * @custom:note See \\\"Contextless Call Proxies\\\" above for more about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        //isValidAppAction(callData)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Context Struct\\n     *\\n     * @custom:note on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     * - We cannot change the structure of the Context struct because of ABI compatibility requirements\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // app callback level\\n        uint8 appCallbackLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app credit granted\\n        uint256 appCreditGranted;\\n        // app credit wanted by the app callback\\n        uint256 appCreditWantedDeprecated;\\n        // app credit used, allowing negative values over a callback session\\n        // the appCreditUsed value over a callback sessions is calculated with:\\n        // existing flow data owed deposit + sum of the callback agreements\\n        // deposit deltas\\n        // the final value used to modify the state is determined by the\\n        // _adjustNewAppCreditUsed function (in AgreementLibrary.sol) which takes\\n        // the appCreditUsed value reached in the callback session and the app\\n        // credit granted\\n        int256 appCreditUsed;\\n        // app address\\n        address appAddress;\\n        // app credit in super token\\n        ISuperfluidToken appCreditToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes memory ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation type. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations\\n     */\\n    function batchCall(Operation[] calldata operations) external;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations\\n     */\\n    function forwardBatchCall(Operation[] calldata operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage doesn't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev Require the ctx being valid.\\n     modifier requireValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev Assert the ctx being valid.\\n     modifier assertValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\",\"keccak256\":\"0x6bf8494d93a4fc67d67b4a26ea9885707014f2123acd53d7cd0fd99987e30096\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Superfluid governance interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidGovernance {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_GOV_INVALID_LIQUIDATION_OR_PATRICIAN_PERIOD(); // 0xe171980a\\n    error SF_GOV_MUST_BE_CONTRACT();                        // 0x80dddd73\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * @custom:note\\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the provided logic contracts.\\n     *      Note that this is an overloaded version taking an additional argument `tokenLogics`\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens,\\n        address[] calldata tokenLogics) external;\\n\\n    /**\\n     * @dev Set configuration as address value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        address value\\n    ) external;\\n\\n    /**\\n     * @dev Set configuration as uint256 value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        uint256 value\\n    ) external;\\n\\n    /**\\n     * @dev Clear configuration\\n     */\\n    function clearConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key\\n    ) external;\\n\\n    /**\\n     * @dev Get configuration as address value\\n     */\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /**\\n     * @dev Get configuration as uint256 value\\n     */\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\",\"keccak256\":\"0xb9328d0977bd022c6771e679518c3d2bfcb6e29b400d2506813bb3cdab772bb4\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\n\\n/**\\n * @title Superfluid token interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_TOKEN_AGREEMENT_ALREADY_EXISTS();  // 0xf05521f6\\n    error SF_TOKEN_AGREEMENT_DOES_NOT_EXIST();  // 0xdae18809\\n    error SF_TOKEN_BURN_INSUFFICIENT_BALANCE(); // 0x10ecdf44\\n    error SF_TOKEN_MOVE_INSUFFICIENT_BALANCE(); // 0x2f4cb941\\n    error SF_TOKEN_ONLY_LISTED_AGREEMENT();     // 0xc9ff6644\\n    error SF_TOKEN_ONLY_HOST();                 // 0xc51efddd\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**\\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\\n     *\\n     * @custom:note \\n     * - version: 1\\n     * - liquidationType key:\\n     *    - 0 = reward account receives reward (PIC period)\\n     *    - 1 = liquidator account receives reward (Pleb period)\\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\\n     */\\n    struct LiquidationTypeData {\\n        uint256 version;\\n        uint8 liquidationType;\\n    }\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @notice Calculate the realtime balance given the current host.getNow() value\\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\\n     * @param account for the query\\n     * @return availableBalance Real-time balance\\n     * @return deposit Account deposit\\n     * @return owedDeposit Account owed Deposit\\n     */\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @notice Check if account is critical\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @notice Check if account is critical now (current host.getNow())\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @notice Check if account is solvent\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @notice Check if account is solvent now\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @notice Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement created event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n    /**\\n     * @dev Agreement terminated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * @custom:note \\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of an agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @notice Settle balance from an account by the agreement\\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Make liquidation payouts (v2)\\n     * @param id Agreement ID\\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\\n     * @param targetAccount Account to be liquidated\\n     * @param rewardAmount The amount the rewarded account will receive\\n     * @param targetAccountBalanceDelta The delta amount the target account balance should change by\\n     *\\n     * @custom:note \\n     * - If a bailout is required (bailoutAmount > 0)\\n     *   - the actual reward (single deposit) goes to the executor,\\n     *   - while the reward account becomes the bailout account\\n     *   - total bailout include: bailout amount + reward amount\\n     *   - the targetAccount will be bailed out\\n     * - If a bailout is not required\\n     *   - the targetAccount will pay the rewardAmount\\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayoutsV2\\n    (\\n        bytes32 id,\\n        bytes memory liquidationTypeData,\\n        address liquidatorAccount,\\n        bool useDefaultRewardAccount,\\n        address targetAccount,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta\\n    ) external;\\n    /**\\n     * @dev Agreement liquidation event v2 (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param targetAccount Account of the stream sender\\n     * @param rewardAmountReceiver Account that collects the reward or bails out insolvent accounts\\n     * @param rewardAmount The amount the reward recipient account balance should change by\\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if the agreement is liquidated during the PIC period\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit)\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the targetAccount is insolvent\\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\\n     *   - the default reward account (governance) will pay for both the rewardAmount and bailoutAmount\\n     *   - the targetAccount will receive the bailoutAmount\\n     */\\n    event AgreementLiquidatedV2(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed liquidatorAccount,\\n        address indexed targetAccount,\\n        address rewardAmountReceiver,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta,\\n        bytes liquidationTypeData\\n    );\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n    /**************************************************************************\\n     * DEPRECATED\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n}\\n\",\"keccak256\":\"0x18ea972421ff57ce62103f90c820ee039f170f0189a4b3c73fd0ff09452d1dbf\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenInfo } from \\\"./TokenInfo.sol\\\";\\n\\n/**\\n * @title ERC20 token with token info interface\\n * @author Superfluid\\n * @dev Using abstract contract instead of interfaces because old solidity\\n *      does not support interface inheriting other interfaces\\n * solhint-disable-next-line no-empty-blocks\\n *\\n */\\n// solhint-disable-next-line no-empty-blocks\\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\\n\",\"keccak256\":\"0x479247ae4308ea9f5b50ff2bdae1299e91153a2c391a60e5d77cb3c980e527b9\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperToken } from \\\"../superfluid/ISuperToken.sol\\\";\\n\\n\\n/**\\n * @title Super ETH (SETH) custom token interface\\n * @author Superfluid\\n */\\ninterface ISETHCustom {\\n    // using native token\\n    function upgradeByETH() external payable;\\n    function upgradeByETHTo(address to) external payable;\\n    function downgradeToETH(uint wad) external;\\n}\\n\\n/**\\n * @title Super ETH (SETH) full interface\\n * @author Superfluid\\n */\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISETH is ISETHCustom, ISuperToken {}\\n\",\"keccak256\":\"0x9857ab20198ca28d75afcf2f6843a23a1052bf2199a308392f8e2d8a63914cbc\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\n/**\\n * @title ERC20 token info interface\\n * @author Superfluid\\n * @dev ERC20 standard interface does not specify these functions, but\\n *      often the token implementations have them.\\n */\\ninterface TokenInfo {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x5adaf0dcec7b8f91b9958c013fc3109f7b8b0efcd30391dc2bc1d98e0d406c0d\",\"license\":\"MIT\"},\"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface IV3SwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// that may remain in the router after the swap.\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// that may remain in the router after the swap.\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0xa2300af2b82af292216a8f3f301a86e65463655fff9fb791515e3fd2ccf4a14c\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x3f485fb1a44e8fbeadefb5da07d66edab3cfe809f0ac4074b1e54e3eb3c4cf69\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\",\"keccak256\":\"0x9af98b0908c96320ca6d08b22f0efca864742f6adbe5794cafe2d1d2e808b0cd\",\"license\":\"GPL-2.0-or-later\"},\"contracts/GoodCollective/IGoodCollectiveSuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IRegistry {\\n    function feeRecipient() external view returns (address);\\n\\n    function feeBps() external view returns (uint32);\\n\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n}\\n\\ninterface IGoodCollectiveSuperApp {\\n    struct Stats {\\n        uint256 netIncome; //without fees\\n        uint256 totalFees;\\n        uint256 lastUpdate;\\n        address lastFeeRecipient;\\n        int96 lastIncomeRate;\\n        address lastManagerFeeRecipient;\\n        uint256 protocolFees;\\n        uint256 managerFees;\\n        // adding fields MUST update GoodCollectiveSuperApp storage layout\\n    }\\n\\n    function getAdminFee() external view returns (address admin, uint32 feeBps);\\n\\n    function getRegistry() external view returns (IRegistry);\\n}\\n\",\"keccak256\":\"0x87ffe91490422187111c4a8f87cefb8cb8377d4890d9f870e68022e48c288b61\",\"license\":\"MIT\"},\"contracts/utils/HelperLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\nimport \\\"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\\\";\\nimport { ISuperToken } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport { SuperTokenV1Library } from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\\\";\\nimport { CFAv1Library } from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\\\";\\n\\nimport \\\"../GoodCollective/IGoodCollectiveSuperApp.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\nlibrary HelperLibrary {\\n    using SuperTokenV1Library for ISuperToken;\\n    using CFAv1Library for CFAv1Library.InitData;\\n\\n    error ZERO_AMOUNT();\\n    error ZERO_ADDRESS();\\n\\n    /**\\n     * @dev A struct containing information about a token swap\\n     * @param swapFrom The address of the token being swapped\\n     * @param amount The amount of tokens being swapped\\n     * @param minReturn The minimum amount of tokens to be received in the swap\\n     * @param timestamp The deadline for the swap to occur\\n     * @param path The path of tokens to take in a uniswap v3 multi-hop swap, encoded as bytes\\n     */\\n    struct SwapData {\\n        address swapFrom;\\n        uint256 amount;\\n        uint256 minReturn;\\n        uint256 deadline;\\n        bytes path;\\n    }\\n\\n    function handleSwap(\\n        IV3SwapRouter swapRouter,\\n        SwapData memory _customData,\\n        address outTokenIfNoPath,\\n        address _sender\\n    ) external returns (uint256 amountOut) {\\n        return handleSwap(swapRouter, _customData, outTokenIfNoPath, _sender, _sender);\\n    }\\n\\n    function handleSwap(\\n        IV3SwapRouter swapRouter,\\n        SwapData memory _customData,\\n        address outTokenIfNoPath,\\n        address _sender,\\n        address _recipient\\n    ) public returns (uint256 amountOut) {\\n        // Transfer the tokens from the sender to this contract\\n        TransferHelper.safeTransferFrom(_customData.swapFrom, _sender, address(this), _customData.amount);\\n\\n        // Approve the router to spend the tokens\\n        TransferHelper.safeApprove(_customData.swapFrom, address(swapRouter), _customData.amount);\\n\\n        if (_customData.path.length > 0) {\\n            // If a path is provided, execute a multi-hop swap\\n            IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter.ExactInputParams({\\n                path: _customData.path,\\n                recipient: _recipient,\\n                amountIn: _customData.amount,\\n                amountOutMinimum: _customData.minReturn\\n            });\\n            return swapRouter.exactInput(params);\\n        } else {\\n            // If no path is provided, execute a single-hop swap\\n            IV3SwapRouter.ExactInputSingleParams memory params = IV3SwapRouter.ExactInputSingleParams({\\n                tokenIn: _customData.swapFrom,\\n                tokenOut: outTokenIfNoPath,\\n                fee: 10000,\\n                recipient: _recipient,\\n                amountIn: _customData.amount,\\n                amountOutMinimum: _customData.minReturn,\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n            // Execute the swap using `exactInputSingle`\\n            return swapRouter.exactInputSingle(params);\\n        }\\n    }\\n\\n    function getRealtimeStats(\\n        IGoodCollectiveSuperApp.Stats memory stats,\\n        ISuperToken superToken\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 netIncome,\\n            uint256 totalFees,\\n            uint256 protocolFees,\\n            uint256 managerFees,\\n            int96 incomeFlowRate,\\n            int96 feeRate,\\n            int96 managerFeeRate\\n        )\\n    {\\n        incomeFlowRate = stats.lastIncomeRate;\\n        netIncome = stats.netIncome + uint96(stats.lastIncomeRate) * (block.timestamp - stats.lastUpdate);\\n        feeRate = superToken.getFlowRate(address(this), stats.lastFeeRecipient);\\n        managerFeeRate = superToken.getFlowRate(address(this), stats.lastManagerFeeRecipient);\\n\\n        protocolFees =\\n            stats.protocolFees +\\n            uint96(superToken.getFlowRate(address(this), stats.lastFeeRecipient)) *\\n            (block.timestamp - stats.lastUpdate);\\n        managerFees =\\n            stats.managerFees +\\n            uint96(superToken.getFlowRate(address(this), stats.lastManagerFeeRecipient)) *\\n            (block.timestamp - stats.lastUpdate);\\n        totalFees = protocolFees + managerFees;\\n    }\\n\\n    // this should be called before any flow rate changes\\n    function updateStats(\\n        IGoodCollectiveSuperApp.Stats storage stats,\\n        ISuperToken superToken,\\n        IRegistry registry,\\n        uint32 managerFeeBps,\\n        uint256 _amount\\n    ) external {\\n        uint feeBps;\\n        if (address(registry) != address(0)) {\\n            feeBps = registry.feeBps();\\n        }\\n        //use last rate before the current possible rate update\\n        stats.netIncome += uint96(stats.lastIncomeRate) * (block.timestamp - stats.lastUpdate);\\n        if (stats.lastFeeRecipient != address(0)) {\\n            //fees sent to last recipient, the flowRate to recipient still wasnt updated.\\n            stats.protocolFees +=\\n                uint96(superToken.getFlowRate(address(this), stats.lastFeeRecipient)) *\\n                (block.timestamp - stats.lastUpdate);\\n        }\\n        if (stats.lastManagerFeeRecipient != address(0)) {\\n            //fees sent to last recipient, the flowRate to recipient still wasnt updated.\\n            stats.managerFees +=\\n                uint96(superToken.getFlowRate(address(this), stats.lastManagerFeeRecipient)) *\\n                (block.timestamp - stats.lastUpdate);\\n        }\\n\\n        if (_amount > 0) {\\n            stats.netIncome += (_amount * (10000 - feeBps - managerFeeBps)) / 10000;\\n            stats.protocolFees += (_amount * feeBps) / 10000;\\n            stats.managerFees += (_amount * managerFeeBps) / 10000;\\n        }\\n        stats.totalFees = stats.managerFees + stats.protocolFees;\\n        stats.lastUpdate = block.timestamp;\\n    }\\n\\n    function takeFeeFlow(\\n        CFAv1Library.InitData storage cfaV1,\\n        ISuperToken superToken,\\n        address prevRecipient,\\n        address recipient,\\n        uint32 feeBps,\\n        int96 _diffRate,\\n        bytes memory _ctx\\n    ) public returns (bytes memory newCtx) {\\n        newCtx = _ctx;\\n        if (address(recipient) == address(0)) return newCtx;\\n        int96 curFeeRate = superToken.getFlowRate(address(this), prevRecipient);\\n        bool newRecipient;\\n        if (recipient != prevRecipient) {\\n            newRecipient = true;\\n            if (prevRecipient != address(0)) {\\n                //delete old recipient flow\\n                if (curFeeRate > 0) newCtx = cfaV1.deleteFlowWithCtx(newCtx, address(this), prevRecipient, superToken); //passing in the ctx which is sent to the callback here\\n            }\\n        }\\n        if (recipient == address(0)) return newCtx;\\n\\n        int96 newFeeRate = curFeeRate + (_diffRate * int32(feeBps)) / 10000;\\n        if (newRecipient == false && curFeeRate > 0) {\\n            if (newFeeRate <= 0) {\\n                newCtx = cfaV1.deleteFlowWithCtx(newCtx, address(this), recipient, superToken); //passing in the ctx which is sent to the callback here\\n            } else {\\n                newCtx = cfaV1.updateFlowWithCtx(newCtx, recipient, superToken, newFeeRate); //passing in the ctx which is sent to the callback here\\n            }\\n        } else if (newFeeRate > 0) newCtx = cfaV1.createFlowWithCtx(newCtx, recipient, superToken, newFeeRate); //passing in the ctx which is sent to the callback here\\n    }\\n\\n    function recoverFunds(ISuperToken superToken, address recipient, uint256 amount) external {\\n        require(IGoodCollectiveSuperApp(address(this)).getRegistry().hasRole(0x00, msg.sender), \\\"not owner\\\");\\n        if (amount == 0) revert ZERO_AMOUNT();\\n        if (recipient == address(0)) revert ZERO_ADDRESS();\\n        superToken.transfer(recipient, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x6d8233512240bd172cb29df788922ced3b9fbd2c324501cd4824faca2bd53fc2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61191661003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061006c5760003560e01c806321437a53146100715780634d167a90146100a457806358c0dacb146100d157806365a99a06146100f1578063934e2cce14610113578063b2f918a114610133575b600080fd5b81801561007d57600080fd5b5061009161008c3660046111a0565b610184565b6040519081526020015b60405180910390f35b8180156100b057600080fd5b506100c46100bf366004611255565b610318565b60405161009b9190611348565b8180156100dd57600080fd5b506100916100ec366004611362565b610434565b8180156100fd57600080fd5b5061011161010c3660046113d6565b610443565b005b81801561011f57600080fd5b5061011161012e366004611417565b610612565b610146610141366004611472565b61088b565b604080519788526020880196909652948601939093526060850191909152600b90810b608085015290810b60a08401520b60c082015260e00161009b565b600061019a8560000151843088602001516109d1565b6101ad8560000151878760200151610adb565b6080850151511561025c57604080516080808201835287015181526001600160a01b0380851660208084019190915288015182840152878301516060830152915163b858183f60e01b8152909188169063b858183f9061021190849060040161151b565b6020604051808303816000875af1158015610230573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102549190611569565b91505061030f565b6040805160e08101825286516001600160a01b039081168252868116602080840191825261271084860190815287841660608601908152918b0151608086019081528b87015160a08701908152600060c0880190815297516304e45aaf60e01b8152875187166004820152945186166024860152915162ffffff166044850152915184166064840152905160848301525160a48201529251811660c48401529091908816906304e45aaf9060e401610211565b95945050505050565b806001600160a01b0385161561042957600061033e6001600160a01b0389163089610be5565b90506000876001600160a01b0316876001600160a01b031614610389575060016001600160a01b0388161561038957600082600b0b1315610389576103868a84308b8d610c7d565b92505b6001600160a01b03871661039e575050610429565b60006127106103b1600389900b88611598565b6103bb91906115d5565b6103c59084611613565b9050811580156103d85750600083600b0b135b1561040957600081600b0b136103fc576103f58b85308b8e610c7d565b9350610425565b6103f58b858a8d85610cac565b600081600b0b1315610425576104228b858a8d85610cd1565b93505b5050505b979650505050505050565b600061030f8585858586610184565b306001600160a01b0316635ab1bd536040518163ffffffff1660e01b8152600401602060405180830381865afa158015610481573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104a59190611646565b604051632474521560e21b8152600060048201523360248201526001600160a01b0391909116906391d1485490604401602060405180830381865afa1580156104f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105169190611663565b6105535760405162461bcd60e51b81526020600482015260096024820152683737ba1037bbb732b960b91b60448201526064015b60405180910390fd5b8060000361057457604051630f6fa54560e41b815260040160405180910390fd5b6001600160a01b03821661059b5760405163538ba4f960e01b815260040160405180910390fd5b60405163a9059cbb60e01b81526001600160a01b0384169063a9059cbb906105c99085908590600401611685565b6020604051808303816000875af11580156105e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060c9190611663565b50505050565b60006001600160a01b0384161561068e57836001600160a01b03166324a9d8536040518163ffffffff1660e01b8152600401602060405180830381865afa158015610661573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610685919061169e565b63ffffffff1690505b600286015461069d90426116bb565b60038701546106bc9190600160a01b90046001600160601b03166116ce565b8660000160008282546106cf91906116e5565b909155505060038601546001600160a01b03161561073f5760028601546106f690426116bb565b6003870154610713906001600160a01b0388811691309116610be5565b6001600160601b031661072691906116ce565b86600501600082825461073991906116e5565b90915550505b60048601546001600160a01b0316156107aa57600286015461076190426116bb565b600487015461077e906001600160a01b0388811691309116610be5565b6001600160601b031661079191906116ce565b8660060160008282546107a491906116e5565b90915550505b81156108615761271063ffffffff84166107c483836116bb565b6107ce91906116bb565b6107d890846116ce565b6107e291906116f8565b8660000160008282546107f591906116e5565b90915550612710905061080882846116ce565b61081291906116f8565b86600501600082825461082591906116e5565b90915550612710905061083e63ffffffff8516846116ce565b61084891906116f8565b86600601600082825461085b91906116e5565b90915550505b8560050154866006015461087591906116e5565b6001870155505042600290940193909355505050565b6000806000806000806000886080015192508860400151426108ad91906116bb565b89608001516001600160601b03166108c591906116ce565b89516108d191906116e5565b96506108f5308a606001518a6001600160a01b0316610be59092919063ffffffff16565b9150610919308a60a001518a6001600160a01b0316610be59092919063ffffffff16565b905088604001514261092b91906116bb565b60608a0151610946906001600160a01b038b16903090610be5565b6001600160601b031661095991906116ce565b8960c0015161096891906116e5565b945088604001514261097a91906116bb565b60a08a0151610995906001600160a01b038b16903090610be5565b6001600160601b03166109a891906116ce565b8960e001516109b791906116e5565b93506109c384866116e5565b955092959891949750929550565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b1790529151600092839290881691610a35919061170c565b6000604051808303816000865af19150503d8060008114610a72576040519150601f19603f3d011682016040523d82523d6000602084013e610a77565b606091505b5091509150818015610aa1575080511580610aa1575080806020019051810190610aa19190611663565b610ad35760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b604482015260640161054a565b505050505050565b600080846001600160a01b031663095ea7b360e01b8585604051602401610b03929190611685565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051610b41919061170c565b6000604051808303816000865af19150503d8060008114610b7e576040519150601f19603f3d011682016040523d82523d6000602084013e610b83565b606091505b5091509150818015610bad575080511580610bad575080806020019051810190610bad9190611663565b610bde5760405162461bcd60e51b8152602060048201526002602482015261534160f01b604482015260640161054a565b5050505050565b600080610bf185610cf6565b604051631cd43d1160e31b81526001600160a01b03888116600483015287811660248301528681166044830152919350908316915063e6a1e88890606401608060405180830381865afa158015610c4c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c709190611728565b5090979650505050505050565b604080516000815260208101909152606090610ca29087908790879087908790610e77565b9695505050505050565b604080516000815260208101909152606090610ca29087908790879087908790610f60565b604080516000815260208101909152606090610ca29087908790879087908790610fc7565b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a546001600160a01b038116610e46576001600160a01b038216610dbb57826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610db89190611646565b91505b604051635b69006f60e11b81527fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd360048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015610e1f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e439190611646565b90505b6001600160a01b038216610e5c57610e5c611766565b6001600160a01b038116610e7257610e72611766565b915091565b855460018701546040805160008152602081019091526060926001600160a01b0390811692634329d29392911690819063b4b333c690610ec09089908c908c906044810161177c565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b0319168252610f0d9392509087908c906004016117b0565b6000604051808303816000875af1158015610f2c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610f549190810190611847565b50979650505050505050565b855460018701546060916001600160a01b0390811691634329d2939116806350209a62888a8960005b6040519080825280601f01601f191660200182016040528015610fb3576020820181803683370190505b50604051602401610ec094939291906118aa565b855460018701546060916001600160a01b0390811691634329d2939116806362fc305e888a896000610f89565b6001600160a01b038116811461100957600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60405161010081016001600160401b03811182821017156110455761104561100c565b60405290565b604051601f8201601f191681016001600160401b03811182821017156110735761107361100c565b604052919050565b803561108681610ff4565b919050565b60006001600160401b038211156110a4576110a461100c565b50601f01601f191660200190565b600082601f8301126110c357600080fd5b81356110d66110d18261108b565b61104b565b8181528460208386010111156110eb57600080fd5b816020850160208301376000918101602001919091529392505050565b600060a0828403121561111a57600080fd5b60405160a081016001600160401b03808211838310171561113d5761113d61100c565b816040528293508435915061115182610ff4565b818352602085013560208401526040850135604084015260608501356060840152608085013591508082111561118657600080fd5b50611193858286016110b2565b6080830152505092915050565b600080600080600060a086880312156111b857600080fd5b85356111c381610ff4565b945060208601356001600160401b038111156111de57600080fd5b6111ea88828901611108565b94505060408601356111fb81610ff4565b9250606086013561120b81610ff4565b9150608086013561121b81610ff4565b809150509295509295909350565b63ffffffff8116811461100957600080fd5b80600b0b811461100957600080fd5b80356110868161123b565b600080600080600080600060e0888a03121561127057600080fd5b87359650602088013561128281610ff4565b9550604088013561129281610ff4565b945060608801356112a281610ff4565b935060808801356112b281611229565b925060a08801356112c28161123b565b915060c08801356001600160401b038111156112dd57600080fd5b6112e98a828b016110b2565b91505092959891949750929550565b60005b838110156113135781810151838201526020016112fb565b50506000910152565b600081518084526113348160208601602086016112f8565b601f01601f19169290920160200192915050565b60208152600061135b602083018461131c565b9392505050565b6000806000806080858703121561137857600080fd5b843561138381610ff4565b935060208501356001600160401b0381111561139e57600080fd5b6113aa87828801611108565b93505060408501356113bb81610ff4565b915060608501356113cb81610ff4565b939692955090935050565b6000806000606084860312156113eb57600080fd5b83356113f681610ff4565b9250602084013561140681610ff4565b929592945050506040919091013590565b600080600080600060a0868803121561142f57600080fd5b85359450602086013561144181610ff4565b9350604086013561145181610ff4565b9250606086013561146181611229565b949793965091946080013592915050565b60008082840361012081121561148757600080fd5b6101008082121561149757600080fd5b61149f611022565b915084358252602085013560208301526040850135604083015260608501356114c781610ff4565b60608301526114d86080860161124a565b60808301526114e960a0860161107b565b60a083015260c085013560c083015260e085013560e083015281935061151081860161107b565b925050509250929050565b60208152600082516080602084015261153760a084018261131c565b905060018060a01b03602085015116604084015260408401516060840152606084015160808401528091505092915050565b60006020828403121561157b57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b600082600b0b82600b0b0280600b0b91508082146115b8576115b8611582565b5092915050565b634e487b7160e01b600052601260045260246000fd5b600081600b0b83600b0b806115ec576115ec6115bf565b60016001605f1b031982146000198214161561160a5761160a611582565b90059392505050565b600b81810b9083900b0160016001605f1b03811360016001605f1b03198212171561164057611640611582565b92915050565b60006020828403121561165857600080fd5b815161135b81610ff4565b60006020828403121561167557600080fd5b8151801515811461135b57600080fd5b6001600160a01b03929092168252602082015260400190565b6000602082840312156116b057600080fd5b815161135b81611229565b8181038181111561164057611640611582565b808202811582820484141761164057611640611582565b8082018082111561164057611640611582565b600082611707576117076115bf565b500490565b6000825161171e8184602087016112f8565b9190910192915050565b6000806000806080858703121561173e57600080fd5b8451935060208501516117508161123b565b6040860151606090960151949790965092505050565b634e487b7160e01b600052600160045260246000fd5b6001600160a01b038581168252848116602083015283166040820152608060608201819052600090610ca29083018461131c565b6001600160a01b03851681526080602082018190526000906117d49083018661131c565b82810360408401526117e6818661131c565b90508281036060840152610429818561131c565b600082601f83011261180b57600080fd5b81516118196110d18261108b565b81815284602083860101111561182e57600080fd5b61183f8260208301602087016112f8565b949350505050565b6000806040838503121561185a57600080fd5b82516001600160401b038082111561187157600080fd5b61187d868387016117fa565b9350602085015191508082111561189357600080fd5b506118a0858286016117fa565b9150509250929050565b6001600160a01b03858116825284166020820152600b83900b6040820152608060608201819052600090610ca29083018461131c56fea2646970667358221220e739c45f68397b23574712a5795db305f86359225ffc9500481c7ed7ed7f406064736f6c63430008130033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061006c5760003560e01c806321437a53146100715780634d167a90146100a457806358c0dacb146100d157806365a99a06146100f1578063934e2cce14610113578063b2f918a114610133575b600080fd5b81801561007d57600080fd5b5061009161008c3660046111a0565b610184565b6040519081526020015b60405180910390f35b8180156100b057600080fd5b506100c46100bf366004611255565b610318565b60405161009b9190611348565b8180156100dd57600080fd5b506100916100ec366004611362565b610434565b8180156100fd57600080fd5b5061011161010c3660046113d6565b610443565b005b81801561011f57600080fd5b5061011161012e366004611417565b610612565b610146610141366004611472565b61088b565b604080519788526020880196909652948601939093526060850191909152600b90810b608085015290810b60a08401520b60c082015260e00161009b565b600061019a8560000151843088602001516109d1565b6101ad8560000151878760200151610adb565b6080850151511561025c57604080516080808201835287015181526001600160a01b0380851660208084019190915288015182840152878301516060830152915163b858183f60e01b8152909188169063b858183f9061021190849060040161151b565b6020604051808303816000875af1158015610230573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102549190611569565b91505061030f565b6040805160e08101825286516001600160a01b039081168252868116602080840191825261271084860190815287841660608601908152918b0151608086019081528b87015160a08701908152600060c0880190815297516304e45aaf60e01b8152875187166004820152945186166024860152915162ffffff166044850152915184166064840152905160848301525160a48201529251811660c48401529091908816906304e45aaf9060e401610211565b95945050505050565b806001600160a01b0385161561042957600061033e6001600160a01b0389163089610be5565b90506000876001600160a01b0316876001600160a01b031614610389575060016001600160a01b0388161561038957600082600b0b1315610389576103868a84308b8d610c7d565b92505b6001600160a01b03871661039e575050610429565b60006127106103b1600389900b88611598565b6103bb91906115d5565b6103c59084611613565b9050811580156103d85750600083600b0b135b1561040957600081600b0b136103fc576103f58b85308b8e610c7d565b9350610425565b6103f58b858a8d85610cac565b600081600b0b1315610425576104228b858a8d85610cd1565b93505b5050505b979650505050505050565b600061030f8585858586610184565b306001600160a01b0316635ab1bd536040518163ffffffff1660e01b8152600401602060405180830381865afa158015610481573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104a59190611646565b604051632474521560e21b8152600060048201523360248201526001600160a01b0391909116906391d1485490604401602060405180830381865afa1580156104f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105169190611663565b6105535760405162461bcd60e51b81526020600482015260096024820152683737ba1037bbb732b960b91b60448201526064015b60405180910390fd5b8060000361057457604051630f6fa54560e41b815260040160405180910390fd5b6001600160a01b03821661059b5760405163538ba4f960e01b815260040160405180910390fd5b60405163a9059cbb60e01b81526001600160a01b0384169063a9059cbb906105c99085908590600401611685565b6020604051808303816000875af11580156105e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060c9190611663565b50505050565b60006001600160a01b0384161561068e57836001600160a01b03166324a9d8536040518163ffffffff1660e01b8152600401602060405180830381865afa158015610661573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610685919061169e565b63ffffffff1690505b600286015461069d90426116bb565b60038701546106bc9190600160a01b90046001600160601b03166116ce565b8660000160008282546106cf91906116e5565b909155505060038601546001600160a01b03161561073f5760028601546106f690426116bb565b6003870154610713906001600160a01b0388811691309116610be5565b6001600160601b031661072691906116ce565b86600501600082825461073991906116e5565b90915550505b60048601546001600160a01b0316156107aa57600286015461076190426116bb565b600487015461077e906001600160a01b0388811691309116610be5565b6001600160601b031661079191906116ce565b8660060160008282546107a491906116e5565b90915550505b81156108615761271063ffffffff84166107c483836116bb565b6107ce91906116bb565b6107d890846116ce565b6107e291906116f8565b8660000160008282546107f591906116e5565b90915550612710905061080882846116ce565b61081291906116f8565b86600501600082825461082591906116e5565b90915550612710905061083e63ffffffff8516846116ce565b61084891906116f8565b86600601600082825461085b91906116e5565b90915550505b8560050154866006015461087591906116e5565b6001870155505042600290940193909355505050565b6000806000806000806000886080015192508860400151426108ad91906116bb565b89608001516001600160601b03166108c591906116ce565b89516108d191906116e5565b96506108f5308a606001518a6001600160a01b0316610be59092919063ffffffff16565b9150610919308a60a001518a6001600160a01b0316610be59092919063ffffffff16565b905088604001514261092b91906116bb565b60608a0151610946906001600160a01b038b16903090610be5565b6001600160601b031661095991906116ce565b8960c0015161096891906116e5565b945088604001514261097a91906116bb565b60a08a0151610995906001600160a01b038b16903090610be5565b6001600160601b03166109a891906116ce565b8960e001516109b791906116e5565b93506109c384866116e5565b955092959891949750929550565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b1790529151600092839290881691610a35919061170c565b6000604051808303816000865af19150503d8060008114610a72576040519150601f19603f3d011682016040523d82523d6000602084013e610a77565b606091505b5091509150818015610aa1575080511580610aa1575080806020019051810190610aa19190611663565b610ad35760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b604482015260640161054a565b505050505050565b600080846001600160a01b031663095ea7b360e01b8585604051602401610b03929190611685565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051610b41919061170c565b6000604051808303816000865af19150503d8060008114610b7e576040519150601f19603f3d011682016040523d82523d6000602084013e610b83565b606091505b5091509150818015610bad575080511580610bad575080806020019051810190610bad9190611663565b610bde5760405162461bcd60e51b8152602060048201526002602482015261534160f01b604482015260640161054a565b5050505050565b600080610bf185610cf6565b604051631cd43d1160e31b81526001600160a01b03888116600483015287811660248301528681166044830152919350908316915063e6a1e88890606401608060405180830381865afa158015610c4c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c709190611728565b5090979650505050505050565b604080516000815260208101909152606090610ca29087908790879087908790610e77565b9695505050505050565b604080516000815260208101909152606090610ca29087908790879087908790610f60565b604080516000815260208101909152606090610ca29087908790879087908790610fc7565b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a546001600160a01b038116610e46576001600160a01b038216610dbb57826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610db89190611646565b91505b604051635b69006f60e11b81527fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd360048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015610e1f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e439190611646565b90505b6001600160a01b038216610e5c57610e5c611766565b6001600160a01b038116610e7257610e72611766565b915091565b855460018701546040805160008152602081019091526060926001600160a01b0390811692634329d29392911690819063b4b333c690610ec09089908c908c906044810161177c565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b0319168252610f0d9392509087908c906004016117b0565b6000604051808303816000875af1158015610f2c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610f549190810190611847565b50979650505050505050565b855460018701546060916001600160a01b0390811691634329d2939116806350209a62888a8960005b6040519080825280601f01601f191660200182016040528015610fb3576020820181803683370190505b50604051602401610ec094939291906118aa565b855460018701546060916001600160a01b0390811691634329d2939116806362fc305e888a896000610f89565b6001600160a01b038116811461100957600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60405161010081016001600160401b03811182821017156110455761104561100c565b60405290565b604051601f8201601f191681016001600160401b03811182821017156110735761107361100c565b604052919050565b803561108681610ff4565b919050565b60006001600160401b038211156110a4576110a461100c565b50601f01601f191660200190565b600082601f8301126110c357600080fd5b81356110d66110d18261108b565b61104b565b8181528460208386010111156110eb57600080fd5b816020850160208301376000918101602001919091529392505050565b600060a0828403121561111a57600080fd5b60405160a081016001600160401b03808211838310171561113d5761113d61100c565b816040528293508435915061115182610ff4565b818352602085013560208401526040850135604084015260608501356060840152608085013591508082111561118657600080fd5b50611193858286016110b2565b6080830152505092915050565b600080600080600060a086880312156111b857600080fd5b85356111c381610ff4565b945060208601356001600160401b038111156111de57600080fd5b6111ea88828901611108565b94505060408601356111fb81610ff4565b9250606086013561120b81610ff4565b9150608086013561121b81610ff4565b809150509295509295909350565b63ffffffff8116811461100957600080fd5b80600b0b811461100957600080fd5b80356110868161123b565b600080600080600080600060e0888a03121561127057600080fd5b87359650602088013561128281610ff4565b9550604088013561129281610ff4565b945060608801356112a281610ff4565b935060808801356112b281611229565b925060a08801356112c28161123b565b915060c08801356001600160401b038111156112dd57600080fd5b6112e98a828b016110b2565b91505092959891949750929550565b60005b838110156113135781810151838201526020016112fb565b50506000910152565b600081518084526113348160208601602086016112f8565b601f01601f19169290920160200192915050565b60208152600061135b602083018461131c565b9392505050565b6000806000806080858703121561137857600080fd5b843561138381610ff4565b935060208501356001600160401b0381111561139e57600080fd5b6113aa87828801611108565b93505060408501356113bb81610ff4565b915060608501356113cb81610ff4565b939692955090935050565b6000806000606084860312156113eb57600080fd5b83356113f681610ff4565b9250602084013561140681610ff4565b929592945050506040919091013590565b600080600080600060a0868803121561142f57600080fd5b85359450602086013561144181610ff4565b9350604086013561145181610ff4565b9250606086013561146181611229565b949793965091946080013592915050565b60008082840361012081121561148757600080fd5b6101008082121561149757600080fd5b61149f611022565b915084358252602085013560208301526040850135604083015260608501356114c781610ff4565b60608301526114d86080860161124a565b60808301526114e960a0860161107b565b60a083015260c085013560c083015260e085013560e083015281935061151081860161107b565b925050509250929050565b60208152600082516080602084015261153760a084018261131c565b905060018060a01b03602085015116604084015260408401516060840152606084015160808401528091505092915050565b60006020828403121561157b57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b600082600b0b82600b0b0280600b0b91508082146115b8576115b8611582565b5092915050565b634e487b7160e01b600052601260045260246000fd5b600081600b0b83600b0b806115ec576115ec6115bf565b60016001605f1b031982146000198214161561160a5761160a611582565b90059392505050565b600b81810b9083900b0160016001605f1b03811360016001605f1b03198212171561164057611640611582565b92915050565b60006020828403121561165857600080fd5b815161135b81610ff4565b60006020828403121561167557600080fd5b8151801515811461135b57600080fd5b6001600160a01b03929092168252602082015260400190565b6000602082840312156116b057600080fd5b815161135b81611229565b8181038181111561164057611640611582565b808202811582820484141761164057611640611582565b8082018082111561164057611640611582565b600082611707576117076115bf565b500490565b6000825161171e8184602087016112f8565b9190910192915050565b6000806000806080858703121561173e57600080fd5b8451935060208501516117508161123b565b6040860151606090960151949790965092505050565b634e487b7160e01b600052600160045260246000fd5b6001600160a01b038581168252848116602083015283166040820152608060608201819052600090610ca29083018461131c565b6001600160a01b03851681526080602082018190526000906117d49083018661131c565b82810360408401526117e6818661131c565b90508281036060840152610429818561131c565b600082601f83011261180b57600080fd5b81516118196110d18261108b565b81815284602083860101111561182e57600080fd5b61183f8260208301602087016112f8565b949350505050565b6000806040838503121561185a57600080fd5b82516001600160401b038082111561187157600080fd5b61187d868387016117fa565b9350602085015191508082111561189357600080fd5b506118a0858286016117fa565b9150509250929050565b6001600160a01b03858116825284166020820152600b83900b6040820152608060608201819052600090610ca29083018461131c56fea2646970667358221220e739c45f68397b23574712a5795db305f86359225ffc9500481c7ed7ed7f406064736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}

{
  "address": "0xE9a499b3ceED8512e67aA8b21EaACf109006207a",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ISuperfluid",
          "name": "_host",
          "type": "address"
        },
        {
          "internalType": "contract IV3SwapRouter",
          "name": "_swapRouter",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "whitelistedRoot",
          "type": "address"
        }
      ],
      "name": "ALREADY_CLAIMED",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CLAIMFOR_DISABLED",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EMPTY_MANAGER",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int96",
          "name": "curFeeRate",
          "type": "int96"
        },
        {
          "internalType": "int96",
          "name": "newFeeRate",
          "type": "int96"
        }
      ],
      "name": "FEE_FLOW_FAILED",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "INVALID_0_VALUE",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MAX_MEMBERS_REACHED",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "claimers",
          "type": "uint256"
        }
      ],
      "name": "MAX_PERIOD_CLAIMERS_REACHED",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int96",
          "name": "flowRate",
          "type": "int96"
        }
      ],
      "name": "MIN_FLOWRATE",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "manager",
          "type": "address"
        }
      ],
      "name": "NOT_MANAGER",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "claimer",
          "type": "address"
        }
      ],
      "name": "NOT_MEMBER",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "whitelistedRoot",
          "type": "address"
        }
      ],
      "name": "NOT_WHITELISTED",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAcceptedSuperToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotImplemented",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "ONLY_HOST_OR_SENDER",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UNSUPPORTED_TOKEN",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnauthorizedHost",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZERO_ADDRESS",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZERO_AMOUNT",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "previousAdmin",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        }
      ],
      "name": "AdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "beacon",
          "type": "address"
        }
      ],
      "name": "BeaconUpgraded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "manager",
              "type": "address"
            },
            {
              "internalType": "contract IMembersValidator",
              "name": "membersValidator",
              "type": "address"
            },
            {
              "internalType": "contract IIdentityV2",
              "name": "uniquenessValidator",
              "type": "address"
            },
            {
              "internalType": "contract IERC20Upgradeable",
              "name": "rewardToken",
              "type": "address"
            }
          ],
          "indexed": false,
          "internalType": "struct PoolSettings",
          "name": "settings",
          "type": "tuple"
        }
      ],
      "name": "PoolSettingsChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "supporter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "previousContribution",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "contribution",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "int96",
          "name": "previousFlowRate",
          "type": "int96"
        },
        {
          "indexed": false,
          "internalType": "int96",
          "name": "flowRate",
          "type": "int96"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isFlowUpdate",
          "type": "bool"
        }
      ],
      "name": "SupporterUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "day",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "dailyUbi",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "periodClaimers",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "periodDistributed",
          "type": "uint256"
        }
      ],
      "name": "UBICalculated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "whitelistedRoot",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "claimer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "UBIClaimed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "day",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "pool",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "cycleLength",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "dailyUBIPool",
          "type": "uint256"
        }
      ],
      "name": "UBICycleCalculated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "cycleLengthDays",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "claimPeriodDays",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "minActiveUsers",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "claimForEnabled",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "maxClaimAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "maxMembers",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "onlyMembers",
              "type": "bool"
            }
          ],
          "indexed": false,
          "internalType": "struct UBIPool.UBISettings",
          "name": "settings",
          "type": "tuple"
        }
      ],
      "name": "UBISettingsChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Upgraded",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CFAV1_TYPE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DEFAULT_ADMIN_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MANAGER_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MEMBER_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_FLOW_RATE",
      "outputs": [
        {
          "internalType": "int96",
          "name": "",
          "type": "int96"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "addMember",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isMember",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "agreementData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "ctx",
          "type": "bytes"
        }
      ],
      "name": "afterAgreementCreated",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "newCtx",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "agreementClass",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "agreementData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "cbdata",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "ctx",
          "type": "bytes"
        }
      ],
      "name": "afterAgreementTerminated",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "newCtx",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "agreementData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "cbdata",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "ctx",
          "type": "bytes"
        }
      ],
      "name": "afterAgreementUpdated",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "newCtx",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "agreementClass",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "beforeAgreementCreated",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "agreementClass",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "agreementData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "beforeAgreementTerminated",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "agreementClass",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "agreementData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "beforeAgreementUpdated",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cfaV1",
      "outputs": [
        {
          "internalType": "contract ISuperfluid",
          "name": "host",
          "type": "address"
        },
        {
          "internalType": "contract IConstantFlowAgreementV1",
          "name": "cfa",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_member",
          "type": "address"
        }
      ],
      "name": "checkEntitlement",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "checkEntitlement",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "claimer",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "sendToWhitelistedRoot",
          "type": "bool"
        }
      ],
      "name": "claimFor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentDayInCycle",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "distributionFormula",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "estimateNextDailyUBI",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nextDailyUbi",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "extendedSettings",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "maxPeriodClaimers",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "minClaimAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "managerFeeBps",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentDay",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getManagerFee",
      "outputs": [
        {
          "internalType": "address",
          "name": "feeRecipient",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "feeBps",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "getRealtimeContribution",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getRealtimeStats",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "netIncome",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalFees",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "protocolFees",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "managerFees",
          "type": "uint256"
        },
        {
          "internalType": "int96",
          "name": "incomeFlowRate",
          "type": "int96"
        },
        {
          "internalType": "int96",
          "name": "feeRate",
          "type": "int96"
        },
        {
          "internalType": "int96",
          "name": "managerFeeRate",
          "type": "int96"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getRegistry",
      "outputs": [
        {
          "internalType": "contract IRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        }
      ],
      "name": "getRoleAdmin",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "grantRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "swapFrom",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minReturn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "path",
              "type": "bytes"
            }
          ],
          "internalType": "struct HelperLibrary.SwapData",
          "name": "_customData",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_ctx",
          "type": "bytes"
        }
      ],
      "name": "handleSwap",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_member",
          "type": "address"
        }
      ],
      "name": "hasClaimed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "hasRole",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "host",
      "outputs": [
        {
          "internalType": "contract ISuperfluid",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "manager",
              "type": "address"
            },
            {
              "internalType": "contract IMembersValidator",
              "name": "membersValidator",
              "type": "address"
            },
            {
              "internalType": "contract IIdentityV2",
              "name": "uniquenessValidator",
              "type": "address"
            },
            {
              "internalType": "contract IERC20Upgradeable",
              "name": "rewardToken",
              "type": "address"
            }
          ],
          "internalType": "struct PoolSettings",
          "name": "_settings",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "cycleLengthDays",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "claimPeriodDays",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "minActiveUsers",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "claimForEnabled",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "maxClaimAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "maxMembers",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "onlyMembers",
              "type": "bool"
            }
          ],
          "internalType": "struct UBIPool.UBISettings",
          "name": "_ubiSettings",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "maxPeriodClaimers",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "minClaimAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "managerFeeBps",
              "type": "uint32"
            }
          ],
          "internalType": "struct UBIPool.ExtendedSettings",
          "name": "_extendedSettings",
          "type": "tuple"
        },
        {
          "internalType": "contract UBIPoolFactory",
          "name": "_registry",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "_superToken",
          "type": "address"
        }
      ],
      "name": "isAcceptedSuperToken",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nextClaimTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onTokenTransfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxiableUUID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "registry",
      "outputs": [
        {
          "internalType": "contract UBIPoolFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "removeMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "renounceRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "revokeRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "manager",
              "type": "address"
            },
            {
              "internalType": "contract IMembersValidator",
              "name": "membersValidator",
              "type": "address"
            },
            {
              "internalType": "contract IIdentityV2",
              "name": "uniquenessValidator",
              "type": "address"
            },
            {
              "internalType": "contract IERC20Upgradeable",
              "name": "rewardToken",
              "type": "address"
            }
          ],
          "internalType": "struct PoolSettings",
          "name": "_settings",
          "type": "tuple"
        }
      ],
      "name": "setPoolSettings",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "cycleLengthDays",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "claimPeriodDays",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "minActiveUsers",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "claimForEnabled",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "maxClaimAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "maxMembers",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "onlyMembers",
              "type": "bool"
            }
          ],
          "internalType": "struct UBIPool.UBISettings",
          "name": "_ubiSettings",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "maxPeriodClaimers",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "minClaimAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "managerFeeBps",
              "type": "uint32"
            }
          ],
          "internalType": "struct UBIPool.ExtendedSettings",
          "name": "_extendedSettings",
          "type": "tuple"
        }
      ],
      "name": "setUBISettings",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "settings",
      "outputs": [
        {
          "internalType": "address",
          "name": "manager",
          "type": "address"
        },
        {
          "internalType": "contract IMembersValidator",
          "name": "membersValidator",
          "type": "address"
        },
        {
          "internalType": "contract IIdentityV2",
          "name": "uniquenessValidator",
          "type": "address"
        },
        {
          "internalType": "contract IERC20Upgradeable",
          "name": "rewardToken",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stats",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "netIncome",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalFees",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastUpdate",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "lastFeeRecipient",
          "type": "address"
        },
        {
          "internalType": "int96",
          "name": "lastIncomeRate",
          "type": "int96"
        },
        {
          "internalType": "address",
          "name": "lastManagerFeeRecipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "protocolFees",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "managerFees",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "status",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "currentDay",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "dailyUbi",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "dailyCyclePool",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "startOfCycle",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "currentCycleLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "periodClaimers",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "periodDistributed",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "membersCount",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "superToken",
      "outputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_ctx",
          "type": "bytes"
        }
      ],
      "name": "support",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "swapFrom",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minReturn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "path",
              "type": "bytes"
            }
          ],
          "internalType": "struct HelperLibrary.SwapData",
          "name": "_customData",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "_ctx",
          "type": "bytes"
        }
      ],
      "name": "supportWithSwap",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "supporters",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "contribution",
          "type": "uint256"
        },
        {
          "internalType": "int96",
          "name": "flowRate",
          "type": "int96"
        },
        {
          "internalType": "uint128",
          "name": "lastUpdated",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "swapRouter",
      "outputs": [
        {
          "internalType": "contract IV3SwapRouter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ubiSettings",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "cycleLengthDays",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "claimPeriodDays",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "minActiveUsers",
          "type": "uint32"
        },
        {
          "internalType": "bool",
          "name": "claimForEnabled",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "maxClaimAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "maxMembers",
          "type": "uint32"
        },
        {
          "internalType": "bool",
          "name": "onlyMembers",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToLatest",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x62c5de62f139c07d48e34e2976520c9fb786c0277325fcb0a4d3c72eef48c64f",
  "receipt": {
    "to": null,
    "from": "0x2CeADe86A04e474F3cf9BD87208514d818010627",
    "contractAddress": "0xE9a499b3ceED8512e67aA8b21EaACf109006207a",
    "transactionIndex": 7,
    "gasUsed": "4758211",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x346b1f56a3b96655f6607982dcedaada1b1f72c3a57f3f43f1dfafa26c295718",
    "transactionHash": "0x62c5de62f139c07d48e34e2976520c9fb786c0277325fcb0a4d3c72eef48c64f",
    "logs": [],
    "blockNumber": 35932429,
    "cumulativeGasUsed": "5547059",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xA4Ff07cF81C02CFD356184879D953970cA957585",
    "0x5615CDAb10dc425a742d643d949a7F474C01abc4"
  ],
  "numDeployments": 26,
  "solcInputHash": "f535b035beebf5cf7122547758fcd0bb",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ISuperfluid\",\"name\":\"_host\",\"type\":\"address\"},{\"internalType\":\"contract IV3SwapRouter\",\"name\":\"_swapRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whitelistedRoot\",\"type\":\"address\"}],\"name\":\"ALREADY_CLAIMED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CLAIMFOR_DISABLED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EMPTY_MANAGER\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int96\",\"name\":\"curFeeRate\",\"type\":\"int96\"},{\"internalType\":\"int96\",\"name\":\"newFeeRate\",\"type\":\"int96\"}],\"name\":\"FEE_FLOW_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_0_VALUE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MAX_MEMBERS_REACHED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimers\",\"type\":\"uint256\"}],\"name\":\"MAX_PERIOD_CLAIMERS_REACHED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"}],\"name\":\"MIN_FLOWRATE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"NOT_MANAGER\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"NOT_MEMBER\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whitelistedRoot\",\"type\":\"address\"}],\"name\":\"NOT_WHITELISTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAcceptedSuperToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotImplemented\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ONLY_HOST_OR_SENDER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNSUPPORTED_TOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedHost\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_AMOUNT\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"contract IMembersValidator\",\"name\":\"membersValidator\",\"type\":\"address\"},{\"internalType\":\"contract IIdentityV2\",\"name\":\"uniquenessValidator\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct PoolSettings\",\"name\":\"settings\",\"type\":\"tuple\"}],\"name\":\"PoolSettingsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supporter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousContribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"previousFlowRate\",\"type\":\"int96\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFlowUpdate\",\"type\":\"bool\"}],\"name\":\"SupporterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dailyUbi\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodClaimers\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodDistributed\",\"type\":\"uint256\"}],\"name\":\"UBICalculated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistedRoot\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UBIClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycleLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dailyUBIPool\",\"type\":\"uint256\"}],\"name\":\"UBICycleCalculated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"cycleLengthDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"claimPeriodDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minActiveUsers\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"claimForEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"maxMembers\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"onlyMembers\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct UBIPool.UBISettings\",\"name\":\"settings\",\"type\":\"tuple\"}],\"name\":\"UBISettingsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CFAV1_TYPE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MEMBER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FLOW_RATE\",\"outputs\":[{\"internalType\":\"int96\",\"name\":\"\",\"type\":\"int96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"addMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMember\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"agreementData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"ctx\",\"type\":\"bytes\"}],\"name\":\"afterAgreementCreated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"newCtx\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agreementClass\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"agreementData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"cbdata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"ctx\",\"type\":\"bytes\"}],\"name\":\"afterAgreementTerminated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"newCtx\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"agreementData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"cbdata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"ctx\",\"type\":\"bytes\"}],\"name\":\"afterAgreementUpdated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"newCtx\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agreementClass\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeAgreementCreated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agreementClass\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"agreementData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeAgreementTerminated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agreementClass\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"agreementData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeAgreementUpdated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cfaV1\",\"outputs\":[{\"internalType\":\"contract ISuperfluid\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"contract IConstantFlowAgreementV1\",\"name\":\"cfa\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"checkEntitlement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEntitlement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"sendToWhitelistedRoot\",\"type\":\"bool\"}],\"name\":\"claimFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDayInCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionFormula\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimateNextDailyUBI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextDailyUbi\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extendedSettings\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"maxPeriodClaimers\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"minClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"managerFeeBps\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getManagerFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"feeBps\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRealtimeContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRealtimeStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managerFees\",\"type\":\"uint256\"},{\"internalType\":\"int96\",\"name\":\"incomeFlowRate\",\"type\":\"int96\"},{\"internalType\":\"int96\",\"name\":\"feeRate\",\"type\":\"int96\"},{\"internalType\":\"int96\",\"name\":\"managerFeeRate\",\"type\":\"int96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistry\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"internalType\":\"struct HelperLibrary.SwapData\",\"name\":\"_customData\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_ctx\",\"type\":\"bytes\"}],\"name\":\"handleSwap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"host\",\"outputs\":[{\"internalType\":\"contract ISuperfluid\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"contract IMembersValidator\",\"name\":\"membersValidator\",\"type\":\"address\"},{\"internalType\":\"contract IIdentityV2\",\"name\":\"uniquenessValidator\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"internalType\":\"struct PoolSettings\",\"name\":\"_settings\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"cycleLengthDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"claimPeriodDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minActiveUsers\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"claimForEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"maxMembers\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"onlyMembers\",\"type\":\"bool\"}],\"internalType\":\"struct UBIPool.UBISettings\",\"name\":\"_ubiSettings\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"maxPeriodClaimers\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"minClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"managerFeeBps\",\"type\":\"uint32\"}],\"internalType\":\"struct UBIPool.ExtendedSettings\",\"name\":\"_extendedSettings\",\"type\":\"tuple\"},{\"internalType\":\"contract UBIPoolFactory\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"_superToken\",\"type\":\"address\"}],\"name\":\"isAcceptedSuperToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextClaimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract UBIPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"contract IMembersValidator\",\"name\":\"membersValidator\",\"type\":\"address\"},{\"internalType\":\"contract IIdentityV2\",\"name\":\"uniquenessValidator\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"internalType\":\"struct PoolSettings\",\"name\":\"_settings\",\"type\":\"tuple\"}],\"name\":\"setPoolSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"cycleLengthDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"claimPeriodDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minActiveUsers\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"claimForEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"maxMembers\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"onlyMembers\",\"type\":\"bool\"}],\"internalType\":\"struct UBIPool.UBISettings\",\"name\":\"_ubiSettings\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"maxPeriodClaimers\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"minClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"managerFeeBps\",\"type\":\"uint32\"}],\"internalType\":\"struct UBIPool.ExtendedSettings\",\"name\":\"_extendedSettings\",\"type\":\"tuple\"}],\"name\":\"setUBISettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settings\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"contract IMembersValidator\",\"name\":\"membersValidator\",\"type\":\"address\"},{\"internalType\":\"contract IIdentityV2\",\"name\":\"uniquenessValidator\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lastFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"int96\",\"name\":\"lastIncomeRate\",\"type\":\"int96\"},{\"internalType\":\"address\",\"name\":\"lastManagerFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"protocolFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managerFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyUbi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyCyclePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startOfCycle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentCycleLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodClaimers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodDistributed\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"membersCount\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superToken\",\"outputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_ctx\",\"type\":\"bytes\"}],\"name\":\"support\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"internalType\":\"struct HelperLibrary.SwapData\",\"name\":\"_customData\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_ctx\",\"type\":\"bytes\"}],\"name\":\"supportWithSwap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supporters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"contribution\",\"type\":\"uint256\"},{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"internalType\":\"uint128\",\"name\":\"lastUpdated\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract IV3SwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ubiSettings\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"cycleLengthDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"claimPeriodDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minActiveUsers\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"claimForEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxClaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"maxMembers\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"onlyMembers\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToLatest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"NotAcceptedSuperToken()\":[{\"details\":\"Thrown when SuperTokens not accepted by the SuperApp are streamed to it\"}],\"NotImplemented()\":[{\"details\":\"Thrown if a required callback wasn't implemented (overridden by the SuperApp)\"}],\"UnauthorizedHost()\":[{\"details\":\"Thrown when the callback caller is not the host.\"}]},\"events\":{\"AdminChanged(address,address)\":{\"details\":\"Emitted when the admin account has changed.\"},\"BeaconUpgraded(address)\":{\"details\":\"Emitted when the beacon is changed.\"},\"Initialized(uint8)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"},\"SupporterUpdated(address,uint256,uint256,int96,int96,bool)\":{\"details\":\"Emitted when a supporter's contribution or flow rate is updated\",\"params\":{\"contribution\":\"The new total contribution amount\",\"flowRate\":\"The new flow rate\",\"isFlowUpdate\":\"True if the update was a flow rate update, false if it was a single contribution update\",\"previousContribution\":\"The previous total contribution amount\",\"previousFlowRate\":\"The previous flow rate if isFlowUpdate otherwise 0\",\"supporter\":\"The address of the supporter\"}},\"Upgraded(address)\":{\"details\":\"Emitted when the implementation is upgraded.\"}},\"kind\":\"dev\",\"methods\":{\"addMember(address,bytes)\":{\"details\":\"Adds a member to the contract.\",\"params\":{\"extraData\":\"Additional data to validate the member.\",\"member\":\"The address of the member to add.\"}},\"checkEntitlement(address)\":{\"details\":\"Checks the amount which the sender address is eligible to claim for, regardless if they have been whitelisted or not. In case the user is active, then the current day must be equal to the actual day, i.e. claim or fish has already been executed today.\",\"returns\":{\"_0\":\"The amount of GD tokens the address can claim.\"}},\"claim()\":{\"details\":\"Claims UBI\"},\"constructor\":{\"custom:oz-upgrades-unsafe-allow\":\"constructor\"},\"currentDayInCycle()\":{\"details\":\"returns the day count since start of current cycle\"},\"distributionFormula()\":{\"details\":\"The claim calculation formula. Divide the daily pool with the sum of the active users. the daily balance is determined by dividing current pool by the cycle length\",\"returns\":{\"_0\":\"The amount of GoodDollar the user can claim\"}},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"handleSwap((address,uint256,uint256,uint256,bytes),address,bytes)\":{\"details\":\"Handles the swap of tokens using the SwapData struct\",\"params\":{\"_ctx\":\"The context of the transaction for superfluid\",\"_customData\":\"The SwapData struct containing information about the swap\",\"_sender\":\"The address of the sender of the transaction\"},\"returns\":{\"_0\":\"Returns the context of the transaction\"}},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"initialize((address,address,address,address),(uint32,uint32,uint32,bool,uint256,uint32,bool),(uint32,uint256,uint32),address)\":{\"details\":\"Initializes the contract with the given settings and limits.\",\"params\":{\"_settings\":\"The PoolSettings struct containing pool settings.\",\"_ubiSettings\":\"The UBISettings struct containing safety limits.\"}},\"onTokenTransfer(address,uint256,bytes)\":{\"details\":\"This function is called when a token transfer occurs\",\"params\":{\"_amount\":\"The amount of tokens being transferred\",\"_sender\":\"The address of the sender\"},\"returns\":{\"_0\":\"bool Returns true to indicate that the transfer was successful\"}},\"proxiableUUID()\":{\"details\":\"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"setPoolSettings((address,address,address,address))\":{\"details\":\"Sets the settings for the pool.\",\"params\":{\"_settings\":\"The new pool settings.\"}},\"setUBISettings((uint32,uint32,uint32,bool,uint256,uint32,bool),(uint32,uint256,uint32))\":{\"details\":\"Sets the safety limits for the pool.\",\"params\":{\"_ubiSettings\":\"The new safety limits.\"}},\"support(address,uint256,bytes)\":{\"details\":\"allow single contribution. user needs to approve tokens first. can be used in superfluid batch actions.\",\"params\":{\"_amount\":\"The amount of tokens being contributed.\",\"_ctx\":\"The context of the transaction for superfluid in case this was used in superfluid batch. otherwise can be empty.\",\"_sender\":\"The address of the sender who is contributing tokens.\"},\"returns\":{\"_0\":\"Returns the context of the transaction.\"}},\"supportWithSwap(address,(address,uint256,uint256,uint256,bytes),bytes)\":{\"details\":\"allow single contribution. user needs to approve tokens first. can be used in superfluid batch actions.\",\"params\":{\"_ctx\":\"The context of the transaction for superfluid in case this was used in superfluid batch. otherwise can be empty.\",\"_customData\":\"The SwapData struct containing information about the swap\",\"_sender\":\"The address of the sender who is contributing tokens.\"},\"returns\":{\"_0\":\"Returns the context of the transaction.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"upgradeTo(address)\":{\"details\":\"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"},\"upgradeToAndCall(address,bytes)\":{\"details\":\"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/UBI/UBIPool.sol\":\"UBIPool\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":0},\"remappings\":[]},\"sources\":{\"@gooddollar/goodprotocol/contracts/Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\nimport { DataTypes } from \\\"./utils/DataTypes.sol\\\";\\npragma solidity >=0.8.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface ERC20 {\\n\\tfunction balanceOf(address addr) external view returns (uint256);\\n\\n\\tfunction transfer(address to, uint256 amount) external returns (bool);\\n\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction mint(address to, uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction burn(uint256 amount) external;\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction allowance(\\n\\t\\taddress owner,\\n\\t\\taddress spender\\n\\t) external view returns (uint256);\\n\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\tfunction name() external view returns (string memory);\\n\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 amount);\\n\\tevent Transfer(\\n\\t\\taddress indexed from,\\n\\t\\taddress indexed to,\\n\\t\\tuint256 amount,\\n\\t\\tbytes data\\n\\t);\\n}\\n\\ninterface cERC20 is ERC20 {\\n\\tfunction mint(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction redeemUnderlying(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction redeem(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction exchangeRateCurrent() external returns (uint256);\\n\\n\\tfunction exchangeRateStored() external view returns (uint256);\\n\\n\\tfunction underlying() external returns (address);\\n}\\n\\ninterface IGoodDollar is ERC20 {\\n\\t// view functions\\n\\tfunction feeRecipient() external view returns (address);\\n\\n\\tfunction getFees(\\n\\t\\tuint256 value,\\n\\t\\taddress sender,\\n\\t\\taddress recipient\\n\\t) external view returns (uint256 fee, bool senderPays);\\n\\n\\tfunction cap() external view returns (uint256);\\n\\n\\tfunction isPauser(address _pauser) external view returns (bool);\\n\\n\\tfunction getFees(uint256 value) external view returns (uint256, bool);\\n\\n\\tfunction isMinter(address minter) external view returns (bool);\\n\\n\\tfunction formula() external view returns (address);\\n\\n\\tfunction identity() external view returns (address);\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\t// state changing functions\\n\\tfunction setFeeRecipient(address _feeRecipient) external;\\n\\n\\tfunction setFormula(address _formula) external;\\n\\n\\tfunction transferOwnership(address _owner) external;\\n\\n\\tfunction addPauser(address _pauser) external;\\n\\n\\tfunction pause() external;\\n\\n\\tfunction unpause() external;\\n\\n\\tfunction burn(uint256 amount) external;\\n\\n\\tfunction burnFrom(address account, uint256 amount) external;\\n\\n\\tfunction renounceMinter() external;\\n\\n\\tfunction addMinter(address minter) external;\\n\\n\\tfunction transferAndCall(\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external returns (bool);\\n\\n\\tfunction setIdentity(address identity) external;\\n}\\n\\ninterface IERC2917 is ERC20 {\\n\\t/// @dev This emit when interests amount per block is changed by the owner of the contract.\\n\\t/// It emits with the old interests amount and the new interests amount.\\n\\tevent InterestRatePerBlockChanged(uint256 oldValue, uint256 newValue);\\n\\n\\t/// @dev This emit when a users' productivity has changed\\n\\t/// It emits with the user's address and the the value after the change.\\n\\tevent ProductivityIncreased(address indexed user, uint256 value);\\n\\n\\t/// @dev This emit when a users' productivity has changed\\n\\t/// It emits with the user's address and the the value after the change.\\n\\tevent ProductivityDecreased(address indexed user, uint256 value);\\n\\n\\t/// @dev Return the current contract's interests rate per block.\\n\\t/// @return The amount of interests currently producing per each block.\\n\\tfunction interestsPerBlock() external view returns (uint256);\\n\\n\\t/// @notice Change the current contract's interests rate.\\n\\t/// @dev Note the best practice will be restrict the gross product provider's contract address to call this.\\n\\t/// @return The true/fase to notice that the value has successfully changed or not, when it succeed, it will emite the InterestRatePerBlockChanged event.\\n\\tfunction changeInterestRatePerBlock(uint256 value) external returns (bool);\\n\\n\\t/// @notice It will get the productivity of given user.\\n\\t/// @dev it will return 0 if user has no productivity proved in the contract.\\n\\t/// @return user's productivity and overall productivity.\\n\\tfunction getProductivity(\\n\\t\\taddress user\\n\\t) external view returns (uint256, uint256);\\n\\n\\t/// @notice increase a user's productivity.\\n\\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\\n\\t/// @return true to confirm that the productivity added success.\\n\\tfunction increaseProductivity(\\n\\t\\taddress user,\\n\\t\\tuint256 value\\n\\t) external returns (bool);\\n\\n\\t/// @notice decrease a user's productivity.\\n\\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\\n\\t/// @return true to confirm that the productivity removed success.\\n\\tfunction decreaseProductivity(\\n\\t\\taddress user,\\n\\t\\tuint256 value\\n\\t) external returns (bool);\\n\\n\\t/// @notice take() will return the interests that callee will get at current block height.\\n\\t/// @dev it will always calculated by block.number, so it will change when block height changes.\\n\\t/// @return amount of the interests that user are able to mint() at current block height.\\n\\tfunction take() external view returns (uint256);\\n\\n\\t/// @notice similar to take(), but with the block height joined to calculate return.\\n\\t/// @dev for instance, it returns (_amount, _block), which means at block height _block, the callee has accumulated _amount of interests.\\n\\t/// @return amount of interests and the block height.\\n\\tfunction takeWithBlock() external view returns (uint256, uint256);\\n\\n\\t/// @notice mint the avaiable interests to callee.\\n\\t/// @dev once it mint, the amount of interests will transfer to callee's address.\\n\\t/// @return the amount of interests minted.\\n\\tfunction mint() external returns (uint256);\\n}\\n\\ninterface Staking {\\n\\tstruct Staker {\\n\\t\\t// The staked DAI amount\\n\\t\\tuint256 stakedDAI;\\n\\t\\t// The latest block number which the\\n\\t\\t// staker has staked tokens\\n\\t\\tuint256 lastStake;\\n\\t}\\n\\n\\tfunction stakeDAI(uint256 amount) external;\\n\\n\\tfunction withdrawStake() external;\\n\\n\\tfunction stakers(address staker) external view returns (Staker memory);\\n}\\n\\ninterface Uniswap {\\n\\tfunction swapExactETHForTokens(\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external payable returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForETH(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction WETH() external pure returns (address);\\n\\n\\tfunction factory() external pure returns (address);\\n\\n\\tfunction quote(\\n\\t\\tuint256 amountA,\\n\\t\\tuint256 reserveA,\\n\\t\\tuint256 reserveB\\n\\t) external pure returns (uint256 amountB);\\n\\n\\tfunction getAmountIn(\\n\\t\\tuint256 amountOut,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountIn);\\n\\n\\tfunction getAmountOut(\\n\\t\\tuint256 amountI,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountOut);\\n\\n\\tfunction getAmountsOut(\\n\\t\\tuint256 amountIn,\\n\\t\\taddress[] memory path\\n\\t) external pure returns (uint256[] memory amounts);\\n}\\n\\ninterface UniswapFactory {\\n\\tfunction getPair(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB\\n\\t) external view returns (address);\\n}\\n\\ninterface UniswapPair {\\n\\tfunction getReserves()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n\\tfunction kLast() external view returns (uint256);\\n\\n\\tfunction token0() external view returns (address);\\n\\n\\tfunction token1() external view returns (address);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction balanceOf(address owner) external view returns (uint256);\\n}\\n\\ninterface Reserve {\\n\\tfunction buy(\\n\\t\\taddress _buyWith,\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minReturn\\n\\t) external returns (uint256);\\n}\\n\\ninterface IIdentity {\\n\\tfunction isWhitelisted(address user) external view returns (bool);\\n\\n\\tfunction addWhitelistedWithDID(address account, string memory did) external;\\n\\n\\tfunction removeWhitelisted(address account) external;\\n\\n\\tfunction addBlacklisted(address account) external;\\n\\n\\tfunction removeBlacklisted(address account) external;\\n\\n\\tfunction isBlacklisted(address user) external view returns (bool);\\n\\n\\tfunction addIdentityAdmin(address account) external returns (bool);\\n\\n\\tfunction setAvatar(address _avatar) external;\\n\\n\\tfunction isIdentityAdmin(address account) external view returns (bool);\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction removeContract(address account) external;\\n\\n\\tfunction isDAOContract(address account) external view returns (bool);\\n\\n\\tfunction addrToDID(address account) external view returns (string memory);\\n\\n\\tfunction didHashToAddress(bytes32 hash) external view returns (address);\\n\\n\\tfunction lastAuthenticated(address account) external view returns (uint256);\\n\\n\\tevent WhitelistedAdded(address user);\\n}\\n\\ninterface IIdentityV2 is IIdentity {\\n\\tfunction addWhitelistedWithDIDAndChain(\\n\\t\\taddress account,\\n\\t\\tstring memory did,\\n\\t\\tuint256 orgChainId,\\n\\t\\tuint256 dateAuthenticated\\n\\t) external;\\n\\n\\tfunction getWhitelistedRoot(\\n\\t\\taddress account\\n\\t) external view returns (address root);\\n}\\n\\ninterface IUBIScheme {\\n\\tfunction currentDay() external view returns (uint256);\\n\\n\\tfunction periodStart() external view returns (uint256);\\n\\n\\tfunction hasClaimed(address claimer) external view returns (bool);\\n}\\n\\ninterface IFirstClaimPool {\\n\\tfunction awardUser(address user) external returns (uint256);\\n\\n\\tfunction claimAmount() external view returns (uint256);\\n\\n\\tfunction end() external;\\n}\\n\\ninterface ProxyAdmin {\\n\\tfunction getProxyImplementation(\\n\\t\\taddress proxy\\n\\t) external view returns (address);\\n\\n\\tfunction getProxyAdmin(address proxy) external view returns (address);\\n\\n\\tfunction upgrade(address proxy, address implementation) external;\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction transferOwnership(address newOwner) external;\\n\\n\\tfunction upgradeAndCall(\\n\\t\\taddress proxy,\\n\\t\\taddress implementation,\\n\\t\\tbytes memory data\\n\\t) external;\\n}\\n\\n/**\\n * @dev Interface for chainlink oracles to obtain price datas\\n */\\ninterface AggregatorV3Interface {\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction description() external view returns (string memory);\\n\\n\\tfunction version() external view returns (uint256);\\n\\n\\t// getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n\\t// if they do not have data to report, instead of returning unset values\\n\\t// which could be misinterpreted as actual reported values.\\n\\tfunction getRoundData(\\n\\t\\tuint80 _roundId\\n\\t)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint80 roundId,\\n\\t\\t\\tint256 answer,\\n\\t\\t\\tuint256 startedAt,\\n\\t\\t\\tuint256 updatedAt,\\n\\t\\t\\tuint80 answeredInRound\\n\\t\\t);\\n\\n\\tfunction latestAnswer() external view returns (int256);\\n}\\n\\n/**\\n\\t@dev interface for AAVE lending Pool\\n */\\ninterface ILendingPool {\\n\\t/**\\n\\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n\\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n\\t * @param asset The address of the underlying asset to deposit\\n\\t * @param amount The amount to be deposited\\n\\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n\\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n\\t *   is a different wallet\\n\\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n\\t *   0 if the action is executed directly by the user, without any middle-man\\n\\t **/\\n\\tfunction deposit(\\n\\t\\taddress asset,\\n\\t\\tuint256 amount,\\n\\t\\taddress onBehalfOf,\\n\\t\\tuint16 referralCode\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n\\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n\\t * @param asset The address of the underlying asset to withdraw\\n\\t * @param amount The underlying amount to be withdrawn\\n\\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n\\t * @param to Address that will receive the underlying, same as msg.sender if the user\\n\\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n\\t *   different wallet\\n\\t * @return The final amount withdrawn\\n\\t **/\\n\\tfunction withdraw(\\n\\t\\taddress asset,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) external returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the state and configuration of the reserve\\n\\t * @param asset The address of the underlying asset of the reserve\\n\\t * @return The state of the reserve\\n\\t **/\\n\\tfunction getReserveData(\\n\\t\\taddress asset\\n\\t) external view returns (DataTypes.ReserveData memory);\\n}\\n\\ninterface IDonationStaking {\\n\\tfunction stakeDonations() external payable;\\n}\\n\\ninterface INameService {\\n\\tfunction getAddress(string memory _name) external view returns (address);\\n}\\n\\ninterface IAaveIncentivesController {\\n\\t/**\\n\\t * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n\\t * @param amount Amount of rewards to claim\\n\\t * @param to Address that will be receiving the rewards\\n\\t * @return Rewards claimed\\n\\t **/\\n\\tfunction claimRewards(\\n\\t\\taddress[] calldata assets,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) external returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n\\t * @param user The address of the user\\n\\t * @return The rewards\\n\\t **/\\n\\tfunction getRewardsBalance(\\n\\t\\taddress[] calldata assets,\\n\\t\\taddress user\\n\\t) external view returns (uint256);\\n}\\n\\ninterface IGoodStaking {\\n\\tfunction collectUBIInterest(\\n\\t\\taddress recipient\\n\\t) external returns (uint256, uint256, uint256);\\n\\n\\tfunction iToken() external view returns (address);\\n\\n\\tfunction currentGains(\\n\\t\\tbool _returnTokenBalanceInUSD,\\n\\t\\tbool _returnTokenGainsInUSD\\n\\t) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n\\tfunction getRewardEarned(address user) external view returns (uint256);\\n\\n\\tfunction getGasCostForInterestTransfer() external view returns (uint256);\\n\\n\\tfunction rewardsMinted(\\n\\t\\taddress user,\\n\\t\\tuint256 rewardsPerBlock,\\n\\t\\tuint256 blockStart,\\n\\t\\tuint256 blockEnd\\n\\t) external returns (uint256);\\n}\\n\\ninterface IHasRouter {\\n\\tfunction getRouter() external view returns (Uniswap);\\n}\\n\\ninterface IAdminWallet {\\n\\tfunction addAdmins(address payable[] memory _admins) external;\\n\\n\\tfunction removeAdmins(address[] memory _admins) external;\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction transferOwnership(address _owner) external;\\n}\\n\\ninterface IMultichainRouter {\\n\\t// Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\\n\\tfunction anySwapOut(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 toChainID\\n\\t) external;\\n\\n\\t// Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\\n\\tfunction anySwapOutUnderlying(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 toChainID\\n\\t) external;\\n}\\n\",\"keccak256\":\"0x57739a30eb70aac5df7ca4009a557931ccf13a4b8275bfb33dd45220aab15412\",\"license\":\"MIT\"},\"@gooddollar/goodprotocol/contracts/token/IFeesFormula.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8;\\n\\ninterface IFeesFormula {\\n\\tfunction getTxFees(\\n\\t\\tuint256 value,\\n\\t\\taddress sender,\\n\\t\\taddress recipient\\n\\t) external view returns (uint256 fee, bool senderPays);\\n}\\n\",\"keccak256\":\"0xfd9f081cec5e3cee6e854cb3a0a4b71ba58edd1168df49294f24070194d568fa\",\"license\":\"MIT\"},\"@gooddollar/goodprotocol/contracts/token/superfluid/ISuperGoodDollar.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport { ISuperToken } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/CustomSuperTokenBase.sol\\\";\\nimport \\\"../IFeesFormula.sol\\\";\\nimport \\\"../../Interfaces.sol\\\";\\n\\n// GoodDollar specific functions\\ninterface IGoodDollarCustom {\\n\\t// view functions\\n\\tfunction feeRecipient() external view returns (address);\\n\\n\\tfunction getFees(\\n\\t\\tuint256 value\\n\\t) external view returns (uint256 fee, bool senderPays);\\n\\n\\tfunction getFees(\\n\\t\\tuint256 value,\\n\\t\\taddress sender,\\n\\t\\taddress recipient\\n\\t) external view returns (uint256 fee, bool senderPays);\\n\\n\\tfunction formula() external view returns (IFeesFormula);\\n\\n\\tfunction identity() external view returns (IIdentity);\\n\\n\\tfunction cap() external view returns (uint256);\\n\\n\\tfunction isMinter(address _minter) external view returns (bool);\\n\\n\\tfunction isPauser(address _pauser) external view returns (bool);\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\t// state changing functions\\n\\tfunction setFeeRecipient(address _feeRecipient) external;\\n\\n\\tfunction setFormula(IFeesFormula _formula) external;\\n\\n\\tfunction setIdentity(IIdentityV2 _identity) external;\\n\\n\\tfunction transferOwnership(address _owner) external;\\n\\n\\tfunction transferAndCall(\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external returns (bool);\\n\\n\\tfunction mint(address to, uint256 amount) external returns (bool);\\n\\n\\tfunction burn(uint256 amount) external;\\n\\n\\tfunction burnFrom(address account, uint256 amount) external;\\n\\n\\tfunction addMinter(address _minter) external;\\n\\n\\tfunction renounceMinter() external;\\n\\n\\tfunction addPauser(address _pauser) external;\\n\\n\\tfunction pause() external;\\n\\n\\tfunction unpause() external;\\n}\\n\\ninterface ISuperGoodDollar is\\n\\tIGoodDollarCustom,\\n\\tISuperToken,\\n\\tIERC20PermitUpgradeable\\n{\\n\\tfunction initialize(\\n\\t\\tstring calldata name,\\n\\t\\tstring calldata symbol,\\n\\t\\tuint256 _cap,\\n\\t\\tIFeesFormula _formula,\\n\\t\\tIIdentity _identity,\\n\\t\\taddress _feeRecipient,\\n\\t\\taddress _owner\\n\\t) external;\\n}\\n\",\"keccak256\":\"0x2ca567950d98df80768d10673056b22d74c0b28bd6cf17ba46d8d8aa6976f796\",\"license\":\"MIT\"},\"@gooddollar/goodprotocol/contracts/utils/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nlibrary DataTypes {\\n\\t// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n\\tstruct ReserveData {\\n\\t\\t//stores the reserve configuration\\n\\t\\tReserveConfigurationMap configuration;\\n\\t\\t//the liquidity index. Expressed in ray\\n\\t\\tuint128 liquidityIndex;\\n\\t\\t//variable borrow index. Expressed in ray\\n\\t\\tuint128 variableBorrowIndex;\\n\\t\\t//the current supply rate. Expressed in ray\\n\\t\\tuint128 currentLiquidityRate;\\n\\t\\t//the current variable borrow rate. Expressed in ray\\n\\t\\tuint128 currentVariableBorrowRate;\\n\\t\\t//the current stable borrow rate. Expressed in ray\\n\\t\\tuint128 currentStableBorrowRate;\\n\\t\\tuint40 lastUpdateTimestamp;\\n\\t\\t//tokens addresses\\n\\t\\taddress aTokenAddress;\\n\\t\\taddress stableDebtTokenAddress;\\n\\t\\taddress variableDebtTokenAddress;\\n\\t\\t//address of the interest rate strategy\\n\\t\\taddress interestRateStrategyAddress;\\n\\t\\t//the id of the reserve. Represents the position in the list of the active reserves\\n\\t\\tuint8 id;\\n\\t}\\n\\n\\tstruct ReserveConfigurationMap {\\n\\t\\t//bit 0-15: LTV\\n\\t\\t//bit 16-31: Liq. threshold\\n\\t\\t//bit 32-47: Liq. bonus\\n\\t\\t//bit 48-55: Decimals\\n\\t\\t//bit 56: Reserve is active\\n\\t\\t//bit 57: reserve is frozen\\n\\t\\t//bit 58: borrowing is enabled\\n\\t\\t//bit 59: stable rate borrowing enabled\\n\\t\\t//bit 60-63: reserved\\n\\t\\t//bit 64-79: reserve factor\\n\\t\\tuint256 data;\\n\\t}\\n\\tenum InterestRateMode { NONE, STABLE, VARIABLE }\\n}\\n\",\"keccak256\":\"0xbc0c2512438c5b8d92e7ecd3c4d0848edf24ef0bacaf51744048173f60a2114c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\\n    function __AccessControl_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        StringsUpgradeable.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        StringsUpgradeable.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xe8f27a3e3e25067334e76799f03d4de6d8f8535c3fc4806468228a9ebd5de51a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0xb8f5302f12138c5561362e88a78d061573e6298b7a1a5afe84a1e2c8d4d5aeaa\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.3) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.9._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0xb8d68221343ed784c7b76edb6a686cb65e49c476d9e22bb89a5c0c3947ff14db\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x77c89f893e403efc6929ba842b7ccf6534d4ffe03afe31670b4a528c0ad78c0f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x1599637b52d20dc3954cea44914b2a4a9a8a5caade58d9da947e0b6c9acc07ba\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x24b86ac8c005b8c654fbf6ac34a5a4f61580d7273541e83e013e89d66fbf0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x037c334add4b033ad3493038c25be1682d78c00992e1acb0e2795caff3925271\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x7967d130887c4b40666cd88f8744691d4527039a1b2a38aa0de41481ef646778\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xcc70d8e2281fb3ff69e8ab242500f10142cd0a7fa8dd9e45882be270d4d09024\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x220c4a5af915e656be2aaa85ca57505d102418e476b1e2ef6c62e0c6ac143871\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\\n     * that `ownerOf(tokenId)` is `a`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\n        _balances[account] += amount;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[44] private __gap;\\n}\\n\",\"keccak256\":\"0xac29c453f4cf43afe4c9599374b6e1ed493c18644d814554e8a5969aaa6f3486\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xbb2ed8106d94aeae6858e2551a1e7174df73994b77b13ebd120ccaaef80155f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x2c0b89cef83f353c6f9488c013d8a5968587ffdd6dfc26aad53774214b97e229\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x95a471796eb5f030fdc438660bebec121ad5d063763e64d92376ffb4b5ce8b70\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x09864aea84f01e39313375b5610c73a3c1c68abbdc51e5ccdd25ff977fdadf9a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0x6b9a5d35b744b25529a2856a8093e7c03fb35a34b1c4fb5499e560f8ade140da\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc1bd5b53319c68f84e3becd75694d941e8f4be94049903232cd8bc7c535aaa5a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1967.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0x3cbef5ebc24b415252e2f8c0c9254555d30d9f085603b4b80d9b5ed20ab87e90\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xa2b22da3032e50b55f95ec1d13336102d675f341167aa76db571ef7f8bb7975d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/IERC1967.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967Upgrade is IERC1967 {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3b21ae06bf5957f73fa16754b0669c77b7abd8ba6c072d35c3281d446fdb86c2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor(address beacon, bytes memory data) payable {\\n        _upgradeBeaconToAndCall(beacon, data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address) {\\n        return _getBeacon();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_getBeacon()).implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        _upgradeBeaconToAndCall(beacon, data, false);\\n    }\\n}\\n\",\"keccak256\":\"0x85439e74ab467b6a23d45d32bdc9506cbc3760320289afd605f11638c4138e95\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../../access/Ownable.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\\n * implementation contract, which is where they will delegate all function calls.\\n *\\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\\n */\\ncontract UpgradeableBeacon is IBeacon, Ownable {\\n    address private _implementation;\\n\\n    /**\\n     * @dev Emitted when the implementation returned by the beacon is changed.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\\n     * beacon.\\n     */\\n    constructor(address implementation_) {\\n        _setImplementation(implementation_);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function implementation() public view virtual override returns (address) {\\n        return _implementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the beacon to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * Requirements:\\n     *\\n     * - msg.sender must be the owner of the contract.\\n     * - `newImplementation` must be a contract.\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation contract address for this beacon\\n     *\\n     * Requirements:\\n     *\\n     * - `newImplementation` must be a contract.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableBeacon: implementation is not a contract\\\");\\n        _implementation = newImplementation;\\n    }\\n}\\n\",\"keccak256\":\"0x6ec71aef5659f3f74011169948d2fcda8c6599be5bb38f986380a8737f96cc0f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\\n     */\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\\n     */\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n}\\n\",\"keccak256\":\"0x79e6094047e40d49efa3c725b7a1519e16c28c46944884b5f6d0fbe89b450f03\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf09e68aa0dc6722a25bc46490e8d48ed864466d17313b8a0b254c36b54e49899\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperfluidToken,\\n    IConstantFlowAgreementV1\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\n/**\\n * @title Constant flow agreement v1 library\\n * @author Superfluid\\n * @dev for working with the constant flow agreement within solidity\\n * @dev the first set of functions are each for callAgreement()\\n * @dev the second set of functions are each for use in callAgreementWithContext()\\n */\\nlibrary CFAv1Library {\\n\\n    /**\\n     * @dev Initialization data\\n     * @param host Superfluid host for calling agreements\\n     * @param cfa Constant Flow Agreement contract\\n     */\\n    struct InitData {\\n        ISuperfluid host;\\n        IConstantFlowAgreementV1 cfa;\\n    }\\n\\n    /**\\n     * @dev Create flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal {\\n        createFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal {\\n        updateFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Update flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlow(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal {\\n        deleteFlow(cfaLibrary, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlow(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Update flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowByOperatorWithCtx(\\n            cfaLibrary,\\n            ctx,\\n            sender,\\n            receiver,\\n            token,\\n            flowRate,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates a flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates a flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowByOperatorWithCtx(\\n            cfaLibrary,\\n            ctx,\\n            sender,\\n            receiver,\\n            token,\\n            flowRate,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowByOperator(cfaLibrary, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowByOperatorWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the permissions of a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\\n     */\\n    function updateFlowOperatorPermissions(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissions,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the permissions of a flow operator with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\\n     */\\n    function updateFlowOperatorPermissionsWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissions,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Grants full, unlimited permission to a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Grants full, unlimited permission to a flow operator with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function authorizeFlowOperatorWithFullControlWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes all permissions from a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes all permissions from a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function revokeFlowOperatorWithFullControlWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x8e090c93d97520fbca57f31ab1aaa4484c1683b2e5b57384c75fcdcab2df17e2\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperToken,\\n    IConstantFlowAgreementV1,\\n    IInstantDistributionAgreementV1\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\n/**\\n * @title Library for Token Centric Interface\\n * @author Superfluid\\n * @dev Set `using for ISuperToken` in including file, and call any of these functions on an instance\\n * of ISuperToken.\\n * Note that it is important to \\\"warm up\\\" the cache and cache the host, cfa, ida before calling,\\n * this is only applicable to Foundry tests where the vm.expectRevert() will not work as expected.\\n */\\nlibrary SuperTokenV1Library {\\n    /** CFA BASE CRUD ************************************* */\\n\\n    /**\\n     * @dev Create flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        return createFlow(token, receiver, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData // userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Update flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        return updateFlow(token, receiver, flowRate, new bytes(0));\\n    }\\n\\n\\n    /**\\n     * @dev Update flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Delete flow without userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver)\\n        internal returns (bool)\\n    {\\n        return deleteFlow(token, sender, receiver, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The userdata passed along with call\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** CFA ACL ************************************* */\\n\\n    /**\\n     * @dev Update permissions for flow operator\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     */\\n    function setFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (token, flowOperator, permissionsBitmask, flowRateAllowance, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function setMaxFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function revokeFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     */\\n    function increaseFlowRateAllowance(ISuperToken token, address flowOperator, int96 addedFlowRateAllowance)\\n        internal\\n        returns (bool)\\n    {\\n        return increaseFlowRateAllowance(token, flowOperator, addedFlowRateAllowance, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function increaseFlowRateAllowance(\\n        ISuperToken token,\\n        address flowOperator,\\n        int96 addedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(cfa.increaseFlowRateAllowance, (token, flowOperator, addedFlowRateAllowance, new bytes(0))),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is decreased\\n     * @param subtractedFlowRateAllowance amount to decrease allowance by\\n     */\\n    function decreaseFlowRateAllowance(ISuperToken token, address flowOperator, int96 subtractedFlowRateAllowance)\\n        internal\\n        returns (bool)\\n    {\\n        return decreaseFlowRateAllowance(token, flowOperator, subtractedFlowRateAllowance, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is decreased\\n     * @param subtractedFlowRateAllowance amount to decrease allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function decreaseFlowRateAllowance(\\n        ISuperToken token,\\n        address flowOperator,\\n        int96 subtractedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.decreaseFlowRateAllowance, (token, flowOperator, subtractedFlowRateAllowance, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator and adds the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param permissionsToAdd The permissions to add for the flow operator\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     */\\n    function increaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToAdd,\\n        int96 addedFlowRateAllowance\\n    ) internal returns (bool) {\\n        return\\n            increaseFlowRateAllowanceWithPermissions(\\n                token,\\n                flowOperator,\\n                permissionsToAdd,\\n                addedFlowRateAllowance,\\n                new bytes(0)\\n            );\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator and adds the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param permissionsToAdd The permissions to add for the flow operator\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function increaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToAdd,\\n        int96 addedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.increaseFlowRateAllowanceWithPermissions,\\n                (token, flowOperator, permissionsToAdd, addedFlowRateAllowance, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator and removes the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is subtracted\\n     * @param permissionsToRemove The permissions to remove for the flow operator\\n     * @param subtractedFlowRateAllowance amount to subtract allowance by\\n     */\\n    function decreaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToRemove,\\n        int96 subtractedFlowRateAllowance\\n    ) internal returns (bool) {\\n        return decreaseFlowRateAllowanceWithPermissions(\\n            token, flowOperator, permissionsToRemove, subtractedFlowRateAllowance, new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator and removes the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is subtracted\\n     * @param permissionsToRemove The permissions to remove for the flow operator\\n     * @param subtractedFlowRateAllowance amount to subtract allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function decreaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToRemove,\\n        int96 subtractedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.decreaseFlowRateAllowanceWithPermissions,\\n                (token, flowOperator, permissionsToRemove, subtractedFlowRateAllowance, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator in callback\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function setFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissionsBitmask,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function setMaxFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n    * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n\\n    /**\\n     * @dev Creates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        return createFlowFrom(token, sender, receiver, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Updates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        return updateFlowFrom(token, sender, receiver, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n     /**\\n     * @dev Deletes flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver\\n    ) internal returns (bool) {\\n        return deleteFlowFrom(token, sender, receiver, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /** CFA With CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function createFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Create flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function createFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow with context\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The receiver of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function deleteFlowWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function deleteFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /** CFA VIEW FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev get flow rate between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return flowRate The flow rate\\n     */\\n    function getFlowRate(ISuperToken token, address sender, address receiver)\\n        internal view returns(int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (, flowRate, , ) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get flow info between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return lastUpdated Timestamp of flow creation or last flowrate change\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlowInfo(ISuperToken token, address sender, address receiver)\\n        internal view\\n        returns(uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (lastUpdated, flowRate, deposit, owedDeposit) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get net flow rate for given account for given token\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return flowRate The net flow rate of the account\\n     */\\n    function getNetFlowRate(ISuperToken token, address account)\\n        internal view returns (int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getNetFlow(token, account);\\n    }\\n\\n    /**\\n     * @dev get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return lastUpdated Timestamp of the last change of the net flow\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getNetFlowInfo(ISuperToken token, address account)\\n        internal view\\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getAccountFlowInfo(token, account);\\n    }\\n\\n    /**\\n     * @dev calculate buffer for a flow rate\\n     * @param token The token used in flow\\n     * @param flowRate The flowrate to calculate the needed buffer for\\n     * @return bufferAmount The buffer amount based on flowRate, liquidationPeriod and minimum deposit\\n     */\\n    function getBufferAmountByFlowRate(ISuperToken token, int96 flowRate) internal view\\n        returns (uint256 bufferAmount)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getDepositRequiredForFlowRate(token, flowRate);\\n    }\\n\\n    /**\\n     * @dev get existing flow permissions\\n     * @param token The token used in flow\\n     * @param sender sender of a flow\\n     * @param flowOperator the address we are checking permissions of for sender & token\\n     * @return allowCreate is true if the flowOperator can create flows\\n     * @return allowUpdate is true if the flowOperator can update flows\\n     * @return allowDelete is true if the flowOperator can delete flows\\n     * @return flowRateAllowance The flow rate allowance the flowOperator is granted (only goes down)\\n     */\\n    function getFlowPermissions(ISuperToken token, address sender, address flowOperator)\\n        internal view\\n        returns (bool allowCreate, bool allowUpdate, bool allowDelete, int96 flowRateAllowance)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        uint8 permissionsBitmask;\\n        (, permissionsBitmask, flowRateAllowance) = cfa.getFlowOperatorData(token, sender, flowOperator);\\n        allowCreate = permissionsBitmask & 1 == 1;\\n        allowUpdate = permissionsBitmask >> 1 & 1 == 1;\\n        allowDelete = permissionsBitmask >> 2 & 1 == 1;\\n    }\\n\\n\\n     /** IDA VIEW FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Gets an index by its ID and publisher.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @return exist True if the index exists.\\n     * @return indexValue Total value of the index.\\n     * @return totalUnitsApproved Units of the index approved by subscribers.\\n     * @return totalUnitsPending Units of teh index not yet approved by subscribers.\\n     */\\n    function getIndex(ISuperToken token, address publisher, uint32 indexId)\\n        internal view\\n        returns (bool exist, uint128 indexValue, uint128 totalUnitsApproved, uint128 totalUnitsPending)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getIndex(token, publisher, indexId);\\n    }\\n\\n    /**\\n     * @dev Calculates the distribution amount based on the amount of tokens desired to distribute.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount of tokens desired to distribute.\\n     * @return actualAmount Amount to be distributed with correct rounding.\\n     * @return newIndexValue The index value after the distribution would be called.\\n     */\\n    function calculateDistribution(ISuperToken token, address publisher, uint32 indexId, uint256 amount)\\n        internal view\\n        returns (uint256 actualAmount, uint128 newIndexValue)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.calculateDistribution(token, publisher, indexId, amount);\\n    }\\n\\n    /**\\n     * @dev List all subscriptions of an address\\n     * @param token Super token used in the indexes listed.\\n     * @param subscriber Subscriber address.\\n     * @return publishers Publishers of the indices.\\n     * @return indexIds IDs of the indices.\\n     * @return unitsList Units owned of the indices.\\n     */\\n    function listSubscriptions(\\n        ISuperToken token,\\n        address subscriber\\n    )\\n        internal view\\n        returns (\\n            address[] memory publishers,\\n            uint32[] memory indexIds,\\n            uint128[] memory unitsList\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.listSubscriptions(token, subscriber);\\n    }\\n\\n    /**\\n     * @dev Gets subscription by publisher, index id, and subscriber.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber to the index.\\n     * @return exist True if the subscription exists.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscription(ISuperToken token, address publisher, uint32 indexId, address subscriber)\\n        internal view\\n        returns (bool exist, bool approved, uint128 units, uint256 pendingDistribution)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscription(token, publisher, indexId, subscriber);\\n    }\\n\\n    /*\\n     * @dev Gets subscription by the agreement ID.\\n     * @param token Super Token used with the index.\\n     * @param agreementId Agreement ID, unique to the subscriber and index ID.\\n     * @return publisher Publisher of the index.\\n     * @return indexId ID of the index.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscriptionByID(ISuperToken token, bytes32 agreementId)\\n        internal view\\n        returns (\\n            address publisher,\\n            uint32 indexId,\\n            bool approved,\\n            uint128 units,\\n            uint256 pendingDistribution\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscriptionByID(token, agreementId);\\n    }\\n\\n\\n    /** IDA BASE FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Creates a new index.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        return createIndex(token, indexId, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates a new index with userData.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates an index value. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue\\n    ) internal returns (bool) {\\n        return updateIndexValue(token, indexId, indexValue, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates an index value with userData. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of\\n     * passing the new total index value, you pass the amount of tokens desired to be distributed. \\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount - total number of tokens desired to be distributed \\n     * NOTE in many cases, there can be some precision loss \\n     This may cause a slight difference in the amount param specified and the actual amount distributed. \\n     See below for math:\\n     //indexDelta = amount the index will be updated by during an internal call to _updateIndex().\\n     It is calculated like so:\\n     indexDelta = amount / totalUnits \\n     (see the distribute() implementatation in ./agreements/InstantDistributionAgreement.sol)\\n     * NOTE Solidity does not support floating point numbers\\n     So the indexDelta will be rounded down to the nearest integer. \\n     This will create a 'remainder' amount of tokens that will not be distributed \\n     (we'll call this the 'distribution modulo')\\n     distributionModulo = amount - indexDelta * totalUnits\\n     * NOTE due to rounding, there may be a small amount of tokens left in the publisher's account\\n     This amount is equal to the 'distributionModulo' value\\n     //\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        return distribute(token, indexId, amount, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex` (w user data). Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        return approveSubscription(token, publisher, indexId, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index with user data. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        return revokeSubscription(token, publisher, indexId, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber holds\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units\\n    ) internal returns (bool) {\\n        return updateSubscriptionUnits(token, indexId, subscriber, units, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n        return deleteSubscription(token, publisher, indexId, subscriber, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero. This takes arbitrary userdata.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n        return claim(token, publisher, indexId, subscriber, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** IDA WITH CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Creates a new index with ctx.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function createIndexWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates an index value with ctx. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * Meant for usage in super app callbakcs\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param ctx from super app callback\\n     */\\n    function updateIndexValueWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`.Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param ctx from super app callback\\n     */\\n    function distributeWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function approveSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function revokeSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param ctx from super app callback\\n     */\\n    function updateSubscriptionUnitsWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero.\\n     * Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param ctx from super app callback\\n     */\\n    function deleteSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param ctx from super app callback\\n     */\\n    function claimWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    // ************** private helpers **************\\n\\n    // @note We must use hardcoded constants here because:\\n    // Only direct number constants and references to such constants are supported by inline assembly.\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.host\\\")\\n    bytes32 private constant _HOST_SLOT = 0x65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.cfa\\\")\\n    bytes32 private constant _CFA_SLOT = 0xb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.ida\\\");\\n    bytes32 private constant _IDA_SLOT = 0xa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb;\\n\\n    // gets the host and cfa addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndCFA(ISuperToken token) private\\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"))));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n            // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_CFA_SLOT, cfa)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndIDA(ISuperToken token) private\\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\"))));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n            // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_IDA_SLOT, ida)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n\\n    // gets the host and cfa addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndCFA(ISuperToken token) private view\\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"))));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndIDA(ISuperToken token) private view\\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\"))));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n}\\n\",\"keccak256\":\"0xfc49f4845cf277b157b838edfe4bdade6b680253581e6b892bc1975e9ea9445c\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Constant Flow Agreement interface\\n * @author Superfluid\\n */\\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error CFA_ACL_NO_SENDER_CREATE();               // 0x4b993136\\n    error CFA_ACL_NO_SENDER_UPDATE();               // 0xedfa0d3b\\n    error CFA_ACL_OPERATOR_NO_CREATE_PERMISSIONS(); // 0xa3eab6ac\\n    error CFA_ACL_OPERATOR_NO_UPDATE_PERMISSIONS(); // 0xac434b5f\\n    error CFA_ACL_OPERATOR_NO_DELETE_PERMISSIONS(); // 0xe30f1bff\\n    error CFA_ACL_FLOW_RATE_ALLOWANCE_EXCEEDED();   // 0xa0645c1f\\n    error CFA_ACL_UNCLEAN_PERMISSIONS();            // 0x7939d66c\\n    error CFA_ACL_NO_SENDER_FLOW_OPERATOR();        // 0xb0ed394d\\n    error CFA_ACL_NO_NEGATIVE_ALLOWANCE();          // 0x86e0377d\\n    error CFA_FLOW_ALREADY_EXISTS();                // 0x801b6863\\n    error CFA_FLOW_DOES_NOT_EXIST();                // 0x5a32bf24\\n    error CFA_INSUFFICIENT_BALANCE();               // 0xea76c9b3\\n    error CFA_ZERO_ADDRESS_SENDER();                // 0x1ce9b067\\n    error CFA_ZERO_ADDRESS_RECEIVER();              // 0x78e02b2a\\n    error CFA_HOOK_OUT_OF_GAS();                    // 0x9f76430b\\n    error CFA_DEPOSIT_TOO_BIG();                    // 0x752c2b9c\\n    error CFA_FLOW_RATE_TOO_BIG();                  // 0x0c9c55c1\\n    error CFA_NON_CRITICAL_SENDER();                // 0xce11b5d1\\n    error CFA_INVALID_FLOW_RATE();                  // 0x91acad16\\n    error CFA_NO_SELF_FLOW();                       // 0xa47338ef\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\");\\n    }\\n\\n    /**\\n     * @notice Get the maximum flow rate allowed with the deposit\\n     * @dev The deposit is clipped and rounded down\\n     * @param deposit Deposit amount used for creating the flow\\n     * @return flowRate The maximum flow rate\\n     */\\n    function getMaximumFlowRateFromDeposit(\\n        ISuperfluidToken token,\\n        uint256 deposit)\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Get the deposit required for creating the flow\\n     * @dev Calculates the deposit based on the liquidationPeriod and flowRate\\n     * @param flowRate Flow rate to be tested\\n     * @return deposit The deposit amount based on flowRate and liquidationPeriod\\n     * @custom:note\\n     * - if calculated deposit (flowRate * liquidationPeriod) is less\\n     *   than the minimum deposit, we use the minimum deposit otherwise\\n     *   we use the calculated deposit\\n     */\\n    function getDepositRequiredForFlowRate(\\n        ISuperfluidToken token,\\n        int96 flowRate)\\n        external view virtual\\n        returns (uint256 deposit);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on host.getNow()\\n     * @param account The account we are interested in\\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\\n     * @return timestamp The value of host.getNow()\\n     */\\n    function isPatricianPeriodNow(\\n        ISuperfluidToken token,\\n        address account)\\n        external view virtual\\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on timestamp\\n     * @param account The account we are interested in\\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\\n     * @return bool Whether it is currently the patrician period dictated by governance\\n     */\\n    function isPatricianPeriod(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 timestamp\\n    )\\n        public view virtual\\n        returns (bool);\\n\\n    /**\\n     * @dev msgSender from `ctx` updates permissions for the `flowOperator` with `flowRateAllowance`\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissions A bitmask representation of the granted permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowOperatorPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice msgSender from `ctx` increases flow rate allowance for the `flowOperator` by `addedFlowRateAllowance`\\n     * @dev if `addedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param addedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function increaseFlowRateAllowance(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        int96 addedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` decreases flow rate allowance for the `flowOperator` by `subtractedFlowRateAllowance`\\n     * @dev if `subtractedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param subtractedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function decreaseFlowRateAllowance(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        int96 subtractedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` increases flow rate allowance for the `flowOperator` by `addedFlowRateAllowance`\\n     * @dev if `addedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissionsToAdd A bitmask representation of the granted permissions to add as a delta\\n     * @param addedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function increaseFlowRateAllowanceWithPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissionsToAdd,\\n        int96 addedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` decreases flow rate allowance for the `flowOperator` by `subtractedFlowRateAllowance`\\n     * @dev if `subtractedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissionsToRemove A bitmask representation of the granted permissions to remove as a delta\\n     * @param subtractedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function decreaseFlowRateAllowanceWithPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissionsToRemove,\\n        int96 subtractedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` grants `flowOperator` all permissions with flowRateAllowance as type(int96).max\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n     /**\\n     * @notice msgSender from `ctx` revokes `flowOperator` create/update/delete permissions\\n     * @dev `permissions` and `flowRateAllowance` will both be set to 0\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Get the permissions of a flow operator between `sender` and `flowOperator` for `token`\\n     * @param token Super token address\\n     * @param sender The permission granter address\\n     * @param flowOperator The permission grantee address\\n     * @return flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorData(\\n       ISuperfluidToken token,\\n       address sender,\\n       address flowOperator\\n    )\\n        public view virtual\\n        returns (\\n            bytes32 flowOperatorId,\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Get flow operator using flowOperatorId\\n     * @param token Super token address\\n     * @param flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorDataByID(\\n       ISuperfluidToken token,\\n       bytes32 flowOperatorId\\n    )\\n        external view virtual\\n        returns (\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Create a flow betwen ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks\\n     * - AgreementCreated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note\\n     * - A deposit is taken as safety margin for the solvency agents\\n     * - A extra gas fee may be taken to pay for solvency agent liquidations\\n     */\\n    function createFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Create a flow between sender and receiver\\n    * @dev A flow created by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function createFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Update the flow rate between ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks\\n     * - AgreementUpdated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note\\n     * - Only the flow sender may update the flow rate\\n     * - Even if the flow rate is zero, the flow is not deleted\\n     * from the system\\n     * - Deposit amount will be adjusted accordingly\\n     * - No new gas fee is charged\\n     */\\n    function updateFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Update a flow between sender and receiver\\n    * @dev A flow updated by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function updateFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Get the flow data between `sender` and `receiver` of `token`\\n     * @param token Super token address\\n     * @param sender Flow receiver\\n     * @param receiver Flow sender\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @notice Get flow data using agreementId\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The deposit amount of the flow\\n     * @return owedDeposit The owed deposit amount of the flow\\n     */\\n    function getFlowByID(\\n       ISuperfluidToken token,\\n       bytes32 agreementId\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @dev Get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return timestamp Timestamp of when a flow was last updated for account\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getAccountFlowInfo(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @dev Get the net flow rate of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return flowRate Net flow rate\\n     */\\n    function getNetFlow(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     *\\n     * @custom:callbacks\\n     * - AgreementTerminated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note\\n     * - Both flow sender and receiver may delete the flow\\n     * - If Sender account is insolvent or in critical state, a solvency agent may\\n     *   also terminate the agreement\\n     * - Gas fee may be returned to the sender\\n     */\\n    function deleteFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev A flow deleted by an approved flow operator (see above for details on callbacks)\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     */\\n    function deleteFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Flow operator updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param flowOperator Flow operator address\\n     * @param permissions Octo bitmask representation of permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    event FlowOperatorUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    );\\n\\n    /**\\n     * @dev Flow updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param receiver Flow recipient address\\n     * @param flowRate Flow rate in amount per second for this flow\\n     * @param totalSenderFlowRate Total flow rate in amount per second for the sender\\n     * @param totalReceiverFlowRate Total flow rate in amount per second for the receiver\\n     * @param userData The user provided data\\n     *\\n     */\\n    event FlowUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed receiver,\\n        int96 flowRate,\\n        int256 totalSenderFlowRate,\\n        int256 totalReceiverFlowRate,\\n        bytes userData\\n    );\\n\\n    /**\\n     * @dev Flow updated extension event\\n     * @param flowOperator Flow operator address - the Context.msgSender\\n     * @param deposit The deposit amount for the stream\\n     */\\n    event FlowUpdatedExtension(\\n        address indexed flowOperator,\\n        uint256 deposit\\n    );\\n}\\n\",\"keccak256\":\"0xbbd5d7daa0206a39d15d349f69e6771d670c03fb394d65999f49db4fa21aeb0d\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Instant Distribution Agreement interface\\n * @author Superfluid\\n *\\n * @notice \\n *   - A publisher can create as many as indices as possibly identifiable with `indexId`.\\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\\n *       Despite knowing sha-3 collision is only theoretical.\\n *   - A publisher can create a subscription to an index for any subscriber.\\n *   - A subscription consists of:\\n *     - The index it subscribes to.\\n *     - Number of units subscribed.\\n *   - An index consists of:\\n *     - Current value as `uint128 indexValue`.\\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\\n *   - A publisher can update an index with a new value that doesn't decrease.\\n *   - A publisher can update a subscription with any number of units.\\n *   - A publisher or a subscriber can delete a subscription and reset its units to zero.\\n *   - A subscriber must approve the index in order to receive distributions from the publisher\\n *     each time the index is updated.\\n *     - The amount distributed is $$\\\\Delta{index} * units$$\\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\\n *     - the subscriber approves the subscription (side effect),\\n *     - the publisher updates the subscription (side effect),\\n *     - the subscriber deletes the subscription even if it is never approved (side effect),\\n *     - or the subscriber can explicitly claim them.\\n */\\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error IDA_INDEX_SHOULD_GROW();             // 0xcfdca725\\n    error IDA_OPERATION_NOT_ALLOWED();         // 0x92da6d17\\n    error IDA_INDEX_ALREADY_EXISTS();          // 0x5c02a517\\n    error IDA_INDEX_DOES_NOT_EXIST();          // 0xedeaa63b\\n    error IDA_SUBSCRIPTION_DOES_NOT_EXIST();   // 0xb6c8c980\\n    error IDA_SUBSCRIPTION_ALREADY_APPROVED(); // 0x3eb2f849\\n    error IDA_SUBSCRIPTION_IS_NOT_APPROVED();  // 0x37412573\\n    error IDA_INSUFFICIENT_BALANCE();          // 0x16e759bb\\n    error IDA_ZERO_ADDRESS_SUBSCRIBER();       // 0xc90a4674\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\");\\n    }\\n\\n    /**************************************************************************\\n     * Index operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Create a new index for the publisher\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function createIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n    * @dev Index created event\\n    * @param token Super token address\\n    * @param publisher Index creator and publisher\\n    * @param indexId The specified indexId of the newly created index\\n    * @param userData The user provided data\\n    */\\n    event IndexCreated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Query the data of a index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @return exist Does the index exist\\n     * @return indexValue Value of the current index\\n     * @return totalUnitsApproved Total units approved for the index\\n     * @return totalUnitsPending Total units pending approval for the index\\n     */\\n    function getIndex(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                uint128 indexValue,\\n                uint128 totalUnitsApproved,\\n                uint128 totalUnitsPending);\\n\\n    /**\\n     * @dev Calculate actual distribution amount\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @return actualAmount The amount to be distributed after ensuring no rounding errors\\n     * @return newIndexValue The index value given the desired amount of tokens to be distributed\\n     */\\n    function calculateDistribution(\\n       ISuperfluidToken token,\\n       address publisher,\\n       uint32 indexId,\\n       uint256 amount)\\n           external view\\n           virtual\\n           returns(\\n               uint256 actualAmount,\\n               uint128 newIndexValue);\\n\\n    /**\\n     * @dev Update index value of an index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param indexValue Value of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function updateIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index updated event\\n      * @param token Super token address\\n      * @param publisher Index updater and publisher\\n      * @param indexId The specified indexId of the updated index\\n      * @param oldIndexValue The previous index value\\n      * @param newIndexValue The updated index value\\n      * @param totalUnitsPending The total units pending when the indexValue was updated\\n      * @param totalUnitsApproved The total units approved when the indexValue was updated\\n      * @param userData The user provided data\\n      */\\n    event IndexUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        uint128 oldIndexValue,\\n        uint128 newIndexValue,\\n        uint128 totalUnitsPending,\\n        uint128 totalUnitsApproved,\\n        bytes userData);\\n\\n    /**\\n     * @dev Distribute tokens through the index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:note \\n     * - This is a convenient version of updateIndex. It adds to the index\\n     *   a delta that equals to `amount / totalUnits`\\n     * - The actual amount distributed could be obtained via\\n     *   `calculateDistribution`. This is due to precision error with index\\n     *   value and units data range\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function distribute(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n\\n    /**************************************************************************\\n     * Subscription operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Approve the subscription of an index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     */\\n    function approveSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index subscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The approved subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexSubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n\\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionApproved(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n    * @notice Revoke the subscription of an index\\n    * @dev \\\"Unapproves\\\" the subscription and moves approved units to pending\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function revokeSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n         external\\n         virtual\\n         returns(bytes memory newCtx);\\n    /**\\n      * @dev Index unsubscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The unsubscribed subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexUnsubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionRevoked(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Update the nuber of units of a subscription\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @param units Number of units of the subscription\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function updateSubscription(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n      * @dev Index units updated event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event IndexUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription units updated event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param indexId The specified indexId\\n      * @param publisher Index publisher\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint128 units,\\n        bytes userData);\\n\\n    /**\\n     * @dev Get data of a subscription\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @return exist Does the subscription exist?\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @notice Get data of a subscription by agreement ID\\n     * @dev indexId (agreementId) is the keccak256 hash of encodePacked(\\\"publisher\\\", publisher, indexId)\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return publisher The publisher of the index\\n     * @return indexId Id of the index\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscriptionByID(\\n        ISuperfluidToken token,\\n        bytes32 agreementId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address publisher,\\n                uint32 indexId,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @dev List subscriptions of an user\\n     * @param token Super token address\\n     * @param subscriber The subscriber's address\\n     * @return publishers Publishers of the subcriptions\\n     * @return indexIds Indexes of the subscriptions\\n     * @return unitsList Units of the subscriptions\\n     */\\n    function listSubscriptions(\\n        ISuperfluidToken token,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address[] memory publishers,\\n                uint32[] memory indexIds,\\n                uint128[] memory unitsList);\\n\\n    /**\\n     * @dev Delete the subscription of an user\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber's address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if the subscriber called it\\n     *   - AgreementTerminated callback to the publsiher:\\n     *      - agreementId is for the subscription\\n     * - if the publisher called it\\n     *   - AgreementTerminated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function deleteSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n    * @dev Claim pending distributions\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param subscriber The subscriber's address\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:note The subscription should not be approved yet\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function claim(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n        external\\n        virtual\\n        returns(bytes memory newCtx);\\n    \\n    /**\\n      * @dev Index distribution claimed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param amount The pending amount claimed\\n      */\\n    event IndexDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint256 amount);\\n    \\n    /**\\n      * @dev Subscription distribution claimed event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param amount The pending amount claimed\\n      */\\n    event SubscriptionDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint256 amount);\\n\\n}\\n\",\"keccak256\":\"0xac0ea75673feea931d1129ffff440390a0dd3a8f8cfa60fdb1481342652dc348\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/CustomSuperTokenBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\n// We export this too because it seems reasonable for a custom super token.\\n// solhint-disable-next-line no-unused-import\\nimport { ISuperToken } from \\\"../../interfaces/superfluid/ISuperToken.sol\\\";\\n\\n/**\\n * @title Custom super token base contract\\n * @author Superfluid\\n * NOTE:\\n * - Because of how solidity lays out its storage variables and how custom\\n *   super tokens inherit the SuperToken standard implementation, it is\\n *   required that the custom token proxy pads its implementation\\n *   with reserved storage used by the Super Token implementation.\\n * - You will need to append your own proxy implementation after the base\\n *   - Refer to SETH.sol for an example how it is used.\\n */\\nabstract contract CustomSuperTokenBase {\\n    // This (32) is the hard-coded number of storage slots used by the super token\\n    uint256[32] internal _storagePaddings;\\n}\\n\",\"keccak256\":\"0xb2930ab4127c971a5317e251797036bb4f5249ad5b125cceaf72767748764913\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\n/**\\n * @title Super app definitions library\\n * @author Superfluid\\n */\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppCallbackLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n\\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n\\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\\n    }\\n}\\n\\n/**\\n * @title Context definitions library\\n * @author Superfluid\\n */\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appCallbackLevel, uint8 callType)\\n    {\\n        appCallbackLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appCallbackLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appCallbackLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\n/**\\n * @title Flow Operator definitions library\\n  * @author Superfluid\\n */\\nlibrary FlowOperatorDefinitions {\\n   uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\\n   uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\\n   uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\\n   uint8 constant internal AUTHORIZE_FULL_CONTROL =\\n       AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\\n   uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\\n   uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\\n   uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\\n\\n   function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\\n       return (\\n           permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\\n               | AUTHORIZE_FLOW_OPERATOR_UPDATE\\n               | AUTHORIZE_FLOW_OPERATOR_DELETE)\\n           ) == uint8(0);\\n   }\\n}\\n\\n/**\\n * @title Batch operation library\\n * @author Superfluid\\n */\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev ERC777.send batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationSend(\\n     *     abi.decode(data, (address recipient, uint256 amount, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC777_SEND = 3;\\n    /**\\n     * @dev ERC20.increaseAllowance batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationIncreaseAllowance(\\n     *     abi.decode(data, (address account, address spender, uint256 addedValue))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_INCREASE_ALLOWANCE = 4;\\n    /**\\n     * @dev ERC20.decreaseAllowance batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDecreaseAllowance(\\n     *     abi.decode(data, (address account, address spender, uint256 subtractedValue))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_DECREASE_ALLOWANCE = 5;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes callData, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\n/**\\n * @title Superfluid governance configs library\\n * @author Superfluid\\n */\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\\\");\\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32)\\n    {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n\\n    function decodePPPConfig(uint256 pppConfig) internal pure\\n        returns (uint256 liquidationPeriod, uint256 patricianPeriod)\\n    {\\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\\n        patricianPeriod = pppConfig & type(uint32).max;\\n    }\\n}\\n\",\"keccak256\":\"0xdb22b7d9ef9c3bcf5b5ec64b965d371ed0fa8493486d45e5cb7f52718baec7d8\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantInflowNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\n\\ninterface IConstantInflowNFT is IFlowNFTBase {\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n    error CIF_NFT_ONLY_CONSTANT_OUTFLOW(); // 0xe81ef57a\\n\\n    /**************************************************************************\\n     * Write Functions\\n     *************************************************************************/\\n\\n    /// @notice The mint function emits the \\\"mint\\\" `Transfer` event.\\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\\n    /// is to inform clients that search for events.\\n    /// @param to the flow receiver (inflow NFT receiver)\\n    /// @param newTokenId the new token id\\n    function mint(address to, uint256 newTokenId) external;\\n\\n    /// @notice This burn function emits the \\\"burn\\\" `Transfer` event.\\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\\n    /// is to inform clients that search for events.\\n    /// @param tokenId desired token id to burn\\n    function burn(uint256 tokenId) external;\\n}\\n\",\"keccak256\":\"0xb219bf31e236fe6c2968ecf0f6c3eb24cb6774aaf4fcc83252e9b06bba718f33\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantOutflowNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\n\\ninterface IConstantOutflowNFT is IFlowNFTBase {\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n\\n    error COF_NFT_INVALID_SUPER_TOKEN();            // 0x6de98774\\n    error COF_NFT_MINT_TO_AND_FLOW_RECEIVER_SAME(); // 0x0d1d1161\\n    error COF_NFT_MINT_TO_ZERO_ADDRESS();           // 0x43d05e51\\n    error COF_NFT_ONLY_CONSTANT_INFLOW();           // 0xa495a718\\n    error COF_NFT_ONLY_FLOW_AGREEMENTS();           // 0xd367b64f\\n    error COF_NFT_TOKEN_ALREADY_EXISTS();           // 0xe2480183\\n\\n\\n    /**************************************************************************\\n     * Write Functions\\n     *************************************************************************/\\n\\n    /// @notice The onCreate function is called when a new flow is created.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onCreate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n\\n    /// @notice The onUpdate function is called when a flow is updated.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onUpdate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n\\n    /// @notice The onDelete function is called when a flow is deleted.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onDelete(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n}\\n\",\"keccak256\":\"0x15799c1552fa7aad4c1a7197451cd02422a6c768b236ab2904e72f7158a4a2c2\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IFlowNFTBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\ninterface IFlowNFTBase is IERC721Metadata {\\n    // FlowNFTData struct storage packing:\\n    // b = bits\\n    // WORD 1: | superToken      | FREE\\n    //         | 160b            | 96b\\n    // WORD 2: | flowSender      | FREE\\n    //         | 160b            | 96b\\n    // WORD 3: | flowReceiver    | flowStartDate | FREE\\n    //         | 160b            | 32b           | 64b\\n    struct FlowNFTData {\\n        address superToken;\\n        address flowSender;\\n        address flowReceiver;\\n        uint32 flowStartDate;\\n    }\\n\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n\\n    error CFA_NFT_APPROVE_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();   // 0xa3352582\\n    error CFA_NFT_APPROVE_TO_CALLER();                              // 0xd3c77329\\n    error CFA_NFT_APPROVE_TO_CURRENT_OWNER();                       // 0xe4790b25\\n    error CFA_NFT_INVALID_TOKEN_ID();                               // 0xeab95e3b\\n    error CFA_NFT_ONLY_SUPER_TOKEN_FACTORY();                       // 0xebb7505b\\n    error CFA_NFT_TRANSFER_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();  // 0x2551d606\\n    error CFA_NFT_TRANSFER_FROM_INCORRECT_OWNER();                  // 0x5a26c744\\n    error CFA_NFT_TRANSFER_IS_NOT_ALLOWED();                        // 0xaa747eca\\n    error CFA_NFT_TRANSFER_TO_ZERO_ADDRESS();                       // 0xde06d21e\\n\\n    /**************************************************************************\\n     * Events\\n     *************************************************************************/\\n\\n    /// @notice Informs third-party platforms that NFT metadata should be updated\\n    /// @dev This event comes from https://eips.ethereum.org/EIPS/eip-4906\\n    /// @param tokenId the id of the token that should have its metadata updated\\n    event MetadataUpdate(uint256 tokenId);\\n\\n    /**************************************************************************\\n     * View\\n     *************************************************************************/\\n\\n    /// @notice An external function for querying flow data by `tokenId``\\n    /// @param tokenId the token id\\n    /// @return flowData the flow data associated with `tokenId`\\n    function flowDataByTokenId(\\n        uint256 tokenId\\n    ) external view returns (FlowNFTData memory flowData);\\n\\n    /// @notice An external function for computing the deterministic tokenId\\n    /// @dev tokenId = uint256(keccak256(abi.encode(block.chainId, superToken, flowSender, flowReceiver)))\\n    /// @param superToken the super token\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    /// @return tokenId the tokenId\\n    function getTokenId(\\n        address superToken,\\n        address flowSender,\\n        address flowReceiver\\n    ) external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Write\\n     *************************************************************************/\\n\\n    function initialize(\\n        string memory nftName,\\n        string memory nftSymbol\\n    ) external; // initializer;\\n\\n    function triggerMetadataUpdate(uint256 tokenId) external;\\n}\\n\",\"keccak256\":\"0xa1600ee907288d7852678cc43f995498a039710a4f025a8785de288c4a4ceced\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IPoolAdminNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\n// TODO\\n// solhint-disable-next-line no-empty-blocks\\ninterface IPoolAdminNFT {}\\n\",\"keccak256\":\"0xa821859afd2405819b70daa367c47fc08d71b4d601effc527542862068a07403\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IPoolMemberNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\n// TODO\\n// solhint-disable-next-line no-empty-blocks\\ninterface IPoolMemberNFT {}\\n\",\"keccak256\":\"0xba6dc0dcbd8be4a96ab5f25f90977b7c71aa1eb15df1d6835ebe2b4bb46a3045\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Super agreement interface\\n * @author Superfluid\\n */\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Get the type of the agreement class\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class\\n     * @param account Account the state belongs to\\n     * @param time Time used for the calculation\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\\n     * @return deposit Account deposit amount of this agreement\\n     * @return owedDeposit Account owed deposit amount of this agreement\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\",\"keccak256\":\"0xba0407c47917aee8b6e7cea745332d2f7244cc3b91d249426f0105b365feb0ee\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\n/**\\n * @title SuperApp interface\\n * @author Superfluid\\n * @dev Be aware of the app being jailed, when the word permitted is used.\\n */\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * @custom:note \\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass arbitary information to\\n    *         the after-hook callback.\\n    *\\n    * @custom:note \\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\",\"keccak256\":\"0x9a1cbf6d6037aac2381e8e66a2ad89e9afe6f89b290c21cb587ff6b06d137ee2\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IConstantOutflowNFT } from \\\"./IConstantOutflowNFT.sol\\\";\\nimport { IConstantInflowNFT } from \\\"./IConstantInflowNFT.sol\\\";\\n\\n/**\\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\\n * @author Superfluid\\n */\\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_CALLER_IS_NOT_OPERATOR_FOR_HOLDER();       // 0xf7f02227\\n    error SUPER_TOKEN_NOT_ERC777_TOKENS_RECIPIENT();             // 0xfe737d05\\n    error SUPER_TOKEN_INFLATIONARY_DEFLATIONARY_NOT_SUPPORTED(); // 0xe3e13698\\n    error SUPER_TOKEN_NO_UNDERLYING_TOKEN();                     // 0xf79cf656\\n    error SUPER_TOKEN_ONLY_SELF();                               // 0x7ffa6648\\n    error SUPER_TOKEN_ONLY_HOST();                               // 0x98f73704\\n    error SUPER_TOKEN_ONLY_GOV_OWNER();                          // 0xd9c7ed08\\n    error SUPER_TOKEN_APPROVE_FROM_ZERO_ADDRESS();               // 0x81638627\\n    error SUPER_TOKEN_APPROVE_TO_ZERO_ADDRESS();                 // 0xdf070274\\n    error SUPER_TOKEN_BURN_FROM_ZERO_ADDRESS();                  // 0xba2ab184\\n    error SUPER_TOKEN_MINT_TO_ZERO_ADDRESS();                    // 0x0d243157\\n    error SUPER_TOKEN_TRANSFER_FROM_ZERO_ADDRESS();              // 0xeecd6c9b\\n    error SUPER_TOKEN_TRANSFER_TO_ZERO_ADDRESS();                // 0xe219bd39\\n    error SUPER_TOKEN_NFT_PROXY_ADDRESS_CHANGED();               // 0x6bef249d\\n\\n    /**\\n     * @dev Initialize the contract\\n     */\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**************************************************************************\\n    * Immutable variables\\n    *************************************************************************/\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CONSTANT_OUTFLOW_NFT() external view returns (IConstantOutflowNFT);\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CONSTANT_INFLOW_NFT() external view returns (IConstantInflowNFT);\\n\\n    /**************************************************************************\\n    * TokenInfo & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * @custom:note SuperToken always uses 18 decimals.\\n     *\\n     * This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(TokenInfo) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     *         zero by default.\\n     *\\n     * @notice This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:note Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * @custom:emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     *         allowance mechanism. `amount` is then deducted from the caller's\\n     *         allowance.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     *         means all token operations (creation, movement and destruction) must have\\n     *         amounts that are a multiple of this number.\\n     *\\n     * @custom:note For super token contracts, this value is always 1\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\\n     *      the corresponding functions will be called with `userData` and empty\\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata userData) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply and transfers the underlying token to the caller's account.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `userData` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata userData) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * @custom:emits an {AuthorizedOperator} event.\\n     *\\n     * @custom:requirements\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * @custom:emits a {RevokedOperator} event.\\n     *\\n     * @custom:requirements\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `userData` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `userData` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     * If `userData` is not empty, the `tokensReceived` hook is invoked according to ERC777 semantics.\\n     *\\n     * @custom:modifiers\\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    * If `userData` is not empty, the `tokensToSend` hook is invoked according to ERC777 semantics.\\n    *\\n    * @custom:modifiers\\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n   /**\\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\\n    * spend tokens of `sender`.\\n    *\\n    * @custom:modifiers\\n    *  - onlySelf\\n    */\\n   function selfTransferFrom(\\n        address sender,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n   ) external;\\n\\n   /**\\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\\n    * `account`.\\n    *\\n    * @custom:modifiers\\n    *  - onlySelf\\n    */\\n   function selfApproveFor(\\n        address account,\\n        address spender,\\n        uint256 amount\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to receive upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param userData User data for the TokensRecipient callback\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     *\\n     * @custom:warning\\n     * - there is potential of reentrancy IF the \\\"to\\\" account is a registered ERC777 recipient.\\n     * @custom:requirements\\n     * - if `userData` is NOT empty AND `to` is a contract, it MUST be a registered ERC777 recipient\\n     *   otherwise it reverts.\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata userData) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20 and transfer immediately\\n     * @param to The account to receive downgraded tokens\\n     * @param amount Number of tokens to be downgraded (in 18 decimals)\\n     */\\n    function downgradeTo(address to, uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are downgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    function operationIncreaseAllowance(\\n        address account,\\n        address spender,\\n        uint256 addedValue\\n    ) external;\\n\\n    function operationDecreaseAllowance(\\n        address account,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transferFrom by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC777 send by host contract.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    * @param userData Arbitrary user inputted data\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationSend(\\n        address spender,\\n        address recipient,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n    // Flow NFT events\\n    /**\\n     * @dev Constant Outflow NFT proxy created event\\n     * @param constantOutflowNFT constant outflow nft address\\n     */\\n    event ConstantOutflowNFTCreated(\\n        IConstantOutflowNFT indexed constantOutflowNFT\\n    );\\n\\n    /**\\n     * @dev Constant Inflow NFT proxy created event\\n     * @param constantInflowNFT constant inflow nft address\\n     */\\n    event ConstantInflowNFTCreated(\\n        IConstantInflowNFT indexed constantInflowNFT\\n    );\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\",\"keccak256\":\"0xa8a3d0d97b11244bb58331dc53b8152c03337b5e7907182b15bcfcfae355cdd7\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { IERC20, ERC20WithTokenInfo } from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\n\\n/**\\n * @title Super token factory interface\\n * @author Superfluid\\n */\\ninterface ISuperTokenFactory {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_FACTORY_ALREADY_EXISTS();                 // 0x91d67972\\n    error SUPER_TOKEN_FACTORY_DOES_NOT_EXIST();                 // 0x872cac48\\n    error SUPER_TOKEN_FACTORY_UNINITIALIZED();                  // 0x1b39b9b4\\n    error SUPER_TOKEN_FACTORY_ONLY_HOST();                      // 0x478b8e83\\n    error SUPER_TOKEN_FACTORY_NON_UPGRADEABLE_IS_DEPRECATED();  // 0xc4901a43\\n    error SUPER_TOKEN_FACTORY_ZERO_ADDRESS();                   // 0x305c9e82\\n\\n    /**************************************************************************\\n    * Immutable Variables\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @notice Get the canonical super token logic.\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABLE\\n    }\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     */\\n    function createERC20Wrapper(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        ERC20WithTokenInfo underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Creates a wrapper super token AND sets it in the canonical list OR reverts if it already exists\\n     * @dev salt for create2 is the keccak256 hash of abi.encode(address(_underlyingToken))\\n     * @param _underlyingToken Underlying ERC20 token\\n     * @return ISuperToken the created supertoken\\n     */\\n    function createCanonicalERC20Wrapper(ERC20WithTokenInfo _underlyingToken)\\n        external\\n        returns (ISuperToken);\\n\\n    /**\\n     * @notice Computes/Retrieves wrapper super token address given the underlying token address\\n     * @dev We return from our canonical list if it already exists, otherwise we compute it\\n     * @dev note that this function only computes addresses for SEMI_UPGRADABLE SuperTokens\\n     * @param _underlyingToken Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     * @return isDeployed whether the super token is deployed AND set in the canonical mapping\\n     */\\n    function computeCanonicalERC20WrapperAddress(address _underlyingToken)\\n        external\\n        view\\n        returns (address superTokenAddress, bool isDeployed);\\n\\n    /**\\n     * @notice Gets the canonical ERC20 wrapper super token address given the underlying token address\\n     * @dev We return the address if it exists and the zero address otherwise\\n     * @param _underlyingTokenAddress Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     */\\n    function getCanonicalERC20Wrapper(address _underlyingTokenAddress)\\n        external\\n        view\\n        returns (address superTokenAddress);\\n\\n    /**\\n     * @dev Creates a new custom super token\\n     * @param customSuperTokenProxy address of the custom supertoken proxy\\n     */\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    /**\\n      * @dev Super token logic created event\\n      * @param tokenLogic Token logic address\\n      */\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    /**\\n      * @dev Super token created event\\n      * @param token Newly created super token address\\n      */\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    /**\\n      * @dev Custom super token created event\\n      * @param token Newly created custom super token address\\n      */\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\",\"keccak256\":\"0xbfc7fbef20c707e64adabe969ea6db4d6c26a56155961a8bf46b7e55a16a046d\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\n// ISuperfluid.sol can also be used as an umbrella-import for everything Superfluid, hence we should have these unused\\n// import.\\n//\\n// solhint-disable no-unused-import\\n\\n/// Global definitions\\nimport {\\n    SuperAppDefinitions,\\n    ContextDefinitions,\\n    FlowOperatorDefinitions,\\n    BatchOperation,\\n    SuperfluidGovernanceConfigs\\n} from \\\"./Definitions.sol\\\";\\n/// Super token related interfaces:\\n/// Note: CustomSuperTokenBase is not included for people building CustomSuperToken.\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { TokenInfo, ERC20WithTokenInfo } from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperTokenFactory } from \\\"./ISuperTokenFactory.sol\\\";\\nimport { ISETH } from \\\"../tokens/ISETH.sol\\\";\\n/// Superfluid/ERC20x NFTs\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\nimport { IConstantOutflowNFT } from \\\"./IConstantOutflowNFT.sol\\\";\\nimport { IConstantInflowNFT } from \\\"./IConstantInflowNFT.sol\\\";\\nimport { IPoolAdminNFT } from \\\"./IPoolAdminNFT.sol\\\";\\nimport { IPoolMemberNFT } from \\\"./IPoolMemberNFT.sol\\\";\\n/// Superfluid agreement interfaces:\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { IConstantFlowAgreementV1 } from \\\"../agreements/IConstantFlowAgreementV1.sol\\\";\\nimport { IInstantDistributionAgreementV1 } from \\\"../agreements/IInstantDistributionAgreementV1.sol\\\";\\n/// Superfluid App interfaces:\\nimport { ISuperApp } from \\\"./ISuperApp.sol\\\";\\n/// Superfluid governance\\nimport { ISuperfluidGovernance } from \\\"./ISuperfluidGovernance.sol\\\";\\n\\n/**\\n * @title Host interface\\n * @author Superfluid\\n * @notice This is the central contract of the system where super agreement, super app\\n * and super token features are connected.\\n *\\n * The Superfluid host contract is also the entry point for the protocol users,\\n * where batch call and meta transaction are provided for UX improvements.\\n *\\n */\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    // Superfluid Custom Errors\\n    error HOST_AGREEMENT_CALLBACK_IS_NOT_ACTION();              // 0xef4295f6\\n    error HOST_CANNOT_DOWNGRADE_TO_NON_UPGRADEABLE();           // 0x474e7641\\n    error HOST_CALL_AGREEMENT_WITH_CTX_FROM_WRONG_ADDRESS();    // 0x0cd0ebc2\\n    error HOST_CALL_APP_ACTION_WITH_CTX_FROM_WRONG_ADDRESS();   // 0x473f7bd4\\n    error HOST_INVALID_CONFIG_WORD();                           // 0xf4c802a4\\n    error HOST_MAX_256_AGREEMENTS();                            // 0x7c281a78\\n    error HOST_NON_UPGRADEABLE();                               // 0x14f72c9f\\n    error HOST_NON_ZERO_LENGTH_PLACEHOLDER_CTX();               // 0x67e9985b\\n    error HOST_ONLY_GOVERNANCE();                               // 0xc5d22a4e\\n    error HOST_UNKNOWN_BATCH_CALL_OPERATION_TYPE();             // 0xb4770115\\n    error HOST_AGREEMENT_ALREADY_REGISTERED();                  // 0xdc9ddba8\\n    error HOST_AGREEMENT_IS_NOT_REGISTERED();                   // 0x1c9e9bea\\n    error HOST_MUST_BE_CONTRACT();                              // 0xd4f6b30c\\n    error HOST_ONLY_LISTED_AGREEMENT();                         // 0x619c5359\\n    error HOST_NEED_MORE_GAS();                                 // 0xd4f5d496\\n\\n    // App Related Custom Errors\\n    // uses SuperAppDefinitions' App Jail Reasons as _code\\n    error APP_RULE(uint256 _code);                              // 0xa85ba64f\\n\\n    error HOST_INVALID_OR_EXPIRED_SUPER_APP_REGISTRATION_KEY(); // 0x19ab84d1\\n    error HOST_NOT_A_SUPER_APP();                               // 0x163cbe43\\n    error HOST_NO_APP_REGISTRATION_PERMISSIONS();               // 0x5b93ebf0\\n    error HOST_RECEIVER_IS_NOT_SUPER_APP();                     // 0x96aa315e\\n    error HOST_SENDER_IS_NOT_SUPER_APP();                       // 0xbacfdc40\\n    error HOST_SOURCE_APP_NEEDS_HIGHER_APP_LEVEL();             // 0x44725270\\n    error HOST_SUPER_APP_IS_JAILED();                           // 0x02384b64\\n    error HOST_SUPER_APP_ALREADY_REGISTERED();                  // 0x01b0a935\\n    error HOST_UNAUTHORIZED_SUPER_APP_FACTORY();                // 0x289533c5\\n\\n    /**************************************************************************\\n     * Time\\n     *\\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\\n     * > Neo: Then why can't I see what happens to her?\\n     * > The Oracle: We can never see past the choices we don't understand.\\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\\n     *************************************************************************/\\n\\n    function getNow() external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governance address of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n    /**\\n     * @dev Governance replaced event\\n     * @param oldGov Address of the old governance contract\\n     * @param newGov Address of the new governance contract\\n     */\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic Initial agreement class code\\n     *\\n     * @custom:modifiers\\n     * - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class registered event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type registered\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * @custom:modifiers\\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class updated event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type updated\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n\\n    /**\\n    * @notice Check if the agreement type is whitelisted\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @notice Get agreement class\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @notice Create a new bitmask by adding a agreement class to it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @notice Create a new bitmask by removing a agreement class from it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n    /**\\n     * @dev SuperToken factory updated event\\n     * @param newFactory Address of the new factory\\n     */\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n\\n    /**\\n     * @notice Update the super token logic to the latest (canonical) implementation\\n     * if `newLogicOverride` is zero, or to `newLogicOverride` otherwise.\\n     * or to the provided implementation `.\\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\\n     */\\n    function updateSuperTokenLogic(ISuperToken token, address newLogicOverride) external;\\n    /**\\n     * @notice Update the super token logic to the provided one\\n     * @dev newLogic must implement UUPSProxiable with matching proxiableUUID\\n     */\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares itself as a super app.\\n     * @custom:deprecated you should use `registerAppWithKey` or `registerAppByFactory` instead,\\n     * because app registration is currently governance permissioned on mainnets.\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     */\\n    function registerApp(uint256 configWord) external;\\n    /**\\n     * @dev App registered event\\n     * @param app Address of jailed app\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev Message sender declares itself as a super app.\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.\\n     * @notice See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     * On testnets or in dev environment, a placeholder (e.g. empty string) can be used.\\n     * While the message sender must be the super app itself, the transaction sender (tx.origin)\\n     * must be the deployer account the registration key was issued for.\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares app as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @notice On mainnet deployments, only factory contracts pre-authorized by governance can use this.\\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app callbacklevel\\n     * @param app Super app address\\n     */\\n    function getAppCallbackLevel(ISuperApp app) external view returns(uint8 appCallbackLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The target super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app is allowed to call the target app as downstream app\\n     * @param app Super app address\\n     * @param targetApp The target super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app credit and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev (For agreements) StaticCall the app before callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return cbdata            Data returned from the callback.\\n     */\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory cbdata);\\n\\n    /**\\n     * @dev (For agreements) Call the app after callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return newCtx            The current context of the transaction.\\n     */\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Create a new callback stack\\n     * @param  ctx                     The current ctx, it will be validated.\\n     * @param  app                     The super app.\\n     * @param  appCreditGranted        App credit granted so far.\\n     * @param  appCreditUsed           App credit used so far.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appCreditGranted,\\n        int256 appCreditUsed,\\n        ISuperfluidToken appCreditToken\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Pop from the current app callback stack\\n     * @param  ctx                     The ctx that was pushed before the callback stack.\\n     * @param  appCreditUsedDelta      App credit used by the app.\\n     * @return newCtx                  The current context of the transaction.\\n     *\\n     * @custom:security\\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\\n     */\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appCreditUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Use app credit.\\n     * @param  ctx                      The current ctx, it will be validated.\\n     * @param  appCreditUsedMore        See app credit for more details.\\n     * @return newCtx                   The current context of the transaction.\\n     */\\n    function ctxUseCredit(\\n        bytes calldata ctx,\\n        int256 appCreditUsedMore\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Jail the app.\\n     * @param  app                     The super app.\\n     * @param  reason                  Jail reason code.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Jail event for the app\\n     * @param app Address of jailed app\\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param agreementClass The agreement address you are calling\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        //isAgreement(agreementClass)\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @notice Call app action\\n     * @dev Main use case is calling app action in a batch call via the host\\n     * @param callData The contextual call data\\n     *\\n     * @custom:note See \\\"Contextless Call Proxies\\\" above for more about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        //isValidAppAction(callData)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Context Struct\\n     *\\n     * @custom:note on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     * - We cannot change the structure of the Context struct because of ABI compatibility requirements\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // app callback level\\n        uint8 appCallbackLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app credit granted\\n        uint256 appCreditGranted;\\n        // app credit wanted by the app callback\\n        uint256 appCreditWantedDeprecated;\\n        // app credit used, allowing negative values over a callback session\\n        // the appCreditUsed value over a callback sessions is calculated with:\\n        // existing flow data owed deposit + sum of the callback agreements\\n        // deposit deltas\\n        // the final value used to modify the state is determined by the\\n        // _adjustNewAppCreditUsed function (in AgreementLibrary.sol) which takes\\n        // the appCreditUsed value reached in the callback session and the app\\n        // credit granted\\n        int256 appCreditUsed;\\n        // app address\\n        address appAddress;\\n        // app credit in super token\\n        ISuperfluidToken appCreditToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes memory ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation type. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations\\n     */\\n    function batchCall(Operation[] calldata operations) external;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations\\n     */\\n    function forwardBatchCall(Operation[] calldata operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage doesn't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev Require the ctx being valid.\\n     modifier requireValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev Assert the ctx being valid.\\n     modifier assertValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\",\"keccak256\":\"0x6bf8494d93a4fc67d67b4a26ea9885707014f2123acd53d7cd0fd99987e30096\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Superfluid governance interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidGovernance {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_GOV_INVALID_LIQUIDATION_OR_PATRICIAN_PERIOD(); // 0xe171980a\\n    error SF_GOV_MUST_BE_CONTRACT();                        // 0x80dddd73\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * @custom:note\\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the provided logic contracts.\\n     *      Note that this is an overloaded version taking an additional argument `tokenLogics`\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens,\\n        address[] calldata tokenLogics) external;\\n\\n    /**\\n     * @dev Set configuration as address value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        address value\\n    ) external;\\n\\n    /**\\n     * @dev Set configuration as uint256 value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        uint256 value\\n    ) external;\\n\\n    /**\\n     * @dev Clear configuration\\n     */\\n    function clearConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key\\n    ) external;\\n\\n    /**\\n     * @dev Get configuration as address value\\n     */\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /**\\n     * @dev Get configuration as uint256 value\\n     */\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\",\"keccak256\":\"0xb9328d0977bd022c6771e679518c3d2bfcb6e29b400d2506813bb3cdab772bb4\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\n\\n/**\\n * @title Superfluid token interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_TOKEN_AGREEMENT_ALREADY_EXISTS();  // 0xf05521f6\\n    error SF_TOKEN_AGREEMENT_DOES_NOT_EXIST();  // 0xdae18809\\n    error SF_TOKEN_BURN_INSUFFICIENT_BALANCE(); // 0x10ecdf44\\n    error SF_TOKEN_MOVE_INSUFFICIENT_BALANCE(); // 0x2f4cb941\\n    error SF_TOKEN_ONLY_LISTED_AGREEMENT();     // 0xc9ff6644\\n    error SF_TOKEN_ONLY_HOST();                 // 0xc51efddd\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**\\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\\n     *\\n     * @custom:note \\n     * - version: 1\\n     * - liquidationType key:\\n     *    - 0 = reward account receives reward (PIC period)\\n     *    - 1 = liquidator account receives reward (Pleb period)\\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\\n     */\\n    struct LiquidationTypeData {\\n        uint256 version;\\n        uint8 liquidationType;\\n    }\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @notice Calculate the realtime balance given the current host.getNow() value\\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\\n     * @param account for the query\\n     * @return availableBalance Real-time balance\\n     * @return deposit Account deposit\\n     * @return owedDeposit Account owed Deposit\\n     */\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @notice Check if account is critical\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @notice Check if account is critical now (current host.getNow())\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @notice Check if account is solvent\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @notice Check if account is solvent now\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @notice Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement created event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n    /**\\n     * @dev Agreement terminated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * @custom:note \\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of an agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @notice Settle balance from an account by the agreement\\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Make liquidation payouts (v2)\\n     * @param id Agreement ID\\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\\n     * @param targetAccount Account to be liquidated\\n     * @param rewardAmount The amount the rewarded account will receive\\n     * @param targetAccountBalanceDelta The delta amount the target account balance should change by\\n     *\\n     * @custom:note \\n     * - If a bailout is required (bailoutAmount > 0)\\n     *   - the actual reward (single deposit) goes to the executor,\\n     *   - while the reward account becomes the bailout account\\n     *   - total bailout include: bailout amount + reward amount\\n     *   - the targetAccount will be bailed out\\n     * - If a bailout is not required\\n     *   - the targetAccount will pay the rewardAmount\\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayoutsV2\\n    (\\n        bytes32 id,\\n        bytes memory liquidationTypeData,\\n        address liquidatorAccount,\\n        bool useDefaultRewardAccount,\\n        address targetAccount,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta\\n    ) external;\\n    /**\\n     * @dev Agreement liquidation event v2 (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param targetAccount Account of the stream sender\\n     * @param rewardAmountReceiver Account that collects the reward or bails out insolvent accounts\\n     * @param rewardAmount The amount the reward recipient account balance should change by\\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if the agreement is liquidated during the PIC period\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit)\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the targetAccount is insolvent\\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\\n     *   - the default reward account (governance) will pay for both the rewardAmount and bailoutAmount\\n     *   - the targetAccount will receive the bailoutAmount\\n     */\\n    event AgreementLiquidatedV2(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed liquidatorAccount,\\n        address indexed targetAccount,\\n        address rewardAmountReceiver,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta,\\n        bytes liquidationTypeData\\n    );\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n    /**************************************************************************\\n     * DEPRECATED\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n}\\n\",\"keccak256\":\"0x18ea972421ff57ce62103f90c820ee039f170f0189a4b3c73fd0ff09452d1dbf\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenInfo } from \\\"./TokenInfo.sol\\\";\\n\\n/**\\n * @title ERC20 token with token info interface\\n * @author Superfluid\\n * @dev Using abstract contract instead of interfaces because old solidity\\n *      does not support interface inheriting other interfaces\\n * solhint-disable-next-line no-empty-blocks\\n *\\n */\\n// solhint-disable-next-line no-empty-blocks\\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\\n\",\"keccak256\":\"0x479247ae4308ea9f5b50ff2bdae1299e91153a2c391a60e5d77cb3c980e527b9\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperToken } from \\\"../superfluid/ISuperToken.sol\\\";\\n\\n\\n/**\\n * @title Super ETH (SETH) custom token interface\\n * @author Superfluid\\n */\\ninterface ISETHCustom {\\n    // using native token\\n    function upgradeByETH() external payable;\\n    function upgradeByETHTo(address to) external payable;\\n    function downgradeToETH(uint wad) external;\\n}\\n\\n/**\\n * @title Super ETH (SETH) full interface\\n * @author Superfluid\\n */\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISETH is ISETHCustom, ISuperToken {}\\n\",\"keccak256\":\"0x9857ab20198ca28d75afcf2f6843a23a1052bf2199a308392f8e2d8a63914cbc\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\n/**\\n * @title ERC20 token info interface\\n * @author Superfluid\\n * @dev ERC20 standard interface does not specify these functions, but\\n *      often the token implementations have them.\\n */\\ninterface TokenInfo {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x5adaf0dcec7b8f91b9958c013fc3109f7b8b0efcd30391dc2bc1d98e0d406c0d\",\"license\":\"MIT\"},\"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface IV3SwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// that may remain in the router after the swap.\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// that may remain in the router after the swap.\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0xa2300af2b82af292216a8f3f301a86e65463655fff9fb791515e3fd2ccf4a14c\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x3f485fb1a44e8fbeadefb5da07d66edab3cfe809f0ac4074b1e54e3eb3c4cf69\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\",\"keccak256\":\"0x9af98b0908c96320ca6d08b22f0efca864742f6adbe5794cafe2d1d2e808b0cd\",\"license\":\"GPL-2.0-or-later\"},\"contracts/DirectPayments/DirectPaymentsFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n// import the DirectPayments contract\\nimport \\\"./DirectPaymentsPool.sol\\\";\\nimport \\\"./ProvableNFT.sol\\\";\\nimport \\\"../GoodCollective/SuperAppBaseFlow.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\\\";\\nimport { AccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\ncontract DirectPaymentsFactory is AccessControlUpgradeable, UUPSUpgradeable {\\n    error NOT_PROJECT_OWNER();\\n    error NOT_POOL();\\n\\n    event PoolCreated(\\n        address indexed pool,\\n        string indexed projectId,\\n        string ipfs,\\n        uint32 indexed nftType,\\n        DirectPaymentsPool.PoolSettings poolSettings,\\n        DirectPaymentsPool.SafetyLimits poolLimits\\n    );\\n\\n    event PoolDetailsChanged(address indexed pool, string ipfs);\\n    event PoolVerifiedChanged(address indexed pool, bool isVerified);\\n    event UpdatedImpl(address indexed impl);\\n\\n    struct PoolRegistry {\\n        string ipfs;\\n        bool isVerified;\\n        string projectId;\\n    }\\n\\n    UpgradeableBeacon public impl;\\n    ProvableNFT public nft;\\n    uint32 public nextNftType;\\n\\n    mapping(address => PoolRegistry) public registry;\\n    mapping(bytes32 => DirectPaymentsPool) public projectIdToControlPool;\\n\\n    address public feeRecipient;\\n    uint32 public feeBps;\\n\\n    mapping(address => address[]) public memberPools;\\n    address[] public pools;\\n\\n    modifier onlyProjectOwnerOrNon(string memory projectId) {\\n        DirectPaymentsPool controlPool = projectIdToControlPool[keccak256(bytes(projectId))];\\n        // console.log(\\\"result %s\\\", controlPool.hasRole(controlPool.DEFAULT_ADMIN_ROLE(), msg.sender));\\n        if (address(controlPool) != address(0)) {\\n            if (controlPool.hasRole(controlPool.DEFAULT_ADMIN_ROLE(), msg.sender) == false) {\\n                revert NOT_PROJECT_OWNER();\\n            }\\n        }\\n        _;\\n    }\\n\\n    modifier onlyPoolOwner(DirectPaymentsPool pool) {\\n        if (pool.hasRole(pool.DEFAULT_ADMIN_ROLE(), msg.sender) == false) {\\n            revert NOT_PROJECT_OWNER();\\n        }\\n\\n        _;\\n    }\\n\\n    modifier onlyPool() {\\n        if (bytes(registry[msg.sender].projectId).length == 0) {\\n            revert NOT_POOL();\\n        }\\n        _;\\n    }\\n\\n    function _authorizeUpgrade(address _impl) internal virtual override onlyRole(DEFAULT_ADMIN_ROLE) {}\\n\\n    function initialize(\\n        address _owner,\\n        address _dpimpl,\\n        ProvableNFT _nft,\\n        address _feeRecipient,\\n        uint32 _feeBps\\n    ) external initializer {\\n        nextNftType = 1;\\n        impl = new UpgradeableBeacon(_dpimpl);\\n        nft = _nft;\\n        feeRecipient = _feeRecipient;\\n        feeBps = _feeBps;\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\\n    }\\n\\n    //TODO: implement a pool that's auto upgradeable using beacon method\\n    function createBeaconPool(\\n        string memory _projectId,\\n        string memory _ipfs,\\n        DirectPaymentsPool.PoolSettings memory _settings,\\n        DirectPaymentsPool.SafetyLimits memory _limits,\\n        uint32 _managerFeeBps\\n    ) external onlyProjectOwnerOrNon(_projectId) returns (DirectPaymentsPool pool) {\\n        return _createPool(_projectId, _ipfs, _settings, _limits, _managerFeeBps, true);\\n    }\\n\\n    function createPool(\\n        string memory _projectId,\\n        string memory _ipfs,\\n        DirectPaymentsPool.PoolSettings memory _settings,\\n        DirectPaymentsPool.SafetyLimits memory _limits,\\n        uint32 _managerFeeBps\\n    ) external onlyProjectOwnerOrNon(_projectId) returns (DirectPaymentsPool pool) {\\n        return _createPool(_projectId, _ipfs, _settings, _limits, _managerFeeBps, false);\\n    }\\n\\n    function _createPool(\\n        string memory _projectId,\\n        string memory _ipfs,\\n        DirectPaymentsPool.PoolSettings memory _settings,\\n        DirectPaymentsPool.SafetyLimits memory _limits,\\n        uint32 _managerFeeBps,\\n        bool useBeacon\\n    ) internal returns (DirectPaymentsPool pool) {\\n        //TODO: add check if msg.sender is whitelisted\\n\\n        _settings.nftType = nextNftType;\\n        bytes memory initCall = abi.encodeCall(\\n            DirectPaymentsPool.initialize,\\n            (nft, _settings, _limits, _managerFeeBps, this)\\n        );\\n\\n        if (useBeacon) {\\n            pool = DirectPaymentsPool(address(new BeaconProxy(address(impl), initCall)));\\n        } else {\\n            pool = DirectPaymentsPool(address(new ERC1967Proxy(impl.implementation(), initCall)));\\n        }\\n\\n        // Register the app with the host\\n        IRegisterSuperapp(address(pool.host())).registerApp(address(pool), SuperAppDefinitions.APP_LEVEL_FINAL);\\n\\n        nft.grantRole(nft.getManagerRole(nextNftType), address(pool));\\n\\n        //access control to project is determinted by the first pool access control rules\\n        if (address(projectIdToControlPool[keccak256(bytes(_projectId))]) == address(0))\\n            projectIdToControlPool[keccak256(bytes(_projectId))] = pool;\\n        registry[address(pool)].ipfs = _ipfs;\\n        registry[address(pool)].projectId = _projectId;\\n\\n        pool.grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        pool.renounceRole(DEFAULT_ADMIN_ROLE, address(this));\\n        pools.push(address(pool));\\n\\n        emit PoolCreated(address(pool), _projectId, _ipfs, nextNftType, _settings, _limits);\\n\\n        nextNftType++;\\n    }\\n\\n    function changePoolDetails(DirectPaymentsPool _pool, string memory _ipfs) external onlyPoolOwner(_pool) {\\n        registry[address(_pool)].ipfs = _ipfs;\\n        emit PoolDetailsChanged(address(_pool), _ipfs);\\n    }\\n\\n    function setVerified(DirectPaymentsPool _pool, bool _isVerified) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        registry[address(_pool)].isVerified = _isVerified;\\n        emit PoolVerifiedChanged(address(_pool), _isVerified);\\n    }\\n\\n    function updateImpl(address _impl) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        impl.upgradeTo(_impl);\\n        emit UpdatedImpl(_impl);\\n    }\\n\\n    function setFeeInfo(address _feeRecipient, uint32 _feeBps) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        feeBps = _feeBps;\\n        feeRecipient = _feeRecipient;\\n    }\\n\\n    function addMember(address member) external onlyPool {\\n        memberPools[member].push(msg.sender);\\n    }\\n\\n    function removeMember(address member) external onlyPool {\\n        for (uint i = 0; i < memberPools[member].length; i++) {\\n            if (memberPools[member][i] == msg.sender) {\\n                memberPools[member][i] = memberPools[member][memberPools[member].length - 1];\\n                memberPools[member].pop();\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x08fea1f147b360516b0250fe19741f04f3fe1d7e7e7721f098d38cd3c2e755ed\",\"license\":\"MIT\"},\"contracts/DirectPayments/DirectPaymentsLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./DirectPaymentsPool.sol\\\";\\n\\nlibrary DirectPayemntsLibrary {\\n    function _updateMemberLimits(\\n        DirectPaymentsPool.LimitsData storage memberStats,\\n        uint128 reward,\\n        uint64 curMonth\\n    ) internal {\\n        if (memberStats.lastReward + 60 * 60 * 24 < block.timestamp) //more than a day passed since last reward\\n        {\\n            memberStats.daily = reward;\\n        } else {\\n            memberStats.daily += reward;\\n        }\\n\\n        if (memberStats.lastMonth < curMonth) //month switched\\n        {\\n            memberStats.monthly = reward;\\n        } else {\\n            memberStats.monthly += reward;\\n        }\\n\\n        memberStats.total += reward;\\n        memberStats.lastReward = uint64(block.timestamp);\\n        memberStats.lastMonth = curMonth;\\n    }\\n\\n    function _updateGlobalLimits(\\n        DirectPaymentsPool.LimitsData storage globalLimits,\\n        uint128 reward,\\n        uint64 curMonth\\n    ) internal {\\n        if (globalLimits.lastReward + 60 * 60 * 24 < block.timestamp) //more than a day passed since last reward\\n        {\\n            globalLimits.daily = reward;\\n        } else {\\n            globalLimits.daily += reward;\\n        }\\n\\n        if (globalLimits.lastMonth < curMonth) //month switched\\n        {\\n            globalLimits.monthly = reward;\\n        } else {\\n            globalLimits.monthly += reward;\\n        }\\n\\n        globalLimits.total += reward;\\n        globalLimits.lastReward = uint64(block.timestamp);\\n        globalLimits.lastMonth = curMonth;\\n    }\\n}\\n\",\"keccak256\":\"0x8b522b4165f280cd5b191bad1c26ba0ac98b783c1f25ef0468767b5e86d9db87\",\"license\":\"MIT\"},\"contracts/DirectPayments/DirectPaymentsPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8;\\nimport { AccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport { IERC721Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { IERC721ReceiverUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\\\";\\n\\nimport { ProvableNFT } from \\\"./ProvableNFT.sol\\\";\\nimport { DirectPaymentsFactory } from \\\"./DirectPaymentsFactory.sol\\\";\\nimport { DirectPayemntsLibrary } from \\\"./DirectPaymentsLibrary.sol\\\";\\nimport \\\"../GoodCollective/GoodCollectiveSuperApp.sol\\\";\\n\\ninterface IMembersValidator {\\n    function isMemberValid(\\n        address pool,\\n        address operator,\\n        address member,\\n        bytes memory extraData\\n    ) external returns (bool);\\n}\\n\\ninterface IIdentityV2 {\\n    function getWhitelistedRoot(address member) external view returns (address);\\n}\\n\\n/**\\n - optional members validator (but need atleast uniqueness or members)\\n - anyone can claim an nfttype\\n - project id at the registery?\\n - factory -> register the pool, claim nfttype, deploy pool\\n - events\\n */\\ncontract DirectPaymentsPool is\\n    IERC721ReceiverUpgradeable,\\n    AccessControlUpgradeable,\\n    GoodCollectiveSuperApp,\\n    UUPSUpgradeable\\n{\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n    error NOT_MANAGER();\\n    error ALREADY_CLAIMED(uint256);\\n    error NFT_MISSING(uint256);\\n    error OVER_MEMBER_LIMITS(address);\\n    error OVER_GLOBAL_LIMITS();\\n    error UNSUPPORTED_NFT();\\n    error NO_BALANCE();\\n    error NFTTYPE_CHANGED();\\n    error EMPTY_MANAGER();\\n\\n    bytes32 public constant MANAGER_ROLE = keccak256(\\\"MANAGER_ROLE\\\");\\n    bytes32 public constant MEMBER_ROLE = keccak256(\\\"MEMBER_ROLE\\\");\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER\\\");\\n\\n    event PoolCreated(\\n        address indexed pool,\\n        string indexed projectId,\\n        string ipfs,\\n        uint32 indexed nftType,\\n        DirectPaymentsPool.PoolSettings poolSettings,\\n        DirectPaymentsPool.SafetyLimits poolLimits\\n    );\\n\\n    event PoolSettingsChanged(PoolSettings settings);\\n    event PoolLimitsChanged(SafetyLimits limits);\\n    event EventRewardClaimed(\\n        uint256 indexed tokenId,\\n        uint16 eventType,\\n        uint32 eventTimestamp,\\n        uint256 eventQuantity,\\n        string eventUri,\\n        address[] contributers,\\n        uint256 rewardPerContributer\\n    );\\n    event NFTClaimed(uint256 indexed tokenId, uint256 totalRewards);\\n    event NOT_MEMBER_OR_WHITELISTED(address contributer);\\n\\n    // Define functions\\n    struct PoolSettings {\\n        uint32 nftType;\\n        uint16[] validEvents;\\n        uint128[] rewardPerEvent;\\n        address manager;\\n        IMembersValidator membersValidator;\\n        IIdentityV2 uniquenessValidator;\\n        IERC20Upgradeable rewardToken;\\n        bool allowRewardOverride;\\n    }\\n\\n    struct SafetyLimits {\\n        uint maxTotalPerMonth;\\n        uint256 maxMemberPerMonth;\\n        uint256 maxMemberPerDay;\\n    }\\n\\n    struct LimitsData {\\n        uint128 daily;\\n        uint128 monthly;\\n        uint128 total;\\n        uint64 lastReward;\\n        uint64 lastMonth;\\n    }\\n\\n    PoolSettings public settings;\\n    SafetyLimits public limits;\\n    ProvableNFT public nft;\\n\\n    mapping(uint256 => bool) public claimedNfts;\\n    mapping(address => bool) private members_unused; // using access control instead\\n    mapping(address => LimitsData) public memberLimits;\\n    LimitsData public globalLimits;\\n    DirectPaymentsFactory public registry;\\n\\n    uint32 public managerFeeBps;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(ISuperfluid _host, IV3SwapRouter _swapRouter) GoodCollectiveSuperApp(_host, _swapRouter) {}\\n\\n    /**\\n     * @dev Authorizes an upgrade for the implementation contract.\\n     * @param impl The address of the new implementation contract.\\n     */\\n    function _authorizeUpgrade(address impl) internal virtual override onlyRole(DEFAULT_ADMIN_ROLE) {}\\n\\n    function getRegistry() public view override returns (IRegistry) {\\n        return IRegistry(address(registry));\\n    }\\n\\n    function getManagerFee() public view override returns (address feeRecipient, uint32 feeBps) {\\n        return (settings.manager, managerFeeBps);\\n    }\\n\\n    /**\\n     * @dev Initializes the contract with the given settings and limits.\\n     * @param _nft The ProvableNFT contract address.\\n     * @param _settings The PoolSettings struct containing pool settings.\\n     * @param _limits The SafetyLimits struct containing safety limits.\\n     */\\n    function initialize(\\n        ProvableNFT _nft,\\n        PoolSettings memory _settings,\\n        SafetyLimits memory _limits,\\n        uint32 _managerFeeBps,\\n        DirectPaymentsFactory _registry\\n    ) external initializer {\\n        registry = _registry;\\n        settings = _settings;\\n        limits = _limits;\\n        nft = _nft;\\n        managerFeeBps = _managerFeeBps;\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // when using factory this gives factory role which then set role to the real msg.sender\\n        _setupRole(MANAGER_ROLE, _settings.manager);\\n        _setupRole(MINTER_ROLE, _settings.manager);\\n\\n        setSuperToken(ISuperToken(address(settings.rewardToken)));\\n    }\\n\\n    function upgradeToLatest(bytes memory data) external payable virtual {\\n        address impl = address(DirectPaymentsFactory(registry).impl());\\n        _authorizeUpgrade(impl);\\n        _upgradeToAndCallUUPS(impl, data, false);\\n    }\\n\\n    /**\\n     * @dev Claims rewards for the specified NFT ID.\\n     * @param _nftId The ID of the NFT to claim rewards for.\\n     */\\n    function claim(uint256 _nftId) external {\\n        claim(_nftId, nft.getNFTData(_nftId));\\n    }\\n\\n    /**\\n     * @dev Claims rewards for a given NFT ID and its associated data.\\n     * @param _nftId The ID of the NFT to claim rewards for.\\n     * @param _data The associated data for the NFT.\\n     * Emits a {ALREADY_CLAIMED} error if the NFT has already been claimed.\\n     * Emits a {NFT_MISSING} error if the NFT is not owned by this contract.\\n     */\\n\\n    function claim(uint256 _nftId, ProvableNFT.NFTData memory _data) public {\\n        nft.proveNFTData(_nftId, _data);\\n        if (claimedNfts[_nftId]) revert ALREADY_CLAIMED(_nftId);\\n\\n        // TODO: should pool own the NFTs?\\n        // if (settings.collectNfts && nft.ownerOf(_nftId) != address(this)) revert NFT_MISSING(_nftId);\\n\\n        _claim(_nftId, _data);\\n    }\\n\\n    /**\\n     * @dev Claims rewards for the specified NFT ID.\\n     * @param _nftId The ID of the NFT to claim rewards for.\\n     * @param _data The NFTData struct containing data about the NFT.\\n     */\\n    function _claim(uint256 _nftId, ProvableNFT.NFTData memory _data) internal {\\n        claimedNfts[_nftId] = true;\\n        uint totalRewards;\\n        uint rewardsBalance = settings.rewardToken.balanceOf(address(this));\\n\\n        bool allowRewardOverride = settings.allowRewardOverride;\\n        for (uint256 i = 0; i < _data.events.length; i++) {\\n            uint reward = (\\n                allowRewardOverride && _data.events[i].rewardOverride > 0\\n                    ? _data.events[i].rewardOverride\\n                    : _eventReward(_data.events[i].subtype)\\n            ) * _data.events[i].quantity;\\n            if (reward > 0) {\\n                totalRewards += reward;\\n                if (totalRewards > rewardsBalance) revert NO_BALANCE();\\n                rewardsBalance -= totalRewards;\\n                _sendReward(_data.events[i].contributers, uint128(reward));\\n                emit EventRewardClaimed(\\n                    _nftId,\\n                    _data.events[i].subtype,\\n                    _data.events[i].timestamp,\\n                    _data.events[i].quantity,\\n                    _data.events[i].eventUri,\\n                    _data.events[i].contributers,\\n                    uint128(reward / _data.events[i].contributers.length)\\n                );\\n            }\\n        }\\n\\n        emit NFTClaimed(_nftId, totalRewards);\\n    }\\n\\n    /**\\n     * @dev Returns the reward amount for the specified event type.\\n     * @param _eventType The type of the event to get the reward for.\\n     * @return reward amount for the specified event type.\\n     */\\n    function _eventReward(uint16 _eventType) internal view returns (uint128 reward) {\\n        for (uint i = 0; i < settings.validEvents.length; i++) {\\n            if (_eventType == settings.validEvents[i]) return settings.rewardPerEvent[i];\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Sends rewards to the specified recipients.\\n     * @param recipients The addresses of the recipients to send rewards to.\\n     * @param reward The total amount of rewards to send.\\n     */\\n    function _sendReward(address[] memory recipients, uint128 reward) internal {\\n        uint128 perReward = uint128(reward / recipients.length);\\n        uint128 totalSent;\\n        for (uint i = 0; i < recipients.length; i++) {\\n            bool valid = _enforceAndUpdateMemberLimits(recipients[i], perReward);\\n            if (valid) {\\n                settings.rewardToken.safeTransfer(recipients[i], perReward);\\n                totalSent += perReward;\\n            } else {\\n                emit NOT_MEMBER_OR_WHITELISTED(recipients[i]);\\n            }\\n        }\\n        _enforceAndUpdateGlobalLimits(totalSent);\\n    }\\n\\n    /**\\n     * @dev Enforces and updates the reward limits for the specified member.\\n     * @param member The address of the member to enforce and update limits for.\\n     * @param reward The amount of rewards to enforce and update limits for.\\n     */\\n    function _enforceAndUpdateMemberLimits(address member, uint128 reward) internal returns (bool) {\\n        //dont revert on non valid members, just dont reward them (their reward is lost)\\n        if (_addMember(member, \\\"\\\") == false) {\\n            return false;\\n        }\\n\\n        DirectPayemntsLibrary._updateMemberLimits(memberLimits[member], reward, _month());\\n\\n        if (\\n            memberLimits[member].daily > limits.maxMemberPerDay ||\\n            memberLimits[member].monthly > limits.maxMemberPerMonth\\n        ) revert OVER_MEMBER_LIMITS(member);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Enforces and updates the global reward limits.\\n     * @param reward The amount of rewards to enforce and update limits for.\\n     */\\n    function _enforceAndUpdateGlobalLimits(uint128 reward) internal {\\n        DirectPayemntsLibrary._updateGlobalLimits(globalLimits, reward, _month());\\n\\n        if (globalLimits.monthly > limits.maxTotalPerMonth) revert OVER_GLOBAL_LIMITS();\\n    }\\n\\n    /**\\n     * @dev Returns the current month.\\n     * @return month current month as a uint64 value.\\n     */\\n    function _month() internal view returns (uint64 month) {\\n        return uint64(block.timestamp / (60 * 60 * 24 * 30));\\n    }\\n\\n    /**\\n     * @dev Adds a member to the contract.\\n     * @param member The address of the member to add.\\n     * @param extraData Additional data to validate the member.\\n     */\\n\\n    function _addMember(address member, bytes memory extraData) internal returns (bool isMember) {\\n        if (hasRole(MEMBER_ROLE, member)) return true;\\n\\n        if (address(settings.uniquenessValidator) != address(0)) {\\n            address rootAddress = settings.uniquenessValidator.getWhitelistedRoot(member);\\n            if (rootAddress == address(0)) return false;\\n        }\\n\\n        // if no members validator then anyone can join the pool\\n        if (address(settings.membersValidator) != address(0)) {\\n            if (settings.membersValidator.isMemberValid(address(this), msg.sender, member, extraData) == false) {\\n                return false;\\n            }\\n        }\\n\\n        _grantRole(MEMBER_ROLE, member);\\n        return true;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        if (role == MEMBER_ROLE) {\\n            registry.addMember(account);\\n        }\\n        super._grantRole(role, account);\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        if (role == MEMBER_ROLE) {\\n            registry.removeMember(account);\\n        }\\n        super._revokeRole(role, account);\\n    }\\n\\n    function mintNFT(address _to, ProvableNFT.NFTData memory _nftData, bool withClaim) external onlyRole(MINTER_ROLE) {\\n        uint nftId = nft.mintPermissioned(_to, _nftData, true, \\\"\\\");\\n        if (withClaim) {\\n            claim(nftId, _nftData);\\n        }\\n    }\\n\\n    /**\\n     * @dev Receives an ERC721 token\\n     * @param operator The address of the operator that sent the token.\\n     * @param from The address of the sender that sent the token.\\n     * @param tokenId The ID of the token received.\\n     * @param data Additional data to trigger a claim for rewards.\\n     * @return A bytes4 value indicating success or failure.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4) {\\n        // bool triggerClaim;\\n        // if (data.length > 0) (triggerClaim) = abi.decode(data, (bool));\\n        // if (triggerClaim) {\\n        //   ProvableNFT.NFTData memory nftData = nft.getNFTData(tokenId);\\n        //   if (nftData.nftType > 0) // check the nftData is actually stored on-chain, otherwise claim will not work\\n        //   {\\n        //     claim(tokenId, nftData);\\n        //   }\\n        // }\\n        ProvableNFT.NFTData memory nftData = nft.getNFTData(tokenId);\\n        if (nftData.nftType != settings.nftType) revert UNSUPPORTED_NFT();\\n        return DirectPaymentsPool.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * @dev Sets the safety limits for the pool.\\n     * @param _limits The new safety limits.\\n     */\\n    function setPoolLimits(SafetyLimits memory _limits) public onlyRole(MANAGER_ROLE) {\\n        limits = _limits;\\n        emit PoolLimitsChanged(_limits);\\n    }\\n\\n    /**\\n     * @dev Sets the settings for the pool.\\n     * @param _settings The new pool settings.\\n     */\\n    function setPoolSettings(PoolSettings memory _settings, uint32 _managerFeeBps) public onlyRole(MANAGER_ROLE) {\\n        managerFeeBps = _managerFeeBps;\\n        if (_settings.nftType != settings.nftType) revert NFTTYPE_CHANGED();\\n        if (_settings.manager == address(0)) revert EMPTY_MANAGER();\\n\\n        _revokeRole(DEFAULT_ADMIN_ROLE, settings.manager);\\n        settings = _settings;\\n        _setupRole(DEFAULT_ADMIN_ROLE, _settings.manager);\\n        emit PoolSettingsChanged(_settings);\\n    }\\n}\\n\",\"keccak256\":\"0x6a88d3ebf22909c28dba6229e4edc0758956d9da9095e267b04ff97b14dd5e74\",\"license\":\"MIT\"},\"contracts/DirectPayments/ProvableNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { ERC721Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\\\";\\nimport { AccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport { StringsUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\n/**\\n    An NFT that can store data related to actions, the data is stored on-chain or as hash of the content that can later be proved.\\n */\\ncontract ProvableNFT is ERC721Upgradeable, AccessControlUpgradeable, UUPSUpgradeable {\\n    error BAD_DATAHASH(bytes32 dataHash, bytes32 tokenId);\\n    error NOT_MINTER();\\n    error NOT_MANAGER(uint32);\\n    error BAD_NFTTYPE();\\n\\n    bytes32 public constant MINTER_ROLE = keccak256(abi.encodePacked(\\\"MINTER\\\"));\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    event ProvableNftMinted(uint256 tokenId, address to, bytes32 nftDataHash);\\n\\n    struct EventData {\\n        uint16 subtype;\\n        uint32 timestamp;\\n        uint256 quantity;\\n        string eventUri; //extra data related to event\\n        address[] contributers;\\n        uint128 rewardOverride; //override reward defined per 1 quantity of event, pool will use this instead of its own reward if allowRewardOverride is true\\n    }\\n\\n    struct NFTData {\\n        uint32 nftType; //should be non zero\\n        uint16 version;\\n        string nftUri; //extra data related to nft\\n        EventData[] events;\\n    }\\n\\n    mapping(uint256 => NFTData) internal nftDatas;\\n\\n    function initialize(string memory _name, string memory _symbol) external initializer {\\n        __ERC721_init(_name, _symbol);\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n\\n    function _authorizeUpgrade(address /*newimpl*/) internal virtual override {\\n        _onlyManager(0);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(AccessControlUpgradeable, ERC721Upgradeable) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    function _onlyManager(uint32 nftType) internal view {\\n        if (\\n            ((nftType > 0 && hasRole(getManagerRole(nftType), msg.sender)) ||\\n                hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) == false\\n        ) {\\n            revert NOT_MANAGER(nftType);\\n        }\\n    }\\n\\n    /**\\n     * @dev Mint a new NFT with the given URI and data hash.\\n     *\\n     * Requirements:\\n     * - The caller must have the `Manager` role.\\n     *\\n     * Emits a {Transfer} event and a {URI} event.\\n     *\\n     * @param _to The address that will receive the minted NFT.\\n     * @param _uri The URI for the NFT's metadata.\\n     * @param _nftDataHash The hash of the NFT's data.\\n     * @return tokenId ID of the newly minted NFT.\\n     */\\n    function mint(address _to, string memory _uri, bytes32 _nftDataHash) public returns (uint256 tokenId) {\\n        _onlyManager(0);\\n        NFTData memory nftData;\\n\\n        return _mint(_to, _uri, _nftDataHash, nftData, \\\"\\\"); //send false in calldata, assuming default receiver is a directpaymentspool. without nft data on chain it will fail.\\n    }\\n\\n    function _mint(\\n        address _to,\\n        string memory _uri,\\n        bytes32 _nftDataHash,\\n        NFTData memory /*_nftData*/,\\n        bytes memory _callData\\n    ) internal returns (uint256 tokenId) {\\n        tokenId = uint256(_nftDataHash);\\n        nftDatas[tokenId].nftUri = _uri;\\n        _safeMint(_to, tokenId, _callData);\\n        emit ProvableNftMinted(tokenId, _to, _nftDataHash);\\n    }\\n\\n    /**\\n     * @dev Mint a new permissioned NFT with the given data.\\n     *\\n     * This function is only accessible to users with the `Manager` role for the given NFT type.\\n     *\\n     * Stores nftData in contract storage if `_withStore` is true.\\n     *\\n     * @param _to The address that will receive the minted NFT.\\n     * @param _nftData The data for the NFT.\\n     * @param _withStore Whether or not to store the NFT data in the contract.\\n     * @param _callData call data to pass to erc721receiver\\n     * @return tokenId ID of the newly minted NFT.\\n     */\\n    function mintPermissioned(\\n        address _to,\\n        NFTData memory _nftData,\\n        bool _withStore,\\n        bytes memory _callData\\n    ) external returns (uint256 tokenId) {\\n        _onlyManager(_nftData.nftType);\\n        if (_nftData.nftType == 0) revert BAD_NFTTYPE();\\n\\n        bytes32 dataHash = keccak256(abi.encode(_nftData));\\n        tokenId = uint256(dataHash);\\n        if (_withStore) {\\n            NFTData storage store = nftDatas[tokenId];\\n            store.nftUri = _nftData.nftUri;\\n            store.nftType = _nftData.nftType;\\n            store.version = _nftData.version;\\n            for (uint256 i = 0; i < _nftData.events.length; i++) {\\n                store.events.push(_nftData.events[i]);\\n            }\\n        }\\n        _mint(_to, _nftData.nftUri, dataHash, _nftData, _callData);\\n    }\\n\\n    function proveNFTData(uint256 _tokenId, NFTData memory _nftData) public view returns (NFTData memory data) {\\n        _requireMinted(_tokenId);\\n        if (keccak256(abi.encode(_nftData)) != bytes32(_tokenId))\\n            revert BAD_DATAHASH(keccak256(abi.encode(_nftData)), bytes32(_tokenId));\\n\\n        return _nftData;\\n    }\\n\\n    function getNFTData(uint256 _tokenId) external view returns (NFTData memory) {\\n        return nftDatas[_tokenId];\\n    }\\n\\n    function getNFTEvent(uint256 _tokenId, uint256 _index) external view returns (EventData memory) {\\n        return nftDatas[_tokenId].events[_index];\\n    }\\n\\n    function getNFTEvents(uint256 _tokenId) external view returns (EventData[] memory) {\\n        return nftDatas[_tokenId].events;\\n    }\\n\\n    function addManager(address _manager, uint32 _nftType) external {\\n        grantRole(getManagerRole(_nftType), _manager);\\n    }\\n\\n    function getManagerRole(uint32 _nftType) public pure returns (bytes32 roleHash) {\\n        return keccak256(abi.encodePacked(\\\"MANAGER_\\\", _nftType));\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return\\n            bytes(baseURI).length > 0\\n                ? string(abi.encodePacked(baseURI, nftDatas[tokenId].nftUri))\\n                : nftDatas[tokenId].nftUri;\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return \\\"\\\";\\n    }\\n}\\n\",\"keccak256\":\"0x1adffa1a765ea3832373474aa09350b5fc7fb4e8216e53b9da52f04ca15da658\",\"license\":\"MIT\"},\"contracts/GoodCollective/GoodCollectiveSuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { SuperAppBaseFlow } from \\\"./SuperAppBaseFlow.sol\\\";\\nimport { ISuperfluid, ISuperToken, SuperAppDefinitions, ISuperApp } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport { ISuperGoodDollar } from \\\"@gooddollar/goodprotocol/contracts/token/superfluid/ISuperGoodDollar.sol\\\";\\nimport { SuperTokenV1Library } from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\\\";\\nimport { CFAv1Library, IConstantFlowAgreementV1 } from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\\\";\\n\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\nimport \\\"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\\\";\\n\\nimport \\\"../DirectPayments/DirectPaymentsFactory.sol\\\";\\nimport \\\"../utils/HelperLibrary.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\nabstract contract GoodCollectiveSuperApp is SuperAppBaseFlow {\\n    int96 public constant MIN_FLOW_RATE = 386e9;\\n\\n    using SuperTokenV1Library for ISuperToken;\\n    using CFAv1Library for CFAv1Library.InitData;\\n\\n    error ZERO_ADDRESS();\\n    error ZERO_AMOUNT();\\n    error UNSUPPORTED_TOKEN();\\n    error ONLY_HOST_OR_SENDER(address);\\n    error FEE_FLOW_FAILED(int96 curFeeRate, int96 newFeeRate);\\n    error MIN_FLOWRATE(int96 flowRate);\\n\\n    /**\\n     * @dev Emitted when a supporter's contribution or flow rate is updated\\n     * @param supporter The address of the supporter\\n     * @param previousContribution The previous total contribution amount\\n     * @param contribution The new total contribution amount\\n     * @param previousFlowRate The previous flow rate if isFlowUpdate otherwise 0\\n     * @param flowRate The new flow rate\\n     * @param isFlowUpdate True if the update was a flow rate update, false if it was a single contribution update\\n     */\\n    event SupporterUpdated(\\n        address indexed supporter,\\n        uint256 previousContribution,\\n        uint256 contribution,\\n        int96 previousFlowRate,\\n        int96 flowRate,\\n        bool isFlowUpdate\\n    );\\n\\n    //TODO:\\n    // ask about \\\"receiver\\\" can it be different then app?\\n\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    IV3SwapRouter public immutable swapRouter;\\n\\n    struct SupporterData {\\n        uint256 contribution;\\n        int96 flowRate;\\n        uint128 lastUpdated;\\n    }\\n\\n    ISuperToken public superToken;\\n\\n    mapping(address => SupporterData) public supporters;\\n\\n    //initialize cfaV1 variable\\n    CFAv1Library.InitData public cfaV1;\\n\\n    IGoodCollectiveSuperApp.Stats public stats;\\n\\n    uint256[45] private _reserved;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(ISuperfluid _host, IV3SwapRouter _swapRouter) SuperAppBaseFlow(_host) {\\n        if (address(_host) == address(0)) revert ZERO_ADDRESS();\\n        swapRouter = _swapRouter;\\n    }\\n\\n    function getRegistry() public view virtual returns (IRegistry);\\n\\n    function getManagerFee() public view virtual returns (address admin, uint32 feeBps);\\n\\n    /**\\n     * @dev Sets the address of the super token and registers the app with the host\\n     * @param _superToken The address of the super token contract\\n     */\\n    function setSuperToken(ISuperToken _superToken) internal {\\n        if (address(_superToken) == address(0)) revert ZERO_ADDRESS();\\n\\n        // Set the super token address\\n        superToken = _superToken;\\n\\n        // // Define the callback definitions for the app\\n        // uint256 callBackDefinitions = SuperAppDefinitions.APP_LEVEL_FINAL;\\n\\n        // // Register the app with the host\\n        // host.registerApp(callBackDefinitions);\\n\\n        //initialize InitData struct, and set equal to cfaV1\\n        cfaV1 = CFAv1Library.InitData(\\n            host,\\n            IConstantFlowAgreementV1(\\n                address(host.getAgreementClass(keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\")))\\n            )\\n        );\\n    }\\n\\n    function isAcceptedSuperToken(ISuperToken _superToken) public view override returns (bool) {\\n        return address(superToken) == address(_superToken);\\n    }\\n\\n    function getRealtimeContribution(address _user) public view returns (uint256) {\\n        SupporterData memory supporter = supporters[_user];\\n        if (supporter.flowRate == 0) return supporter.contribution;\\n        return supporter.contribution + uint96(supporter.flowRate) * (block.timestamp - supporter.lastUpdated);\\n    }\\n\\n    function getRealtimeStats()\\n        public\\n        view\\n        returns (\\n            uint256 netIncome,\\n            uint256 totalFees,\\n            uint256 protocolFees,\\n            uint256 managerFees,\\n            int96 incomeFlowRate,\\n            int96 feeRate,\\n            int96 managerFeeRate\\n        )\\n    {\\n        return HelperLibrary.getRealtimeStats(stats, superToken);\\n    }\\n\\n    /**\\n     * @dev This function is called when a token transfer occurs\\n     * @param _sender The address of the sender\\n     * @param _amount The amount of tokens being transferred\\n     * @return bool Returns true to indicate that the transfer was successful\\n     */\\n    function onTokenTransfer(address _sender, uint256 _amount, bytes calldata /*_data*/) external returns (bool) {\\n        if (msg.sender != address(superToken)) revert UNSUPPORTED_TOKEN();\\n        if (_amount == 0) revert ZERO_AMOUNT();\\n\\n        // Update the contribution amount for the sender in the supporters mapping\\n        _updateSupporter(_sender, int256(_amount), 0, \\\"\\\");\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev allow single contribution. user needs to approve tokens first. can be used in superfluid batch actions.\\n     * @param _sender The address of the sender who is contributing tokens.\\n     * @param _amount The amount of tokens being contributed.\\n     * @param _ctx The context of the transaction for superfluid in case this was used in superfluid batch. otherwise can be empty.\\n     * @return Returns the context of the transaction.\\n     */\\n    function support(\\n        address _sender,\\n        uint256 _amount,\\n        bytes memory _ctx\\n    ) external onlyHostOrSender(_sender) returns (bytes memory) {\\n        if (_amount == 0) revert ZERO_AMOUNT();\\n\\n        // Transfer the tokens from the sender to this contract\\n        TransferHelper.safeTransferFrom(address(superToken), _sender, address(this), _amount);\\n\\n        // Update the contribution amount for the sender in the supporters mapping\\n        _updateSupporter(_sender, int256(_amount), 0, \\\"\\\"); //we pass empty ctx since this is not a flow but a single donation\\n\\n        return _ctx;\\n    }\\n\\n    /**\\n     * @dev allow single contribution. user needs to approve tokens first. can be used in superfluid batch actions.\\n     * @param _sender The address of the sender who is contributing tokens.\\n     * @param _customData The SwapData struct containing information about the swap\\n     * @param _ctx The context of the transaction for superfluid in case this was used in superfluid batch. otherwise can be empty.\\n     * @return Returns the context of the transaction.\\n     */\\n    function supportWithSwap(\\n        address _sender,\\n        HelperLibrary.SwapData memory _customData,\\n        bytes memory _ctx\\n    ) external onlyHostOrSender(_sender) returns (bytes memory) {\\n        uint256 balance = superToken.balanceOf(address(this));\\n        HelperLibrary.handleSwap(swapRouter, _customData, address(superToken), _sender, address(this));\\n        uint256 amountReceived = superToken.balanceOf(address(this)) - balance;\\n        if (amountReceived == 0) revert ZERO_AMOUNT();\\n\\n        // Update the contribution amount for the sender in the supporters mapping\\n        _updateSupporter(_sender, int256(amountReceived), 0, \\\"\\\"); //we pass empty ctx since this is not a flow but a single donation\\n        return _ctx;\\n    }\\n\\n    /**\\n     * @dev Handles the swap of tokens using the SwapData struct\\n     * @param _customData The SwapData struct containing information about the swap\\n     * @param _sender The address of the sender of the transaction\\n     * @param _ctx The context of the transaction for superfluid\\n     * @return Returns the context of the transaction\\n     */\\n    function handleSwap(\\n        HelperLibrary.SwapData memory _customData,\\n        address _sender,\\n        bytes memory _ctx\\n    ) external onlyHostOrSender(_sender) returns (bytes memory) {\\n        HelperLibrary.handleSwap(swapRouter, _customData, address(superToken), _sender);\\n\\n        // Return the context of the transaction\\n        return _ctx;\\n    }\\n\\n    /**\\n     * @dev Called when a new flow is created\\n     * @param _sender The address of the sender of the transaction\\n     * @param _ctx The context of the transaction\\n     * @return Returns the new context of the transaction\\n     */\\n    function onFlowCreated(\\n        ISuperToken /*superToken*/,\\n        address _sender,\\n        bytes calldata _ctx\\n    ) internal virtual override returns (bytes memory /*newCtx*/) {\\n        // Update the supporter's information\\n        return _updateSupporter(_sender, 0, 0, _ctx);\\n    }\\n\\n    /**\\n     * @dev Called when an existing flow is updated\\n     * @param _sender The address of the sender of the transaction\\n     * @param _previousFlowRate The previous flow rate of the stream\\n     * @param _lastUpdated The timestamp of the last update to the stream\\n     * @param _ctx The context of the transaction\\n     * @return Returns the new context of the transaction\\n     */\\n    function onFlowUpdated(\\n        ISuperToken /*superToken*/,\\n        address _sender,\\n        int96 _previousFlowRate,\\n        uint256 _lastUpdated,\\n        bytes calldata _ctx\\n    ) internal virtual override returns (bytes memory /*newCtx*/) {\\n        // Update the supporter's information\\n        return _updateSupporter(_sender, _previousFlowRate, _lastUpdated, _ctx);\\n    }\\n\\n    /**\\n     * @dev Called when an existing flow is deleted\\n     * @param _sender The address of the sender of the transaction\\n     * @param _previousFlowRate The previous flow rate of the stream\\n     * @param _lastUpdated The timestamp of the last update to the stream\\n     * @param _ctx The context of the transaction\\n     * @return Returns the new context of the transaction\\n     */\\n    function onFlowDeleted(\\n        ISuperToken /*superToken*/,\\n        address _sender,\\n        address /*receiver*/,\\n        int96 _previousFlowRate,\\n        uint256 _lastUpdated,\\n        bytes calldata _ctx\\n    ) internal virtual override returns (bytes memory /*newCtx*/) {\\n        // Update the supporter's information\\n\\n        return _updateSupporter(_sender, _previousFlowRate, _lastUpdated, _ctx);\\n    }\\n\\n    /**\\n     * @dev Updates the information for a supporter\\n     * @param _supporter The address of the supporter\\n     * @param _previousFlowRateOrAmount The previous flow rate of the stream or single donation amount\\n     * @param _lastUpdated The timestamp of the last update to the stream\\n     * @param _ctx flow context\\n     */\\n    function _updateSupporter(\\n        address _supporter,\\n        int256 _previousFlowRateOrAmount,\\n        uint256 _lastUpdated,\\n        bytes memory _ctx\\n    ) internal returns (bytes memory newCtx) {\\n        newCtx = _ctx;\\n        bool _isFlow = _ctx.length > 0;\\n        (address feeRecipient, uint32 feeBps) = getManagerFee();\\n        HelperLibrary.updateStats(\\n            stats,\\n            superToken,\\n            getRegistry(),\\n            feeBps,\\n            _isFlow ? 0 : uint256(_previousFlowRateOrAmount)\\n        );\\n        // Get the current flow rate for the supporter\\n        int96 flowRate = superToken.getFlowRate(_supporter, address(this));\\n        uint256 prevContribution = supporters[_supporter].contribution;\\n\\n        if (_isFlow) {\\n            //enforce minimal flow rate\\n            if (flowRate > 0 && flowRate < MIN_FLOW_RATE) revert MIN_FLOWRATE(flowRate);\\n            // Update the supporter's information\\n            supporters[_supporter].lastUpdated = uint128(block.timestamp);\\n            supporters[_supporter].flowRate = flowRate;\\n            supporters[_supporter].contribution +=\\n                uint256(_previousFlowRateOrAmount) *\\n                (block.timestamp - _lastUpdated);\\n\\n            // address feeRecipient;\\n            // uint32 feeBps;\\n            if (address(getRegistry()) != address(0)) {\\n                feeRecipient = getRegistry().feeRecipient();\\n                feeBps = getRegistry().feeBps();\\n                // console.log(\\\"taking fees %s %s\\\", feeRecipient, feeBps);\\n\\n                newCtx = HelperLibrary.takeFeeFlow(\\n                    cfaV1,\\n                    superToken,\\n                    stats.lastFeeRecipient,\\n                    feeRecipient,\\n                    feeBps,\\n                    flowRate - int96(_previousFlowRateOrAmount), // we use diff, because manager takes fee from many streams not just this one\\n                    newCtx\\n                );\\n                stats.lastFeeRecipient = feeRecipient;\\n            }\\n            // console.log(\\\"protocol fee stream ok\\\");\\n            (feeRecipient, feeBps) = getManagerFee();\\n\\n            newCtx = HelperLibrary.takeFeeFlow(\\n                cfaV1,\\n                superToken,\\n                stats.lastManagerFeeRecipient,\\n                feeRecipient,\\n                feeBps,\\n                flowRate - int96(_previousFlowRateOrAmount), // we use diff, because manager takes fee from many streams not just this one\\n                newCtx\\n            );\\n\\n            stats.lastManagerFeeRecipient = feeRecipient;\\n            // console.log(\\\"admin fee stream ok\\\");\\n            // we update the last rate after we do all changes to our own flows\\n            stats.lastIncomeRate = superToken.getNetFlowRate(address(this));\\n        } else {\\n            if (address(getRegistry()) != address(0)) {\\n                feeRecipient = getRegistry().feeRecipient();\\n                feeBps = getRegistry().feeBps();\\n                _takeFeeSingle(feeRecipient, feeBps, uint256(_previousFlowRateOrAmount));\\n            }\\n            (feeRecipient, feeBps) = getManagerFee();\\n            _takeFeeSingle(feeRecipient, feeBps, uint256(_previousFlowRateOrAmount));\\n\\n            supporters[_supporter].contribution += uint256(_previousFlowRateOrAmount);\\n        }\\n\\n        emit SupporterUpdated(\\n            _supporter,\\n            prevContribution,\\n            supporters[_supporter].contribution,\\n            _isFlow ? int96(int256(_previousFlowRateOrAmount)) : int96(0),\\n            flowRate,\\n            _isFlow\\n        );\\n    }\\n\\n    function _takeFeeSingle(address recipient, uint32 feeBps, uint256 _amount) internal {\\n        if (recipient == address(0)) return;\\n\\n        uint256 fee = (_amount * feeBps) / 10000;\\n        TransferHelper.safeTransfer(address(superToken), recipient, fee);\\n    }\\n\\n    /**\\n     * for methods that can be called via superfluid batch or directly\\n     */\\n    modifier onlyHostOrSender(address _sender) {\\n        if (msg.sender != _sender && msg.sender != address(host)) revert ONLY_HOST_OR_SENDER(msg.sender);\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x9f40c34da7e47afb4a3cfd55768afc7dc2952c07f5adcd3a299f37bfb47e0de1\",\"license\":\"MIT\"},\"contracts/GoodCollective/IGoodCollectiveSuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IRegistry {\\n    function feeRecipient() external view returns (address);\\n\\n    function feeBps() external view returns (uint32);\\n}\\n\\ninterface IGoodCollectiveSuperApp {\\n    struct Stats {\\n        uint256 netIncome; //without fees\\n        uint256 totalFees;\\n        uint256 lastUpdate;\\n        address lastFeeRecipient;\\n        int96 lastIncomeRate;\\n        address lastManagerFeeRecipient;\\n        uint256 protocolFees;\\n        uint256 managerFees;\\n        // adding fields MUST update GoodCollectiveSuperApp storage layout\\n    }\\n\\n    function getAdminFee() external view returns (address admin, uint32 feeBps);\\n}\\n\",\"keccak256\":\"0x6fc02e758a28ed3f4ad86dc8ec84ee402d987da889fc87da5a63ecfc4b239dd2\",\"license\":\"MIT\"},\"contracts/GoodCollective/SuperAppBaseFlow.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >=0.8.0;\\n\\nimport { ISuperfluid, ISuperToken, ISuperApp, SuperAppDefinitions } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport { SuperTokenV1Library } from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\ninterface IRegisterSuperapp {\\n    function registerApp(address app, uint256 configWord) external;\\n}\\n\\nabstract contract SuperAppBaseFlow is ISuperApp {\\n    using SuperTokenV1Library for ISuperToken;\\n\\n    bytes32 public constant CFAV1_TYPE = keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\");\\n\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    ISuperfluid public immutable host;\\n\\n    /// @dev Thrown when the callback caller is not the host.\\n    error UnauthorizedHost();\\n\\n    /// @dev Thrown if a required callback wasn't implemented (overridden by the SuperApp)\\n    error NotImplemented();\\n\\n    /// @dev Thrown when SuperTokens not accepted by the SuperApp are streamed to it\\n    error NotAcceptedSuperToken();\\n\\n    /**\\n     * @dev Initializes the contract by setting the expected Superfluid Host.\\n     *      and register which callbacks the Host can engage when appropriate.\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(ISuperfluid host_) {\\n        host = host_;\\n    }\\n\\n    /**\\n     * @dev Optional (positive) filter for accepting only specific SuperTokens.\\n     *      The default implementation accepts all SuperTokens.\\n     *      Can be overridden by the SuperApp in order to apply arbitrary filters.\\n     */\\n    function isAcceptedSuperToken(ISuperToken /*superToken*/) public view virtual returns (bool);\\n\\n    // ---------------------------------------------------------------------------------------------\\n    // CFA specific convenience callbacks\\n    // to be overridden and implemented by inheriting SuperApps\\n\\n    /// @dev override if the SuperApp shall have custom logic invoked when a new flow\\n    ///      to it is created.\\n    function onFlowCreated(\\n        ISuperToken /*superToken*/,\\n        address /*sender*/,\\n        bytes calldata ctx\\n    ) internal virtual returns (bytes memory /*newCtx*/) {\\n        return ctx;\\n    }\\n\\n    /// @dev override if the SuperApp shall have custom logic invoked when an existing flow\\n    ///      to it is updated (flowrate change).\\n    function onFlowUpdated(\\n        ISuperToken /*superToken*/,\\n        address /*sender*/,\\n        int96 /*previousFlowRate*/,\\n        uint256 /*lastUpdated*/,\\n        bytes calldata ctx\\n    ) internal virtual returns (bytes memory /*newCtx*/) {\\n        return ctx;\\n    }\\n\\n    /// @dev override if the SuperApp shall have custom logic invoked when an existing flow\\n    ///      to it is deleted (flowrate set to 0).\\n    ///      Unlike the other callbacks, this method is NOT allowed to revert.\\n    ///      Failing to satisfy that requirement leads to jailing (defunct SuperApp).\\n    function onFlowDeleted(\\n        ISuperToken /*superToken*/,\\n        address /*sender*/,\\n        address /*receiver*/,\\n        int96 /*previousFlowRate*/,\\n        uint256 /*lastUpdated*/,\\n        bytes calldata ctx\\n    ) internal virtual returns (bytes memory /*newCtx*/) {\\n        return ctx;\\n    }\\n\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    ) external view returns (bytes memory /*beforeData*/) {\\n        if (msg.sender != address(host)) revert UnauthorizedHost();\\n        if (!isAcceptedAgreement(agreementClass)) return \\\"0x\\\";\\n        if (!isAcceptedSuperToken(superToken)) revert NotAcceptedSuperToken();\\n        return \\\"0x\\\";\\n    }\\n\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata agreementData,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata ctx\\n    ) external returns (bytes memory newCtx) {\\n        (address sender, ) = abi.decode(agreementData, (address, address));\\n\\n        return\\n            onFlowCreated(\\n                superToken,\\n                sender,\\n                ctx // userData can be acquired with `host.decodeCtx(ctx).userData`\\n            );\\n    }\\n\\n    // UPDATED callbacks\\n\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 /*agreementId*/,\\n        bytes calldata agreementData,\\n        bytes calldata /*ctx*/\\n    ) external view returns (bytes memory /*beforeData*/) {\\n        if (msg.sender != address(host)) revert UnauthorizedHost();\\n        if (!isAcceptedAgreement(agreementClass)) return \\\"0x\\\";\\n        if (!isAcceptedSuperToken(superToken)) revert NotAcceptedSuperToken();\\n\\n        (address sender, ) = abi.decode(agreementData, (address, address));\\n        (uint256 lastUpdated, int96 flowRate, , ) = superToken.getFlowInfo(sender, address(this));\\n\\n        return abi.encode(flowRate, lastUpdated);\\n    }\\n\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    ) external returns (bytes memory newCtx) {\\n        (address sender, ) = abi.decode(agreementData, (address, address));\\n        (int96 previousFlowRate, uint256 lastUpdated) = abi.decode(cbdata, (int96, uint256));\\n\\n        return\\n            onFlowUpdated(\\n                superToken,\\n                sender,\\n                previousFlowRate,\\n                lastUpdated,\\n                ctx // userData can be acquired with `host.decodeCtx(ctx).userData`\\n            );\\n    }\\n\\n    // DELETED callbacks\\n\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 /*agreementId*/,\\n        bytes calldata agreementData,\\n        bytes calldata /*ctx*/\\n    ) external view returns (bytes memory /*beforeData*/) {\\n        // we're not allowed to revert in this callback, thus just return empty beforeData on failing checks\\n        if (msg.sender != address(host) || !isAcceptedAgreement(agreementClass) || !isAcceptedSuperToken(superToken)) {\\n            return \\\"0x\\\";\\n        }\\n\\n        (address sender, address receiver) = abi.decode(agreementData, (address, address));\\n        (uint256 lastUpdated, int96 flowRate, , ) = superToken.getFlowInfo(sender, receiver);\\n\\n        return abi.encode(lastUpdated, flowRate);\\n    }\\n\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 /*agreementId*/,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    ) external returns (bytes memory newCtx) {\\n        // we're not allowed to revert in this callback, thus just return ctx on failing checks\\n        if (msg.sender != address(host) || !isAcceptedAgreement(agreementClass) || !isAcceptedSuperToken(superToken)) {\\n            return ctx;\\n        }\\n\\n        (address sender, address receiver) = abi.decode(agreementData, (address, address));\\n        (uint256 lastUpdated, int96 previousFlowRate) = abi.decode(cbdata, (uint256, int96));\\n\\n        return onFlowDeleted(superToken, sender, receiver, previousFlowRate, lastUpdated, ctx);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------\\n    // HELPERS\\n\\n    /**\\n     * @dev Expect Super Agreement involved in callback to be an accepted one\\n     *      This function can be overridden with custom logic and to revert if desired\\n     *      Current implementation expects ConstantFlowAgreement\\n     */\\n    function isAcceptedAgreement(address agreementClass) internal view virtual returns (bool) {\\n        return agreementClass == address(host.getAgreementClass(CFAV1_TYPE));\\n    }\\n}\\n\",\"keccak256\":\"0x570c5b8368cfeae3c1a05a04676c9fe7904e50c5e8d7b2a7bf9100437e0eac48\",\"license\":\"AGPLv3\"},\"contracts/Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\ninterface IMembersValidator {\\n    function isMemberValid(\\n        address pool,\\n        address operator,\\n        address member,\\n        bytes memory extraData\\n    ) external returns (bool);\\n}\\n\\ninterface IIdentityV2 {\\n    function getWhitelistedRoot(address member) external view returns (address);\\n}\\n\\nstruct PoolSettings {\\n    address manager;\\n    IMembersValidator membersValidator;\\n    IIdentityV2 uniquenessValidator;\\n    IERC20Upgradeable rewardToken;\\n}\\n\",\"keccak256\":\"0x6a99c68dd3969552aa4a26db5739819329316f227b0e9fd7f06c936f7e1968d0\",\"license\":\"MIT\"},\"contracts/UBI/UBIPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8;\\nimport { AccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport { IERC721Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { IERC721ReceiverUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\\\";\\n\\nimport \\\"../GoodCollective/GoodCollectiveSuperApp.sol\\\";\\nimport \\\"./UBIPoolFactory.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\n\\ncontract UBIPool is AccessControlUpgradeable, GoodCollectiveSuperApp, UUPSUpgradeable {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    error CLAIMFOR_DISABLED();\\n    error NOT_MEMBER(address claimer);\\n    error NOT_MANAGER(address manager);\\n    error NOT_WHITELISTED(address whitelistedRoot);\\n    error ALREADY_CLAIMED(address whitelistedRoot);\\n    error INVALID_0_VALUE();\\n    error EMPTY_MANAGER();\\n    error MAX_MEMBERS_REACHED();\\n    error MAX_PERIOD_CLAIMERS_REACHED(uint256 claimers);\\n\\n    bytes32 public constant MANAGER_ROLE = keccak256(\\\"MANAGER_ROLE\\\");\\n    bytes32 public constant MEMBER_ROLE = keccak256(\\\"MEMBER_ROLE\\\");\\n\\n    event PoolSettingsChanged(PoolSettings settings);\\n    event UBISettingsChanged(UBISettings settings);\\n    // Emits when daily ubi is calculated\\n    event UBICalculated(\\n        uint256 day,\\n        uint256 dailyUbi,\\n        uint256 blockNumber,\\n        uint256 periodClaimers,\\n        uint256 periodDistributed\\n    );\\n\\n    //Emits whenever a new multi day cycle starts\\n    event UBICycleCalculated(uint256 day, uint256 pool, uint256 cycleLength, uint256 dailyUBIPool);\\n\\n    event UBIClaimed(address indexed whitelistedRoot, address indexed claimer, uint256 amount);\\n\\n    struct UBISettings {\\n        //number of days of each UBI pool cycle\\n        uint32 cycleLengthDays;\\n        //how often can someone claim their UBI\\n        uint32 claimPeriodDays;\\n        //minimum amount of users to divide the pool for, renamed from defaultDailyUbi\\n        uint32 minActiveUsers;\\n        // can you trigger claim for someone else\\n        bool claimForEnabled;\\n        // max daily claim amount\\n        uint maxClaimAmount;\\n        // max number of members in a pool\\n        uint32 maxMembers;\\n        bool onlyMembers;\\n    }\\n\\n    struct PoolStatus {\\n        //current day of distribution\\n        uint256 currentDay;\\n        // Result of distribution formula\\n        // calculated each day\\n        uint256 dailyUbi;\\n        //the amount of G$ UBI pool for each day in the cycle to be divided by active users\\n        uint256 dailyCyclePool;\\n        //timestamp of current cycle start\\n        uint256 startOfCycle;\\n        //should be 0 for starters so distributionFormula detects new cycle on first day claim\\n        uint256 currentCycleLength;\\n        uint256 periodClaimers;\\n        uint256 periodDistributed;\\n        mapping(address => uint256) lastClaimed;\\n        uint32 membersCount;\\n    }\\n\\n    struct ExtendedSettings {\\n        // max number of members that can claim in a day maxPeriodClaimers <= maxMembers\\n        uint32 maxPeriodClaimers;\\n        // min daily claim amount, daily amount will be 0 if <minClaimAmount\\n        uint minClaimAmount;\\n        // fees taken from income to the pool manager\\n        uint32 managerFeeBps;\\n    }\\n\\n    PoolSettings public settings;\\n    UBISettings public ubiSettings;\\n    PoolStatus public status;\\n\\n    UBIPoolFactory public registry;\\n    ExtendedSettings public extendedSettings;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(ISuperfluid _host, IV3SwapRouter _swapRouter) GoodCollectiveSuperApp(_host, _swapRouter) {}\\n\\n    /**\\n     * @dev Authorizes an upgrade for the implementation contract.\\n     * @param impl The address of the new implementation contract.\\n     */\\n    function _authorizeUpgrade(address impl) internal virtual override onlyRole(DEFAULT_ADMIN_ROLE) {}\\n\\n    function getRegistry() public view override returns (IRegistry) {\\n        return IRegistry(address(registry));\\n    }\\n\\n    function getManagerFee() public view override returns (address feeRecipient, uint32 feeBps) {\\n        return (settings.manager, extendedSettings.managerFeeBps);\\n    }\\n\\n    /**\\n     * @dev Initializes the contract with the given settings and limits.\\n     * @param _settings The PoolSettings struct containing pool settings.\\n     * @param _ubiSettings The UBISettings struct containing safety limits.\\n     */\\n    function initialize(\\n        PoolSettings memory _settings,\\n        UBISettings memory _ubiSettings,\\n        ExtendedSettings memory _extendedSettings,\\n        UBIPoolFactory _registry\\n    ) external initializer {\\n        registry = _registry;\\n        settings = _settings;\\n        ubiSettings = _ubiSettings;\\n        extendedSettings = _extendedSettings;\\n        _verifyPoolSettings(_settings);\\n        _verifyUBISettings(_ubiSettings);\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // when using factory this gives factory role which then set role to the real msg.sender\\n        _setupRole(MANAGER_ROLE, _settings.manager);\\n        setSuperToken(ISuperToken(address(settings.rewardToken)));\\n    }\\n\\n    function upgradeToLatest(bytes memory data) external payable virtual {\\n        address impl = address(UBIPoolFactory(address(registry)).impl());\\n        _authorizeUpgrade(impl);\\n        _upgradeToAndCallUUPS(impl, data, false);\\n    }\\n\\n    function getCurrentDay() public view returns (uint256) {\\n        return (block.timestamp - 12 hours) / (1 days); //make day start at 12:00pm\\n    }\\n\\n    /**\\n     * @dev The claim calculation formula. Divide the daily pool with\\n     * the sum of the active users.\\n     * the daily balance is determined by dividing current pool by the cycle length\\n     * @return The amount of GoodDollar the user can claim\\n     */\\n    function distributionFormula() public returns (uint256) {\\n        // once every claim cycle\\n        uint256 currentDay = getCurrentDay();\\n        if (currentDay >= status.currentDay + ubiSettings.claimPeriodDays) {\\n            (uint256 nextDailyPool, uint256 nextDailyUbi, bool newCycle) = _calcNextDailyUBI();\\n            if (newCycle) {\\n                uint256 currentBalance = settings.rewardToken.balanceOf(address(this));\\n                status.dailyCyclePool = nextDailyPool;\\n                status.currentCycleLength = ubiSettings.cycleLengthDays;\\n                status.startOfCycle = currentDay;\\n                emit UBICycleCalculated(currentDay, currentBalance, ubiSettings.cycleLengthDays, nextDailyPool);\\n            }\\n\\n            status.currentDay = currentDay;\\n            status.dailyUbi = nextDailyUbi;\\n            if (status.dailyUbi <= extendedSettings.minClaimAmount) status.dailyUbi = 0;\\n\\n            emit UBICalculated(\\n                currentDay,\\n                status.dailyUbi,\\n                block.number,\\n                status.periodClaimers,\\n                status.periodDistributed\\n            );\\n            status.periodClaimers = 0;\\n            status.periodDistributed = 0;\\n        }\\n\\n        return status.dailyUbi;\\n    }\\n\\n    function _calcNextDailyUBI() internal view returns (uint256 nextPeriodPool, uint256 nextDailyUbi, bool newCycle) {\\n        uint256 currentBalance = settings.rewardToken.balanceOf(address(this));\\n        //start early cycle if we can increase the daily UBI pool\\n        uint256 nextDailyPool = currentBalance / ubiSettings.cycleLengthDays;\\n        bool shouldStartEarlyCycle = nextDailyPool > (status.dailyCyclePool * 105) / 100 ||\\n            (currentDayInCycle() <= status.currentCycleLength &&\\n                currentBalance < (status.dailyCyclePool * (status.currentCycleLength - currentDayInCycle())));\\n\\n        nextPeriodPool = status.dailyCyclePool;\\n        nextDailyUbi;\\n        if (\\n            (currentDayInCycle() + 1) >= status.currentCycleLength || shouldStartEarlyCycle\\n        ) //start of cycle or first time\\n        {\\n            nextPeriodPool = currentBalance / ubiSettings.cycleLengthDays;\\n            newCycle = true;\\n        }\\n\\n        nextDailyUbi = min(\\n            ubiSettings.maxClaimAmount,\\n            nextPeriodPool / max((status.periodClaimers * 10500) / 10000, ubiSettings.minActiveUsers)\\n        );\\n\\n        if (nextDailyUbi < extendedSettings.minClaimAmount) nextDailyUbi = 0;\\n    }\\n\\n    /**\\n     * @dev returns the day count since start of current cycle\\n     */\\n    function currentDayInCycle() public view returns (uint256) {\\n        return getCurrentDay() - status.startOfCycle;\\n    }\\n\\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Claims UBI\\n     */\\n    function claim() external {\\n        _claim(msg.sender, true);\\n    }\\n\\n    function claimFor(address claimer, bool sendToWhitelistedRoot) external {\\n        if (!ubiSettings.claimForEnabled) revert CLAIMFOR_DISABLED();\\n\\n        _claim(claimer, sendToWhitelistedRoot);\\n    }\\n\\n    /**\\n     * @dev Claims UBI\\n     * @param claimer the address of the claimer.\\n     */\\n\\n    function _claim(address claimer, bool sendToWhitelistedRoot) internal {\\n        address whitelistedRoot = IIdentityV2(settings.uniquenessValidator).getWhitelistedRoot(claimer);\\n        if (whitelistedRoot == address(0)) revert NOT_WHITELISTED(claimer);\\n\\n        // if open for anyone but has limits, we add the first claimers as members to handle the max claimers\\n        if ((ubiSettings.maxMembers > 0 && ubiSettings.onlyMembers == false)) _grantRole(MEMBER_ROLE, claimer);\\n\\n        // check membership if has claimers limits or limited to members only\\n        if ((ubiSettings.maxMembers > 0 || ubiSettings.onlyMembers) && hasRole(MEMBER_ROLE, claimer) == false)\\n            revert NOT_MEMBER(claimer);\\n\\n        if (extendedSettings.maxPeriodClaimers > 0 && status.periodClaimers >= extendedSettings.maxPeriodClaimers)\\n            revert MAX_PERIOD_CLAIMERS_REACHED(status.periodClaimers);\\n\\n        // calculats the formula up today ie on day 0 there are no active users, on day 1 any user\\n        // (new or active) will trigger the calculation with the active users count of the day before\\n        // and so on. the new or inactive users that will become active today, will not take into account\\n        // within the calculation.\\n        uint256 dailyUbi = distributionFormula();\\n\\n        // active user which has not claimed today yet, ie user last claimed < today\\n        if (status.lastClaimed[whitelistedRoot] == status.currentDay) revert ALREADY_CLAIMED(whitelistedRoot);\\n\\n        status.lastClaimed[whitelistedRoot] = status.currentDay;\\n        status.periodClaimers += 1;\\n        status.periodDistributed += dailyUbi;\\n\\n        settings.rewardToken.safeTransfer(sendToWhitelistedRoot ? whitelistedRoot : claimer, dailyUbi);\\n\\n        emit UBIClaimed(whitelistedRoot, claimer, dailyUbi);\\n    }\\n\\n    /**\\n     * @dev Adds a member to the contract.\\n     * @param member The address of the member to add.\\n     * @param extraData Additional data to validate the member.\\n     */\\n\\n    function addMember(address member, bytes memory extraData) external returns (bool isMember) {\\n        if (address(settings.uniquenessValidator) != address(0)) {\\n            address rootAddress = settings.uniquenessValidator.getWhitelistedRoot(member);\\n            if (rootAddress == address(0)) revert NOT_WHITELISTED(member);\\n        }\\n\\n        if (address(settings.membersValidator) != address(0) && hasRole(MANAGER_ROLE, msg.sender) == false) {\\n            if (settings.membersValidator.isMemberValid(address(this), msg.sender, member, extraData) == false) {\\n                revert NOT_MEMBER(member);\\n            }\\n        }\\n        // if no members validator then if members only only manager can add members\\n        else if (ubiSettings.onlyMembers && hasRole(MANAGER_ROLE, msg.sender) == false) {\\n            revert NOT_MANAGER(member);\\n        }\\n\\n        _grantRole(MEMBER_ROLE, member);\\n        return true;\\n    }\\n\\n    function removeMember(address member) external onlyRole(MANAGER_ROLE) {\\n        _revokeRole(MEMBER_ROLE, member);\\n    }\\n\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        if (role == MEMBER_ROLE && hasRole(MEMBER_ROLE, account) == false) {\\n            if (ubiSettings.maxMembers > 0 && status.membersCount > ubiSettings.maxMembers)\\n                revert MAX_MEMBERS_REACHED();\\n            registry.addMember(account);\\n            status.membersCount += 1;\\n        }\\n        super._grantRole(role, account);\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        if (role == MEMBER_ROLE && hasRole(MEMBER_ROLE, account)) {\\n            status.membersCount -= 1;\\n            registry.removeMember(account);\\n        }\\n        super._revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets the safety limits for the pool.\\n     * @param _ubiSettings The new safety limits.\\n     */\\n    function setUBISettings(\\n        UBISettings memory _ubiSettings,\\n        ExtendedSettings memory _extendedSettings\\n    ) public onlyRole(MANAGER_ROLE) {\\n        _verifyUBISettings(_ubiSettings);\\n        ubiSettings = _ubiSettings;\\n        extendedSettings = _extendedSettings;\\n        emit UBISettingsChanged(_ubiSettings);\\n    }\\n\\n    function _verifyUBISettings(UBISettings memory _ubiSettings) internal pure {\\n        if (\\n            _ubiSettings.claimPeriodDays == 0 ||\\n            _ubiSettings.cycleLengthDays == 0 ||\\n            _ubiSettings.minActiveUsers == 0 ||\\n            _ubiSettings.maxClaimAmount == 0\\n        ) revert INVALID_0_VALUE();\\n    }\\n\\n    /**\\n     * @dev Sets the settings for the pool.\\n     * @param _settings The new pool settings.\\n     */\\n    function setPoolSettings(PoolSettings memory _settings) public onlyRole(MANAGER_ROLE) {\\n        _verifyPoolSettings(_settings);\\n\\n        if (_settings.manager != settings.manager) {\\n            _revokeRole(MANAGER_ROLE, settings.manager);\\n            _setupRole(MANAGER_ROLE, _settings.manager);\\n        }\\n        settings = _settings;\\n        emit PoolSettingsChanged(_settings);\\n    }\\n\\n    function _verifyPoolSettings(PoolSettings memory _poolSettings) internal pure {\\n        if (\\n            _poolSettings.manager == address(0) ||\\n            address(_poolSettings.uniquenessValidator) == address(0) ||\\n            address(_poolSettings.rewardToken) == address(0)\\n        ) revert INVALID_0_VALUE();\\n    }\\n\\n    function estimateNextDailyUBI() public view returns (uint256 nextDailyUbi) {\\n        (, nextDailyUbi, ) = _calcNextDailyUBI();\\n    }\\n\\n    function checkEntitlement() public view returns (uint256) {\\n        return checkEntitlement(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Checks the amount which the sender address is eligible to claim for,\\n     * regardless if they have been whitelisted or not. In case the user is\\n     * active, then the current day must be equal to the actual day, i.e. claim\\n     * or fish has already been executed today.\\n     * @return The amount of GD tokens the address can claim.\\n     */\\n    function checkEntitlement(address _member) public view returns (uint256) {\\n        // current day has already been updated which means\\n        // that the dailyUbi has been updated\\n        if (status.currentDay == getCurrentDay() && status.dailyUbi > 0) {\\n            if (extendedSettings.maxPeriodClaimers > 0 && status.periodClaimers >= extendedSettings.maxPeriodClaimers)\\n                return 0;\\n            return hasClaimed(_member) ? 0 : status.dailyUbi;\\n        }\\n        return estimateNextDailyUBI();\\n    }\\n\\n    function hasClaimed(address _member) public view returns (bool) {\\n        address whitelistedRoot = IIdentityV2(settings.uniquenessValidator).getWhitelistedRoot(_member);\\n        return status.lastClaimed[whitelistedRoot] == getCurrentDay();\\n    }\\n\\n    function nextClaimTime() public view returns (uint256) {\\n        return (getCurrentDay() + ubiSettings.claimPeriodDays) * (1 days) + 12 hours;\\n    }\\n}\\n\",\"keccak256\":\"0x5729d2632fa1ebf7df57feccda82d46e239ee255a2bf04c87d423ded4b619d23\",\"license\":\"MIT\"},\"contracts/UBI/UBIPoolFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n// import the DirectPayments contract\\nimport \\\"./UBIPool.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\\\";\\n\\nimport { AccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"../GoodCollective/GoodCollectiveSuperApp.sol\\\";\\nimport \\\"../GoodCollective/SuperAppBaseFlow.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\ncontract UBIPoolFactory is AccessControlUpgradeable, UUPSUpgradeable {\\n    error NOT_PROJECT_OWNER();\\n    error NOT_POOL();\\n\\n    event PoolCreated(\\n        address indexed pool,\\n        string indexed projectId,\\n        string ipfs,\\n        PoolSettings poolSettings,\\n        UBIPool.UBISettings poolLimits\\n    );\\n\\n    event PoolDetailsChanged(address indexed pool, string ipfs);\\n    event PoolVerifiedChanged(address indexed pool, bool isVerified);\\n    event UpdatedImpl(address indexed impl);\\n\\n    struct PoolRegistry {\\n        string ipfs;\\n        bool isVerified;\\n        string projectId;\\n    }\\n\\n    UpgradeableBeacon public impl;\\n\\n    mapping(address => PoolRegistry) public registry;\\n    mapping(bytes32 => UBIPool) public projectIdToControlPool;\\n\\n    address public feeRecipient;\\n    uint32 public feeBps;\\n\\n    mapping(address => address[]) public memberPools;\\n    address[] public pools;\\n\\n    modifier onlyProjectOwnerOrNon(string memory projectId) {\\n        UBIPool controlPool = projectIdToControlPool[keccak256(bytes(projectId))];\\n        // console.log(\\\"result %s\\\", controlPool.hasRole(controlPool.DEFAULT_ADMIN_ROLE(), msg.sender));\\n        if (address(controlPool) != address(0)) {\\n            if (controlPool.hasRole(controlPool.DEFAULT_ADMIN_ROLE(), msg.sender) == false) {\\n                revert NOT_PROJECT_OWNER();\\n            }\\n        }\\n        _;\\n    }\\n\\n    modifier onlyPoolOwner(UBIPool pool) {\\n        if (pool.hasRole(pool.DEFAULT_ADMIN_ROLE(), msg.sender) == false) {\\n            revert NOT_PROJECT_OWNER();\\n        }\\n\\n        _;\\n    }\\n\\n    modifier onlyPool() {\\n        if (bytes(registry[msg.sender].projectId).length == 0) {\\n            revert NOT_POOL();\\n        }\\n        _;\\n    }\\n\\n    function _authorizeUpgrade(address _impl) internal virtual override onlyRole(DEFAULT_ADMIN_ROLE) {}\\n\\n    function initialize(address _owner, address _impl, address _feeRecipient, uint32 _feeBps) external initializer {\\n        impl = new UpgradeableBeacon(_impl);\\n        feeRecipient = _feeRecipient;\\n        feeBps = _feeBps;\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\\n    }\\n\\n    function createManagedPool(\\n        string memory _projectId,\\n        string memory _ipfs,\\n        PoolSettings memory _settings,\\n        UBIPool.UBISettings memory _limits,\\n        UBIPool.ExtendedSettings memory _extendedSettings\\n    ) external onlyProjectOwnerOrNon(_projectId) returns (UBIPool pool) {\\n        return _createPool(_projectId, _ipfs, _settings, _limits, _extendedSettings, true);\\n    }\\n\\n    function createPool(\\n        string memory _projectId,\\n        string memory _ipfs,\\n        PoolSettings memory _settings,\\n        UBIPool.UBISettings memory _limits,\\n        UBIPool.ExtendedSettings memory _extendedSettings\\n    ) external onlyProjectOwnerOrNon(_projectId) returns (UBIPool pool) {\\n        return _createPool(_projectId, _ipfs, _settings, _limits, _extendedSettings, false);\\n    }\\n\\n    function _createPool(\\n        string memory _projectId,\\n        string memory _ipfs,\\n        PoolSettings memory _settings,\\n        UBIPool.UBISettings memory _limits,\\n        UBIPool.ExtendedSettings memory _extendedSettings,\\n        bool useBeacon\\n    ) internal returns (UBIPool pool) {\\n        //TODO: add check if msg.sender is whitelisted\\n\\n        bytes memory initCall = abi.encodeCall(UBIPool.initialize, (_settings, _limits, _extendedSettings, this));\\n\\n        if (useBeacon) {\\n            pool = UBIPool(address(new BeaconProxy(address(impl), initCall)));\\n        } else {\\n            pool = UBIPool(address(new ERC1967Proxy(impl.implementation(), initCall)));\\n        }\\n\\n        // Register the app with the host\\n        IRegisterSuperapp(address(pool.host())).registerApp(address(pool), SuperAppDefinitions.APP_LEVEL_FINAL);\\n\\n        //access control to project is determinted by the first pool access control rules\\n        if (address(projectIdToControlPool[keccak256(bytes(_projectId))]) == address(0))\\n            projectIdToControlPool[keccak256(bytes(_projectId))] = pool;\\n        registry[address(pool)].ipfs = _ipfs;\\n        registry[address(pool)].projectId = _projectId;\\n\\n        // restore creator ownership\\n        pool.grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        pool.renounceRole(DEFAULT_ADMIN_ROLE, address(this));\\n        pools.push(address(pool));\\n        emit PoolCreated(address(pool), _projectId, _ipfs, _settings, _limits);\\n    }\\n\\n    function changePoolDetails(UBIPool _pool, string memory _ipfs) external onlyPoolOwner(_pool) {\\n        registry[address(_pool)].ipfs = _ipfs;\\n        emit PoolDetailsChanged(address(_pool), _ipfs);\\n    }\\n\\n    function setVerified(UBIPool _pool, bool _isVerified) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        registry[address(_pool)].isVerified = _isVerified;\\n        emit PoolVerifiedChanged(address(_pool), _isVerified);\\n    }\\n\\n    function updateImpl(address _impl) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        impl.upgradeTo(_impl);\\n        emit UpdatedImpl(_impl);\\n    }\\n\\n    function setFeeInfo(address _feeRecipient, uint32 _feeBps) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        feeBps = _feeBps;\\n        feeRecipient = _feeRecipient;\\n    }\\n\\n    function addMember(address account) external onlyPool {\\n        memberPools[account].push(msg.sender);\\n    }\\n\\n    function removeMember(address member) external onlyPool {\\n        for (uint i = 0; i < memberPools[member].length; i++) {\\n            if (memberPools[member][i] == msg.sender) {\\n                memberPools[member][i] = memberPools[member][memberPools[member].length - 1];\\n                memberPools[member].pop();\\n            }\\n        }\\n    }\\n\\n    function getMemberPools(address member) external view returns (address[] memory) {\\n        return memberPools[member];\\n    }\\n}\\n\",\"keccak256\":\"0x25c9211fab6426bdd2e64a3e2f7696d5411400aa0ce3c6c793df36efb8a11ab1\",\"license\":\"MIT\"},\"contracts/utils/HelperLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\nimport \\\"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\\\";\\nimport { ISuperToken } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport { SuperTokenV1Library } from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\\\";\\nimport { CFAv1Library } from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\\\";\\n\\nimport \\\"../GoodCollective/IGoodCollectiveSuperApp.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\nlibrary HelperLibrary {\\n    using SuperTokenV1Library for ISuperToken;\\n    using CFAv1Library for CFAv1Library.InitData;\\n\\n    /**\\n     * @dev A struct containing information about a token swap\\n     * @param swapFrom The address of the token being swapped\\n     * @param amount The amount of tokens being swapped\\n     * @param minReturn The minimum amount of tokens to be received in the swap\\n     * @param timestamp The deadline for the swap to occur\\n     * @param path The path of tokens to take in a uniswap v3 multi-hop swap, encoded as bytes\\n     */\\n    struct SwapData {\\n        address swapFrom;\\n        uint256 amount;\\n        uint256 minReturn;\\n        uint256 deadline;\\n        bytes path;\\n    }\\n\\n    function handleSwap(\\n        IV3SwapRouter swapRouter,\\n        SwapData memory _customData,\\n        address outTokenIfNoPath,\\n        address _sender\\n    ) external returns (uint256 amountOut) {\\n        return handleSwap(swapRouter, _customData, outTokenIfNoPath, _sender, _sender);\\n    }\\n\\n    function handleSwap(\\n        IV3SwapRouter swapRouter,\\n        SwapData memory _customData,\\n        address outTokenIfNoPath,\\n        address _sender,\\n        address _recipient\\n    ) public returns (uint256 amountOut) {\\n        // Transfer the tokens from the sender to this contract\\n        TransferHelper.safeTransferFrom(_customData.swapFrom, _sender, address(this), _customData.amount);\\n\\n        // Approve the router to spend the tokens\\n        TransferHelper.safeApprove(_customData.swapFrom, address(swapRouter), _customData.amount);\\n\\n        if (_customData.path.length > 0) {\\n            // If a path is provided, execute a multi-hop swap\\n            IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter.ExactInputParams({\\n                path: _customData.path,\\n                recipient: _recipient,\\n                amountIn: _customData.amount,\\n                amountOutMinimum: _customData.minReturn\\n            });\\n            return swapRouter.exactInput(params);\\n        } else {\\n            // If no path is provided, execute a single-hop swap\\n            IV3SwapRouter.ExactInputSingleParams memory params = IV3SwapRouter.ExactInputSingleParams({\\n                tokenIn: _customData.swapFrom,\\n                tokenOut: outTokenIfNoPath,\\n                fee: 10000,\\n                recipient: _recipient,\\n                amountIn: _customData.amount,\\n                amountOutMinimum: _customData.minReturn,\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n            // Execute the swap using `exactInputSingle`\\n            return swapRouter.exactInputSingle(params);\\n        }\\n    }\\n\\n    function getRealtimeStats(\\n        IGoodCollectiveSuperApp.Stats memory stats,\\n        ISuperToken superToken\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 netIncome,\\n            uint256 totalFees,\\n            uint256 protocolFees,\\n            uint256 managerFees,\\n            int96 incomeFlowRate,\\n            int96 feeRate,\\n            int96 managerFeeRate\\n        )\\n    {\\n        incomeFlowRate = stats.lastIncomeRate;\\n        netIncome = stats.netIncome + uint96(stats.lastIncomeRate) * (block.timestamp - stats.lastUpdate);\\n        feeRate = superToken.getFlowRate(address(this), stats.lastFeeRecipient);\\n        managerFeeRate = superToken.getFlowRate(address(this), stats.lastManagerFeeRecipient);\\n\\n        protocolFees =\\n            stats.protocolFees +\\n            uint96(superToken.getFlowRate(address(this), stats.lastFeeRecipient)) *\\n            (block.timestamp - stats.lastUpdate);\\n        managerFees =\\n            stats.managerFees +\\n            uint96(superToken.getFlowRate(address(this), stats.lastManagerFeeRecipient)) *\\n            (block.timestamp - stats.lastUpdate);\\n        totalFees = protocolFees + managerFees;\\n    }\\n\\n    // this should be called before any flow rate changes\\n    function updateStats(\\n        IGoodCollectiveSuperApp.Stats storage stats,\\n        ISuperToken superToken,\\n        IRegistry registry,\\n        uint32 managerFeeBps,\\n        uint256 _amount\\n    ) external {\\n        uint feeBps;\\n        if (address(registry) != address(0)) {\\n            feeBps = registry.feeBps();\\n        }\\n        //use last rate before the current possible rate update\\n        stats.netIncome += uint96(stats.lastIncomeRate) * (block.timestamp - stats.lastUpdate);\\n        if (stats.lastFeeRecipient != address(0)) {\\n            //fees sent to last recipient, the flowRate to recipient still wasnt updated.\\n            stats.protocolFees +=\\n                uint96(superToken.getFlowRate(address(this), stats.lastFeeRecipient)) *\\n                (block.timestamp - stats.lastUpdate);\\n        }\\n        if (stats.lastManagerFeeRecipient != address(0)) {\\n            //fees sent to last recipient, the flowRate to recipient still wasnt updated.\\n            stats.managerFees +=\\n                uint96(superToken.getFlowRate(address(this), stats.lastManagerFeeRecipient)) *\\n                (block.timestamp - stats.lastUpdate);\\n        }\\n\\n        if (_amount > 0) {\\n            stats.netIncome += (_amount * (10000 - feeBps - managerFeeBps)) / 10000;\\n            stats.protocolFees += (_amount * feeBps) / 10000;\\n            stats.managerFees += (_amount * managerFeeBps) / 10000;\\n        }\\n        stats.totalFees = stats.managerFees + stats.protocolFees;\\n        stats.lastUpdate = block.timestamp;\\n    }\\n\\n    function takeFeeFlow(\\n        CFAv1Library.InitData storage cfaV1,\\n        ISuperToken superToken,\\n        address prevRecipient,\\n        address recipient,\\n        uint32 feeBps,\\n        int96 _diffRate,\\n        bytes memory _ctx\\n    ) public returns (bytes memory newCtx) {\\n        newCtx = _ctx;\\n        if (address(recipient) == address(0)) return newCtx;\\n        int96 curFeeRate = superToken.getFlowRate(address(this), prevRecipient);\\n        bool newRecipient;\\n        if (recipient != prevRecipient) {\\n            newRecipient = true;\\n            if (prevRecipient != address(0)) {\\n                //delete old recipient flow\\n                if (curFeeRate > 0) newCtx = cfaV1.deleteFlowWithCtx(newCtx, address(this), prevRecipient, superToken); //passing in the ctx which is sent to the callback here\\n            }\\n        }\\n        if (recipient == address(0)) return newCtx;\\n\\n        int96 newFeeRate = curFeeRate + (_diffRate * int32(feeBps)) / 10000;\\n        if (newRecipient == false && curFeeRate > 0) {\\n            if (newFeeRate <= 0) {\\n                newCtx = cfaV1.deleteFlowWithCtx(newCtx, address(this), recipient, superToken); //passing in the ctx which is sent to the callback here\\n            } else {\\n                newCtx = cfaV1.updateFlowWithCtx(newCtx, recipient, superToken, newFeeRate); //passing in the ctx which is sent to the callback here\\n            }\\n        } else if (newFeeRate > 0) newCtx = cfaV1.createFlowWithCtx(newCtx, recipient, superToken, newFeeRate); //passing in the ctx which is sent to the callback here\\n    }\\n}\\n\",\"keccak256\":\"0x9a37923f5f3673399e70dd9d63109ed2cded7aef9fe296eae9beff073d7c0bbd\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60e06040523060c0523480156200001557600080fd5b506040516200568338038062005683833981016040819052620000389162000098565b6001600160a01b038216608081905282908290620000695760405163538ba4f960e01b815260040160405180910390fd5b6001600160a01b031660a05250620000d7915050565b6001600160a01b03811681146200009557600080fd5b50565b60008060408385031215620000ac57600080fd5b8251620000b9816200007f565b6020840151909250620000cc816200007f565b809150509250929050565b60805160a05160c0516155136200017060003960008181611106015281816111460152818161149e015281816114de015261155601526000818161097a01528181610e8201526123f8015260008181610bc801528181610e0401528181610fcc01528181611604015281816119de01528181611f070152818161204f0152818161230e01528181612a610152612d9901526155136000f3fe60806040526004361061027b5760003560e01c806301ffc9a7146102805780630b1ca49a146102b55780630c710776146102d75780630ce82d67146103035780630e0cc1b91461032657806319805538146103465780631a2a84b31461037f5780631a787f2e1461039f5780631db128c7146103bf578063200d2ed2146103ec578063230dbd291461046e578063248a9ca31461048e578063298052df146104ae5780632b4116f7146104c35780632f2ff15d146104f057806330d9c9151461051057806336568abe146105305780633659cfe6146105505780633e6968b61461057057806346b6a742146105855780634e71d92d146105a55780634f1ef286146105ba57806352d1902d146105cd57806353c11f99146105e2578063598f8fbf146106025780635a4c5152146106225780635ab1bd53146106b95780635da93292146106ce5780635f9e7d77146106e35780636180c79314610703578063647c75e21461072357806372ca8a3e1461079457806373b2e80e146107b4578063791ea89b146107d45780637b103999146107f457806388480f0c14610815578063884d1f401461086757806391d148541461088757806398d6621b146108a75780639f8fddd2146108bc578063a10f469e146108dc578063a217fddf146108fe578063a4c0ed3614610913578063ae82720014610933578063bcb4546f14610946578063c31c9c0714610968578063c77138701461099c578063d3112b2e146109b1578063d547741f146109e6578063d80528ae14610a06578063d86ed3e514610a97578063dc61d5c214610ab7578063def482a414610b0a578063e06174e414610b2a578063ec87621c14610b94578063f437bc5914610bb6575b600080fd5b34801561028c57600080fd5b506102a061029b36600461449c565b610bea565b60405190151581526020015b60405180910390f35b3480156102c157600080fd5b506102d56102d03660046144db565b610c21565b005b3480156102e357600080fd5b506102f06459df64940081565b604051600b9190910b81526020016102ac565b34801561030f57600080fd5b50610318610c55565b6040519081526020016102ac565b34801561033257600080fd5b506102d5610341366004614516565b610c73565b34801561035257600080fd5b5061035b610ca8565b604080516001600160a01b03909316835263ffffffff9091166020830152016102ac565b34801561038b57600080fd5b5061031861039a3660046144db565b610cc7565b3480156103ab57600080fd5b506103186103ba3660046144db565b610d67565b3480156103cb57600080fd5b506103df6103da3660046146b7565b610de2565b6040516102ac919061477e565b3480156103f857600080fd5b5061013a5461013b5461013c5461013d5461013e5461013f54610140546101425461042d979695949392919063ffffffff1688565b604080519889526020890197909752958701949094526060860192909252608085015260a084015260c083015263ffffffff1660e0820152610100016102ac565b34801561047a57600080fd5b506103df6104893660046147d9565b610f03565b34801561049a57600080fd5b506103186104a93660046148a3565b610f4a565b3480156104ba57600080fd5b50610318610f5f565b3480156104cf57600080fd5b506097546104e3906001600160a01b031681565b6040516102ac91906148bc565b3480156104fc57600080fd5b506102d561050b3660046148d0565b610f9e565b34801561051c57600080fd5b506103df61052b3660046148f5565b610fbf565b34801561053c57600080fd5b506102d561054b3660046148d0565b611082565b34801561055c57600080fd5b506102d561056b3660046144db565b6110fc565b34801561057c57600080fd5b506103186111c4565b34801561059157600080fd5b506102d56105a0366004614b57565b6111e0565b3480156105b157600080fd5b506102d5611487565b6102d56105c8366004614bb3565b611494565b3480156105d957600080fd5b50610318611549565b3480156105ee57600080fd5b506103df6105fd3660046147d9565b6115f7565b34801561060e57600080fd5b506102d561061d366004614c02565b6116d4565b34801561062e57600080fd5b506101375461013854610139546106749263ffffffff80821693600160201b808404831694600160401b850484169460ff600160601b9091048116948216929091041687565b6040805163ffffffff98891681529688166020880152948716948601949094529115156060850152608084015290921660a082015290151560c082015260e0016102ac565b3480156106c557600080fd5b506104e3611809565b3480156106da57600080fd5b50610318611819565b3480156106ef57600080fd5b506103df6106fe3660046148f5565b6119d1565b34801561070f57600080fd5b506102a061071e366004614bb3565b611ab6565b34801561072f57600080fd5b5061076d61073e3660046144db565b60986020526000908152604090208054600190910154600b81900b90600160601b90046001600160801b031683565b60408051938452600b9290920b60208401526001600160801b0316908201526060016102ac565b3480156107a057600080fd5b506102a06107af3660046144db565b611cb3565b3480156107c057600080fd5b506102a06107cf3660046144db565b611cc7565b3480156107e057600080fd5b506102d56107ef366004614c1e565b611d6a565b34801561080057600080fd5b50610143546104e3906001600160a01b031681565b34801561082157600080fd5b506101445461014554610146546108409263ffffffff90811692911683565b6040805163ffffffff948516815260208101939093529216918101919091526060016102ac565b34801561087357600080fd5b506103df6108823660046148f5565b611efa565b34801561089357600080fd5b506102a06108a23660046148d0565b611ff7565b3480156108b357600080fd5b50610318612022565b3480156108c857600080fd5b506103df6108d7366004614c54565b61202d565b3480156108e857600080fd5b506103186000805160206154be83398151915281565b34801561090a57600080fd5b50610318600081565b34801561091f57600080fd5b506102a061092e366004614ca2565b6120e7565b6102d5610941366004614cfd565b612160565b34801561095257600080fd5b5061031860008051602061541783398151915281565b34801561097457600080fd5b506104e37f000000000000000000000000000000000000000000000000000000000000000081565b3480156109a857600080fd5b506103186121e6565b3480156109bd57600080fd5b50609954609a546109d8916001600160a01b03908116911682565b6040516102ac929190614d31565b3480156109f257600080fd5b506102d5610a013660046148d0565b6121f7565b348015610a1257600080fd5b50609b54609c54609d54609e54609f5460a05460a154610a4d969594936001600160a01b0380821694600160a01b909204600b0b9391169188565b604080519889526020890197909752958701949094526001600160a01b039283166060870152600b9190910b60808601521660a084015260c083015260e0820152610100016102ac565b348015610aa357600080fd5b506103df610ab23660046147d9565b612213565b348015610ac357600080fd5b50610acc612241565b604080519788526020880196909652948601939093526060850191909152600b90810b608085015290810b60a08401520b60c082015260e0016102ac565b348015610b1657600080fd5b506103df610b25366004614d4b565b6122ec565b348015610b3657600080fd5b5061013354610134546101355461013654610b61936001600160a01b03908116938116928116911684565b604080516001600160a01b03958616815293851660208501529184169183019190915290911660608201526080016102ac565b348015610ba057600080fd5b5061031860008051602061547783398151915281565b348015610bc257600080fd5b506104e37f000000000000000000000000000000000000000000000000000000000000000081565b60006001600160e01b03198216637965db0b60e01b1480610c1b57506301ffc9a760e01b6001600160e01b03198316145b92915050565b600080516020615477833981519152610c398161253f565b610c516000805160206154be83398151915283612549565b5050565b61013d54600090610c646111c4565b610c6e9190614dbf565b905090565b61013754600160601b900460ff16610c9e576040516369973f2560e11b815260040160405180910390fd5b610c518282612629565b61013354610146546001600160a01b039091169163ffffffff90911690565b6001600160a01b0381166000908152609860209081526040808320815160608101835281548152600190910154600b81900b938201849052600160601b90046001600160801b031691810191909152908203610d24575192915050565b6040810151610d3c906001600160801b031642614dbf565b81602001516001600160601b0316610d549190614dd2565b8151610d609190614de9565b9392505050565b6000610d716111c4565b61013a54148015610d84575061013b5415155b15610dda576101445463ffffffff1615801590610daf57506101445461013f5463ffffffff90911611155b15610dbc57506000919050565b610dc582611cc7565b610dd25761013b54610c1b565b600092915050565b610c1b6121e6565b606082336001600160a01b03821614801590610e275750336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614155b15610e50573360405163087231bf60e31b8152600401610e4791906148bc565b60405180910390fd5b6097546040516358c0dacb60e01b81527385608a0f804D0a9A72C022c812125AA25fA5B9bf916358c0dacb91610eb8917f0000000000000000000000000000000000000000000000000000000000000000918a916001600160a01b0316908a90600401614e41565b602060405180830381865af4158015610ed5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ef99190614e7c565b5091949350505050565b60606000610f1387890189614e95565b509050600080610f2587890189614ed2565b91509150610f378d8484848a8a6128ce565b93505050505b9998505050505050505050565b60009081526065602052604090206001015490565b61013754600090600160201b900463ffffffff16610f7b6111c4565b610f859190614de9565b610f929062015180614dd2565b610c6e9061a8c0614de9565b610fa782610f4a565b610fb08161253f565b610fba8383612915565b505050565b6060336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461100a57604051632f2d36a760e01b815260040160405180910390fd5b61101387612a3b565b6110365750604080518082019091526002815261060f60f31b6020820152611077565b61103f88611cb3565b61105c57604051631ea25bab60e31b815260040160405180910390fd5b50604080518082019091526002815261060f60f31b60208201525b979650505050505050565b6001600160a01b03811633146110f25760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b6064820152608401610e47565b610c518282612549565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036111445760405162461bcd60e51b8152600401610e4790614efe565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316611176612aef565b6001600160a01b03161461119c5760405162461bcd60e51b8152600401610e4790614f38565b6111a581612b0b565b604080516000808252602082019092526111c191839190612b16565b50565b6000620151806111d661a8c042614dbf565b610c6e9190614f72565b600054610100900460ff16158080156112005750600054600160ff909116105b80611221575061120f30612c81565b158015611221575060005460ff166001145b6112845760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610e47565b6000805460ff1916600117905580156112a7576000805461ff0019166101001790555b61014380546001600160a01b03199081166001600160a01b038581169190911790925586516101338054831691841691909117905560208088015161013480548416918516919091179055604080890151610135805485169186169190911790556060808a0151610136805490951695169490941790925586516101378054898401518a860151968b015163ffffffff9485166001600160401b031990931692909217600160201b91851682021764ffffffffff60401b1916600160401b9785169790970260ff60601b191696909617600160601b9115159190910217905560808801516101385560a0880151610139805460c08b015192841664ffffffffff1990911617911515909502179093558551610144805463ffffffff19908116928616929092179055908601516101455590850151610146805490921692169190911790556113f485612c90565b6113fd84612ce6565b611408600033612d3d565b6114246000805160206154778339815191528660000151612d3d565b6101365461143a906001600160a01b0316612d47565b8015611480576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b611492336001612629565b565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036114dc5760405162461bcd60e51b8152600401610e4790614efe565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661150e612aef565b6001600160a01b0316146115345760405162461bcd60e51b8152600401610e4790614f38565b61153d82612b0b565b610c5182826001612b16565b6000306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146115e45760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c6044820152771b1959081d1a1c9bdd59da0819195b1959d85d1958d85b1b60421b6064820152608401610e47565b5060008051602061545783398151915290565b6060336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016141580611637575061163589612a3b565b155b8061164857506116468a611cb3565b155b1561168c5782828080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929350610f3d92505050565b60008061169b888a018a614e95565b90925090506000806116af888a018a614f94565b915091506116c28e858584868c8c612e6c565b9e9d5050505050505050505050505050565b6000805160206154778339815191526116ec8161253f565b6116f582612c90565b6101335482516001600160a01b0390811691161461174f576101335461173390600080516020615477833981519152906001600160a01b0316612549565b61174f6000805160206154778339815191528360000151612d3d565b815161013380546001600160a01b03199081166001600160a01b03938416908117909255602080860180516101348054851691871691909117905560408088018051610135805487169189169190911790556060808a0180516101368054909816908a161790965582519687529251871693860193909352915185168483015291519093169082015290517fc5e56c36231b7247b96ddd6a7e47b60748a332bcb3a514d016fd2e74d9159351916080908290030190a15050565b610143546001600160a01b031690565b6000806118246111c4565b6101375461013a5491925061184791600160201b90910463ffffffff1690614de9565b81106119c857600080600061185a612ebf565b925092509250801561194357610136546040516370a0823160e01b81526000916001600160a01b0316906370a08231906118989030906004016148bc565b602060405180830381865afa1580156118b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118d99190614e7c565b61013c8590556101375463ffffffff1661013e81905561013d879055604080518881526020810184905290810191909152606081018690529091507f83e0d535b9e84324e0a25922406398d6ff5f96d0c686204ee490e16d7670566f9060800160405180910390a1505b61013a84905561013b82905561014554821161196057600061013b555b61013b5461013f5461014054604080518881526020810194909452438482015260608401929092526080830152517fdd2b882b89647cd6c5641ce6ab9d46f1c17865d2b22f065850f30f83cc7d8cf89181900360a00190a15050600061013f81905561014055505b505061013b5490565b6060336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016141580611a115750611a0f87612a3b565b155b80611a225750611a2088611cb3565b155b15611a465750604080518082019091526002815261060f60f31b6020820152611077565b600080611a5586880188614e95565b9092509050600080611a716001600160a01b038d168585613071565b5050915091508181604051602001611a96929190918252600b0b602082015260400190565b604051602081830303815290604052945050505050979650505050505050565b610135546000906001600160a01b031615611b6b57610135546040516316874da360e11b81526000916001600160a01b031690632d0e9b4690611afd9087906004016148bc565b602060405180830381865afa158015611b1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b3e9190614fb9565b90506001600160a01b038116611b695783604051630b7b234960e01b8152600401610e4791906148bc565b505b610134546001600160a01b031615801590611b9b5750611b9960008051602061547783398151915233611ff7565b155b15611c4357610134546040516356a42afd60e11b81526001600160a01b039091169063ad4855fa90611bd7903090339088908890600401614fd6565b6020604051808303816000875af1158015611bf6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c1a9190615014565b1515600003611c3e578260405163130f4a3760e11b8152600401610e4791906148bc565b611c92565b61013954600160201b900460ff168015611c725750611c7060008051602061547783398151915233611ff7565b155b15611c925782604051636f6acad560e01b8152600401610e4791906148bc565b611caa6000805160206154be83398151915284612915565b50600192915050565b6097546001600160a01b0390811691161490565b610135546040516316874da360e11b815260009182916001600160a01b0390911690632d0e9b4690611cfd9086906004016148bc565b602060405180830381865afa158015611d1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d3e9190614fb9565b9050611d486111c4565b6001600160a01b03909116600090815261014160205260409020541492915050565b600080516020615477833981519152611d828161253f565b611d8b83612ce6565b8251610137805460208087015160408089015160608a01511515600160601b0260ff60601b1963ffffffff928316600160401b021664ffffffffff60401b19948316600160201b9081026001600160401b0319909816998416999099179690961793909316949094179190911790935560808701516101385560a0870151610139805460c08a0151151590960264ffffffffff1990961691841691909117949094179093558451610144805491831663ffffffff19928316179055928501516101455584820151610146805491909216931692909217909155517f9c2d0f3e240667c2b704104ff988af37be9eb4befb81fe00424626b088ee757990611eed908590600060e08201905063ffffffff808451168352806020850151166020840152806040850151166040840152606084015115156060840152608084015160808401528060a08501511660a08401525060c0830151151560c083015292915050565b60405180910390a1505050565b6060336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614611f4557604051632f2d36a760e01b815260040160405180910390fd5b611f4e87612a3b565b611f715750604080518082019091526002815261060f60f31b6020820152611077565b611f7a88611cb3565b611f9757604051631ea25bab60e31b815260040160405180910390fd5b6000611fa585870187614e95565b509050600080611fbf6001600160a01b038c168430613071565b505060408051600b9290920b60208301528181019290925281518082038301815260609091019091529b9a5050505050505050505050565b60009182526065602090815260408084206001600160a01b0393909316845291905290205460ff1690565b6000610c6e33610d67565b606083336001600160a01b038216148015906120725750336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614155b15612092573360405163087231bf60e31b8152600401610e4791906148bc565b836000036120b357604051630f6fa54560e41b815260040160405180910390fd5b6097546120cb906001600160a01b0316863087613109565b610ef98585600060405180602001604052806000815250613213565b6097546000906001600160a01b0316331461211557604051630ce706f760e41b815260040160405180910390fd5b8360000361213657604051630f6fa54560e41b815260040160405180910390fd5b6121528585600060405180602001604052806000815250613213565b50600190505b949350505050565b6101435460408051638abf607760e01b815290516000926001600160a01b031691638abf60779160048083019260209291908290030181865afa1580156121ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121cf9190614fb9565b90506121da81612b0b565b610c5181836000612b16565b60006121f0612ebf565b5092915050565b61220082610f4a565b6122098161253f565b610fba8383612549565b6060600061222387890189614e95565b5090506122328b8286866138bb565b9b9a5050505050505050505050565b60975460405163b2f918a160e01b81526000918291829182918291829182917385608a0f804D0a9A72C022c812125AA25fA5B9bf9163b2f918a19161229591609b916001600160a01b031690600401615031565b60e060405180830381865af41580156122b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122d691906150bb565b959d949c50929a50909850965094509092509050565b606083336001600160a01b038216148015906123315750336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614155b15612351573360405163087231bf60e31b8152600401610e4791906148bc565b6097546040516370a0823160e01b81526000916001600160a01b0316906370a08231906123829030906004016148bc565b602060405180830381865afa15801561239f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123c39190614e7c565b6097546040516321437a5360e01b81529192507385608a0f804D0a9A72C022c812125AA25fA5B9bf916321437a5391612432917f0000000000000000000000000000000000000000000000000000000000000000918a916001600160a01b03909116908c90309060040161512f565b602060405180830381865af415801561244f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124739190614e7c565b506097546040516370a0823160e01b815260009183916001600160a01b03909116906370a08231906124a99030906004016148bc565b602060405180830381865afa1580156124c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124ea9190614e7c565b6124f49190614dbf565b90508060000361251757604051630f6fa54560e41b815260040160405180910390fd5b6125338782600060405180602001604052806000815250613213565b50939695505050505050565b6111c18133613909565b6000805160206154be8339815191528214801561257957506125796000805160206154be83398151915282611ff7565b1561261f5761014280546001919060009061259b90849063ffffffff16615170565b825463ffffffff9182166101009390930a9283029190920219909116179055506101435460405163058e524d60e11b81526001600160a01b0390911690630b1ca49a906125ec9084906004016148bc565b600060405180830381600087803b15801561260657600080fd5b505af115801561261a573d6000803e3d6000fd5b505050505b610c518282613962565b610135546040516316874da360e11b81526000916001600160a01b031690632d0e9b469061265b9086906004016148bc565b602060405180830381865afa158015612678573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061269c9190614fb9565b90506001600160a01b0381166126c75782604051630b7b234960e01b8152600401610e4791906148bc565b6101395463ffffffff16158015906126ea575061013954600160201b900460ff16155b15612707576127076000805160206154be83398151915284612915565b6101395463ffffffff16151580612728575061013954600160201b900460ff165b801561274957506127476000805160206154be83398151915284611ff7565b155b15612769578260405163130f4a3760e11b8152600401610e4791906148bc565b6101445463ffffffff161580159061278f57506101445461013f5463ffffffff90911611155b156127b55761013f54604051635136bc3160e01b81526004810191909152602401610e47565b60006127bf611819565b61013a546001600160a01b0384166000908152610141602052604090205491925090036128015781604051631fc1cabf60e31b8152600401610e4791906148bc565b61013a546001600160a01b0383166000908152610141602052604081209190915561013f805460019290612836908490614de9565b90915550506101408054829190600090612851908490614de9565b9091555061287b9050836128655784612867565b825b610136546001600160a01b031690836139c9565b836001600160a01b0316826001600160a01b03167f1c0764b87f885ff7e1be5f7c06a0cc99c5bdc0f7b4884440e6ebe5b12bfd511d836040516128c091815260200190565b60405180910390a350505050565b60606110778686600b0b8686868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061321392505050565b6000805160206154be8339815191528214801561294757506129456000805160206154be83398151915282611ff7565b155b15612a31576101395463ffffffff16158015906129735750610139546101425463ffffffff9182169116115b1561299157604051632263c94160e01b815260040160405180910390fd5b6101435460405163329b55b760e21b81526001600160a01b039091169063ca6d56dc906129c29084906004016148bc565b600060405180830381600087803b1580156129dc57600080fd5b505af11580156129f0573d6000803e3d6000fd5b5050610142805460019350909150600090612a1290849063ffffffff1661518d565b92506101000a81548163ffffffff021916908363ffffffff1602179055505b610c518282613a1f565b604051635b69006f60e11b815260008051602061541783398151915260048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063b6d200de90602401602060405180830381865afa158015612ab0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ad49190614fb9565b6001600160a01b0316826001600160a01b0316149050919050565b600080516020615457833981519152546001600160a01b031690565b6000610c518161253f565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff1615612b4957610fba83613aa5565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015612ba3575060408051601f3d908101601f19168201909252612ba091810190614e7c565b60015b612c065760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b6064820152608401610e47565b6000805160206154578339815191528114612c755760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b6064820152608401610e47565b50610fba838383613b3f565b6001600160a01b03163b151590565b80516001600160a01b03161580612cb2575060408101516001600160a01b0316155b80612cc8575060608101516001600160a01b0316155b156111c157604051631e597d8360e11b815260040160405180910390fd5b602081015163ffffffff161580612d025750805163ffffffff16155b80612d155750604081015163ffffffff16155b80612cc8575060808101516111c157604051631e597d8360e11b815260040160405180910390fd5b610c518282612915565b6001600160a01b038116612d6e5760405163538ba4f960e01b815260040160405180910390fd5b609780546001600160a01b0319166001600160a01b03838116919091179091556040805180820182527f00000000000000000000000000000000000000000000000000000000000000009092168083529051635b69006f60e11b8152600080516020615417833981519152600482015260208301919063b6d200de90602401602060405180830381865afa158015612e0a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e2e9190614fb9565b6001600160a01b039081169091528151609980546001600160a01b0319908116928416929092179055602090920151609a8054909316911617905550565b6060612eb38786600b0b8686868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061321392505050565b98975050505050505050565b610136546040516370a0823160e01b81526000918291829182916001600160a01b03909116906370a0823190612ef99030906004016148bc565b602060405180830381865afa158015612f16573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f3a9190614e7c565b61013754909150600090612f549063ffffffff1683614f72565b90506000606461013a600201546069612f6d9190614dd2565b612f779190614f72565b821180612fbb575061013e54612f8b610c55565b11158015612fbb5750612f9c610c55565b61013e54612faa9190614dbf565b61013c54612fb89190614dd2565b83105b61013c5461013e54909750909150612fd1610c55565b612fdc906001614de9565b101580612fe65750805b156130065761013754612fff9063ffffffff1684614f72565b9550600193505b6101385461013f546130569190613047906127109061302790612904614dd2565b6130319190614f72565b61013754600160401b900463ffffffff16613b6a565b6130519089614f72565b613b81565b6101455490955085101561306957600094505b505050909192565b600080600080600061308288613b90565b604051631cd43d1160e31b81529092506001600160a01b038316915063e6a1e888906130b6908b908b908b906004016151aa565b608060405180830381865afa1580156130d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130f791906151cd565b929b919a509850909650945050505050565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b179052915160009283929088169161316d919061520b565b6000604051808303816000865af19150503d80600081146131aa576040519150601f19603f3d011682016040523d82523d6000602084013e6131af565b606091505b50915091508180156131d95750805115806131d95750808060200190518101906131d99190615014565b61320b5760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b6044820152606401610e47565b505050505050565b805181901515600080613224610ca8565b60975491935091507385608a0f804D0a9A72C022c812125AA25fA5B9bf9063934e2cce90609b906001600160a01b031661325c611809565b8588613268578c61326b565b60005b6040516001600160e01b031960e088901b16815260048101959095526001600160a01b03938416602486015292909116604484015263ffffffff166064830152608482015260a40160006040518083038186803b1580156132cb57600080fd5b505af41580156132df573d6000803e3d6000fd5b5050609754600092506132fd91506001600160a01b03168a30613cff565b6001600160a01b038a1660009081526098602052604090205490915084156136f257600082600b0b13801561333a57506459df649400600b83900b125b1561335d57604051624963df60e91b8152600b83900b6004820152602401610e47565b6001600160a01b038a16600090815260986020526040902060010180546001600160e01b031916600160601b426001600160801b038116919091026001600160601b031916919091176001600160601b038516179091556133bf908990614dbf565b6133c9908a614dd2565b6001600160a01b038b16600090815260986020526040812080549091906133f1908490614de9565b9091555060009050613401611809565b6001600160a01b0316146135c457613417611809565b6001600160a01b031663469048406040518163ffffffff1660e01b8152600401602060405180830381865afa158015613454573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134789190614fb9565b9350613482611809565b6001600160a01b03166324a9d8536040518163ffffffff1660e01b8152600401602060405180830381865afa1580156134bf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134e39190615227565b92507385608a0f804D0a9A72C022c812125AA25fA5B9bf634d167a906099609760009054906101000a90046001600160a01b0316609b60030160009054906101000a90046001600160a01b031688888f8961353e9190615244565b8d6040518863ffffffff1660e01b81526004016135619796959493929190615271565b600060405180830381865af415801561357e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526135a691908101906152c1565b609e80546001600160a01b0319166001600160a01b03871617905595505b6135cc610ca8565b80945081955050507385608a0f804D0a9A72C022c812125AA25fA5B9bf634d167a906099609760009054906101000a90046001600160a01b0316609b60040160009054906101000a90046001600160a01b031688888f8961362d9190615244565b8d6040518863ffffffff1660e01b81526004016136509796959493929190615271565b600060405180830381865af415801561366d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261369591908101906152c1565b609f80546001600160a01b0319166001600160a01b03878116919091179091556097549197506136c6911630613d8d565b609e80546001600160601b0392909216600160a01b026001600160a01b03909216919091179055613831565b60006136fc611809565b6001600160a01b0316146137eb57613712611809565b6001600160a01b031663469048406040518163ffffffff1660e01b8152600401602060405180830381865afa15801561374f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137739190614fb9565b935061377d611809565b6001600160a01b03166324a9d8536040518163ffffffff1660e01b8152600401602060405180830381865afa1580156137ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137de9190615227565b92506137eb84848b613e0c565b6137f3610ca8565b909450925061380384848b613e0c565b6001600160a01b038a16600090815260986020526040812080548b929061382b908490614de9565b90915550505b6001600160a01b038a166000818152609860205260409020547f6342e11b65ccb38a3bb259be9cda846c74ad52b36b62a2ee4799dc3db63a04a39083908861387a57600061387c565b8c5b604080519384526020840192909252600b90810b8383015286900b60608301528815156080830152519081900360a00190a25050505050949350505050565b60606139008460008086868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061321392505050565b95945050505050565b6139138282611ff7565b610c515761392081613e58565b61392b836020613e6a565b60405160200161393c92919061532e565b60408051601f198184030181529082905262461bcd60e51b8252610e479160040161477e565b61396c8282611ff7565b15610c515760008281526065602090815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b610fba8363a9059cbb60e01b84846040516024016139e892919061539d565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152614005565b613a298282611ff7565b610c515760008281526065602090815260408083206001600160a01b03851684529091529020805460ff19166001179055613a613390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b613aae81612c81565b613b105760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b6064820152608401610e47565b60008051602061545783398151915280546001600160a01b0319166001600160a01b0392909216919091179055565b613b48836140d7565b600082511180613b555750805b15610fba57613b648383614117565b50505050565b600081831015613b7a5781610d60565b5090919050565b6000818310613b7a5781610d60565b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a546001600160a01b038116613cce576001600160a01b038216613c5557826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa158015613c2e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613c529190614fb9565b91505b604051635b69006f60e11b815260008051602061541783398151915260048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015613ca7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ccb9190614fb9565b90505b6001600160a01b038216613ce457613ce46153b6565b6001600160a01b038116613cfa57613cfa6153b6565b915091565b600080613d0b85613b90565b604051631cd43d1160e31b81529092506001600160a01b038316915063e6a1e88890613d3f908890889088906004016151aa565b608060405180830381865afa158015613d5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613d8091906151cd565b5090979650505050505050565b600080613d9984613b90565b60405163e8e7e2d160e01b81529092506001600160a01b038316915063e8e7e2d190613dcb9087908790600401614d31565b602060405180830381865afa158015613de8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061215891906153cc565b6001600160a01b038316613e1f57505050565b6000612710613e3463ffffffff851684614dd2565b613e3e9190614f72565b609754909150613b64906001600160a01b03168583614200565b6060610c1b6001600160a01b03831660145b60606000613e79836002614dd2565b613e84906002614de9565b6001600160401b03811115613e9b57613e9b61455c565b6040519080825280601f01601f191660200182016040528015613ec5576020820181803683370190505b509050600360fc1b81600081518110613ee057613ee06153e9565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110613f0f57613f0f6153e9565b60200101906001600160f81b031916908160001a9053506000613f33846002614dd2565b613f3e906001614de9565b90505b6001811115613fb6576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110613f7257613f726153e9565b1a60f81b828281518110613f8857613f886153e9565b60200101906001600160f81b031916908160001a90535060049490941c93613faf816153ff565b9050613f41565b508315610d605760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610e47565b600061405a826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166143039092919063ffffffff16565b805190915015610fba57808060200190518101906140789190615014565b610fba5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610e47565b6140e081613aa5565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b606061412283612c81565b61417d5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b6064820152608401610e47565b600080846001600160a01b031684604051614198919061520b565b600060405180830381855af49150503d80600081146141d3576040519150601f19603f3d011682016040523d82523d6000602084013e6141d8565b606091505b5091509150613900828260405180606001604052806027815260200161549760279139614312565b600080846001600160a01b031663a9059cbb60e01b858560405160240161422892919061539d565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051614266919061520b565b6000604051808303816000865af19150503d80600081146142a3576040519150601f19603f3d011682016040523d82523d6000602084013e6142a8565b606091505b50915091508180156142d25750805115806142d25750808060200190518101906142d29190615014565b6114805760405162461bcd60e51b815260206004820152600260248201526114d560f21b6044820152606401610e47565b6060612158848460008561432b565b60608315614321575081610d60565b610d6083836143fb565b60608247101561438c5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610e47565b600080866001600160a01b031685876040516143a8919061520b565b60006040518083038185875af1925050503d80600081146143e5576040519150601f19603f3d011682016040523d82523d6000602084013e6143ea565b606091505b509150915061107787838387614425565b81511561440b5781518083602001fd5b8060405162461bcd60e51b8152600401610e47919061477e565b6060831561449257825160000361448b5761443f85612c81565b61448b5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610e47565b5081612158565b61215883836143fb565b6000602082840312156144ae57600080fd5b81356001600160e01b031981168114610d6057600080fd5b6001600160a01b03811681146111c157600080fd5b6000602082840312156144ed57600080fd5b8135610d60816144c6565b80151581146111c157600080fd5b8035614511816144f8565b919050565b6000806040838503121561452957600080fd5b8235614534816144c6565b91506020830135614544816144f8565b809150509250929050565b6001600160a01b03169052565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b038111828210171561459a5761459a61455c565b604052919050565b60006001600160401b038211156145bb576145bb61455c565b50601f01601f191660200190565b600082601f8301126145da57600080fd5b81356145ed6145e8826145a2565b614572565b81815284602083860101111561460257600080fd5b816020850160208301376000918101602001919091529392505050565b600060a0828403121561463157600080fd5b60405160a081016001600160401b0380821183831017156146545761465461455c565b8160405282935084359150614668826144c6565b818352602085013560208401526040850135604084015260608501356060840152608085013591508082111561469d57600080fd5b506146aa858286016145c9565b6080830152505092915050565b6000806000606084860312156146cc57600080fd5b83356001600160401b03808211156146e357600080fd5b6146ef8783880161461f565b945060208601359150614701826144c6565b9092506040850135908082111561471757600080fd5b50614724868287016145c9565b9150509250925092565b60005b83811015614749578181015183820152602001614731565b50506000910152565b6000815180845261476a81602086016020860161472e565b601f01601f19169290920160200192915050565b602081526000610d606020830184614752565b60008083601f8401126147a357600080fd5b5081356001600160401b038111156147ba57600080fd5b6020830191508360208285010111156147d257600080fd5b9250929050565b600080600080600080600080600060c08a8c0312156147f757600080fd5b8935614802816144c6565b985060208a0135614812816144c6565b975060408a0135965060608a01356001600160401b038082111561483557600080fd5b6148418d838e01614791565b909850965060808c013591508082111561485a57600080fd5b6148668d838e01614791565b909650945060a08c013591508082111561487f57600080fd5b5061488c8c828d01614791565b915080935050809150509295985092959850929598565b6000602082840312156148b557600080fd5b5035919050565b6001600160a01b0391909116815260200190565b600080604083850312156148e357600080fd5b823591506020830135614544816144c6565b600080600080600080600060a0888a03121561491057600080fd5b873561491b816144c6565b9650602088013561492b816144c6565b95506040880135945060608801356001600160401b038082111561494e57600080fd5b61495a8b838c01614791565b909650945060808a013591508082111561497357600080fd5b506149808a828b01614791565b989b979a50959850939692959293505050565b6000608082840312156149a557600080fd5b604051608081016001600160401b03811182821017156149c7576149c761455c565b60405290508082356149d8816144c6565b815260208301356149e8816144c6565b602082015260408301356149fb816144c6565b60408201526060830135614a0e816144c6565b6060919091015292915050565b63ffffffff811681146111c157600080fd5b803561451181614a1b565b600060e08284031215614a4a57600080fd5b60405160e081016001600160401b0381118282101715614a6c57614a6c61455c565b6040529050808235614a7d81614a1b565b81526020830135614a8d81614a1b565b60208201526040830135614aa081614a1b565b60408201526060830135614ab3816144f8565b606082015260808381013590820152614ace60a08401614a2d565b60a0820152614adf60c08401614506565b60c08201525092915050565b600060608284031215614afd57600080fd5b604051606081016001600160401b0381118282101715614b1f57614b1f61455c565b6040529050808235614b3081614a1b565b8152602083810135908201526040830135614b4a81614a1b565b6040919091015292915050565b6000806000806101e08587031215614b6e57600080fd5b614b788686614993565b9350614b878660808701614a38565b9250614b97866101608701614aeb565b91506101c0850135614ba8816144c6565b939692955090935050565b60008060408385031215614bc657600080fd5b8235614bd1816144c6565b915060208301356001600160401b03811115614bec57600080fd5b614bf8858286016145c9565b9150509250929050565b600060808284031215614c1457600080fd5b610d608383614993565b6000806101408385031215614c3257600080fd5b614c3c8484614a38565b9150614c4b8460e08501614aeb565b90509250929050565b600080600060608486031215614c6957600080fd5b8335614c74816144c6565b92506020840135915060408401356001600160401b03811115614c9657600080fd5b614724868287016145c9565b60008060008060608587031215614cb857600080fd5b8435614cc3816144c6565b93506020850135925060408501356001600160401b03811115614ce557600080fd5b614cf187828801614791565b95989497509550505050565b600060208284031215614d0f57600080fd5b81356001600160401b03811115614d2557600080fd5b612158848285016145c9565b6001600160a01b0392831681529116602082015260400190565b600080600060608486031215614d6057600080fd5b8335614d6b816144c6565b925060208401356001600160401b0380821115614d8757600080fd5b614d938783880161461f565b9350604086013591508082111561471757600080fd5b634e487b7160e01b600052601160045260246000fd5b81810381811115610c1b57610c1b614da9565b8082028115828204841417610c1b57610c1b614da9565b80820180821115610c1b57610c1b614da9565b60018060a01b0381511682526020810151602083015260408101516040830152606081015160608301526000608082015160a0608085015261215860a0850182614752565b600060018060a01b03808716835260806020840152614e636080840187614dfc565b9481166040840152929092166060909101525092915050565b600060208284031215614e8e57600080fd5b5051919050565b60008060408385031215614ea857600080fd5b8235614eb3816144c6565b91506020830135614544816144c6565b80600b0b81146111c157600080fd5b60008060408385031215614ee557600080fd5b8235614ef081614ec3565b946020939093013593505050565b6020808252602c9082015260008051602061543783398151915260408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c9082015260008051602061543783398151915260408201526b6163746976652070726f787960a01b606082015260800190565b600082614f8f57634e487b7160e01b600052601260045260246000fd5b500490565b60008060408385031215614fa757600080fd5b82359150602083013561454481614ec3565b600060208284031215614fcb57600080fd5b8151610d60816144c6565b6001600160a01b03858116825284811660208301528316604082015260806060820181905260009061500a90830184614752565b9695505050505050565b60006020828403121561502657600080fd5b8151610d60816144f8565b825481526001830154602082015260028301546040820152600383015461012082019061506a606084016001600160a01b03831661454f565b61507c608084018260a01d600b0b9052565b5060048401546001600160a01b031661509860a084018261454f565b50600584015460c0830152600684015460e0830152610d6061010083018461454f565b600080600080600080600060e0888a0312156150d657600080fd5b8751965060208801519550604088015194506060880151935060808801516150fd81614ec3565b60a089015190935061510e81614ec3565b60c089015190925061511f81614ec3565b8091505092959891949750929550565b600060018060a01b03808816835260a0602084015261515160a0840188614dfc565b9581166040840152938416606083015250911660809091015292915050565b63ffffffff8281168282160390808211156121f0576121f0614da9565b63ffffffff8181168382160190808211156121f0576121f0614da9565b6001600160a01b0393841681529183166020830152909116604082015260600190565b600080600080608085870312156151e357600080fd5b8451935060208501516151f581614ec3565b6040860151606090960151949790965092505050565b6000825161521d81846020870161472e565b9190910192915050565b60006020828403121561523957600080fd5b8151610d6081614a1b565b600b82810b9082900b0360016001605f1b0319811260016001605f1b0382131715610c1b57610c1b614da9565b8781526001600160a01b03878116602083015286811660408301528516606082015263ffffffff84166080820152600b83900b60a082015260e060c08201819052600090610f3d90830184614752565b6000602082840312156152d357600080fd5b81516001600160401b038111156152e957600080fd5b8201601f810184136152fa57600080fd5b80516153086145e8826145a2565b81815285602083850101111561531d57600080fd5b61390082602083016020860161472e565b76020b1b1b2b9b9a1b7b73a3937b61d1030b1b1b7bab73a1604d1b81526000835161536081601785016020880161472e565b7001034b99036b4b9b9b4b733903937b6329607d1b601791840191820152835161539181602884016020880161472e565b01602801949350505050565b6001600160a01b03929092168252602082015260400190565b634e487b7160e01b600052600160045260246000fd5b6000602082840312156153de57600080fd5b8151610d6081614ec3565b634e487b7160e01b600052603260045260246000fd5b60008161540e5761540e614da9565b50600019019056fea9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd346756e6374696f6e206d7573742062652063616c6c6564207468726f75676820360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564829b824e2329e205435d941c9f13baf578548505283d29261236d8e6596d4636a26469706673582212202027bee3227ca3087d63c709f33bf82f06c231fe331f6c012104a28220589f9e64736f6c63430008130033",
  "deployedBytecode": "0x60806040526004361061027b5760003560e01c806301ffc9a7146102805780630b1ca49a146102b55780630c710776146102d75780630ce82d67146103035780630e0cc1b91461032657806319805538146103465780631a2a84b31461037f5780631a787f2e1461039f5780631db128c7146103bf578063200d2ed2146103ec578063230dbd291461046e578063248a9ca31461048e578063298052df146104ae5780632b4116f7146104c35780632f2ff15d146104f057806330d9c9151461051057806336568abe146105305780633659cfe6146105505780633e6968b61461057057806346b6a742146105855780634e71d92d146105a55780634f1ef286146105ba57806352d1902d146105cd57806353c11f99146105e2578063598f8fbf146106025780635a4c5152146106225780635ab1bd53146106b95780635da93292146106ce5780635f9e7d77146106e35780636180c79314610703578063647c75e21461072357806372ca8a3e1461079457806373b2e80e146107b4578063791ea89b146107d45780637b103999146107f457806388480f0c14610815578063884d1f401461086757806391d148541461088757806398d6621b146108a75780639f8fddd2146108bc578063a10f469e146108dc578063a217fddf146108fe578063a4c0ed3614610913578063ae82720014610933578063bcb4546f14610946578063c31c9c0714610968578063c77138701461099c578063d3112b2e146109b1578063d547741f146109e6578063d80528ae14610a06578063d86ed3e514610a97578063dc61d5c214610ab7578063def482a414610b0a578063e06174e414610b2a578063ec87621c14610b94578063f437bc5914610bb6575b600080fd5b34801561028c57600080fd5b506102a061029b36600461449c565b610bea565b60405190151581526020015b60405180910390f35b3480156102c157600080fd5b506102d56102d03660046144db565b610c21565b005b3480156102e357600080fd5b506102f06459df64940081565b604051600b9190910b81526020016102ac565b34801561030f57600080fd5b50610318610c55565b6040519081526020016102ac565b34801561033257600080fd5b506102d5610341366004614516565b610c73565b34801561035257600080fd5b5061035b610ca8565b604080516001600160a01b03909316835263ffffffff9091166020830152016102ac565b34801561038b57600080fd5b5061031861039a3660046144db565b610cc7565b3480156103ab57600080fd5b506103186103ba3660046144db565b610d67565b3480156103cb57600080fd5b506103df6103da3660046146b7565b610de2565b6040516102ac919061477e565b3480156103f857600080fd5b5061013a5461013b5461013c5461013d5461013e5461013f54610140546101425461042d979695949392919063ffffffff1688565b604080519889526020890197909752958701949094526060860192909252608085015260a084015260c083015263ffffffff1660e0820152610100016102ac565b34801561047a57600080fd5b506103df6104893660046147d9565b610f03565b34801561049a57600080fd5b506103186104a93660046148a3565b610f4a565b3480156104ba57600080fd5b50610318610f5f565b3480156104cf57600080fd5b506097546104e3906001600160a01b031681565b6040516102ac91906148bc565b3480156104fc57600080fd5b506102d561050b3660046148d0565b610f9e565b34801561051c57600080fd5b506103df61052b3660046148f5565b610fbf565b34801561053c57600080fd5b506102d561054b3660046148d0565b611082565b34801561055c57600080fd5b506102d561056b3660046144db565b6110fc565b34801561057c57600080fd5b506103186111c4565b34801561059157600080fd5b506102d56105a0366004614b57565b6111e0565b3480156105b157600080fd5b506102d5611487565b6102d56105c8366004614bb3565b611494565b3480156105d957600080fd5b50610318611549565b3480156105ee57600080fd5b506103df6105fd3660046147d9565b6115f7565b34801561060e57600080fd5b506102d561061d366004614c02565b6116d4565b34801561062e57600080fd5b506101375461013854610139546106749263ffffffff80821693600160201b808404831694600160401b850484169460ff600160601b9091048116948216929091041687565b6040805163ffffffff98891681529688166020880152948716948601949094529115156060850152608084015290921660a082015290151560c082015260e0016102ac565b3480156106c557600080fd5b506104e3611809565b3480156106da57600080fd5b50610318611819565b3480156106ef57600080fd5b506103df6106fe3660046148f5565b6119d1565b34801561070f57600080fd5b506102a061071e366004614bb3565b611ab6565b34801561072f57600080fd5b5061076d61073e3660046144db565b60986020526000908152604090208054600190910154600b81900b90600160601b90046001600160801b031683565b60408051938452600b9290920b60208401526001600160801b0316908201526060016102ac565b3480156107a057600080fd5b506102a06107af3660046144db565b611cb3565b3480156107c057600080fd5b506102a06107cf3660046144db565b611cc7565b3480156107e057600080fd5b506102d56107ef366004614c1e565b611d6a565b34801561080057600080fd5b50610143546104e3906001600160a01b031681565b34801561082157600080fd5b506101445461014554610146546108409263ffffffff90811692911683565b6040805163ffffffff948516815260208101939093529216918101919091526060016102ac565b34801561087357600080fd5b506103df6108823660046148f5565b611efa565b34801561089357600080fd5b506102a06108a23660046148d0565b611ff7565b3480156108b357600080fd5b50610318612022565b3480156108c857600080fd5b506103df6108d7366004614c54565b61202d565b3480156108e857600080fd5b506103186000805160206154be83398151915281565b34801561090a57600080fd5b50610318600081565b34801561091f57600080fd5b506102a061092e366004614ca2565b6120e7565b6102d5610941366004614cfd565b612160565b34801561095257600080fd5b5061031860008051602061541783398151915281565b34801561097457600080fd5b506104e37f000000000000000000000000000000000000000000000000000000000000000081565b3480156109a857600080fd5b506103186121e6565b3480156109bd57600080fd5b50609954609a546109d8916001600160a01b03908116911682565b6040516102ac929190614d31565b3480156109f257600080fd5b506102d5610a013660046148d0565b6121f7565b348015610a1257600080fd5b50609b54609c54609d54609e54609f5460a05460a154610a4d969594936001600160a01b0380821694600160a01b909204600b0b9391169188565b604080519889526020890197909752958701949094526001600160a01b039283166060870152600b9190910b60808601521660a084015260c083015260e0820152610100016102ac565b348015610aa357600080fd5b506103df610ab23660046147d9565b612213565b348015610ac357600080fd5b50610acc612241565b604080519788526020880196909652948601939093526060850191909152600b90810b608085015290810b60a08401520b60c082015260e0016102ac565b348015610b1657600080fd5b506103df610b25366004614d4b565b6122ec565b348015610b3657600080fd5b5061013354610134546101355461013654610b61936001600160a01b03908116938116928116911684565b604080516001600160a01b03958616815293851660208501529184169183019190915290911660608201526080016102ac565b348015610ba057600080fd5b5061031860008051602061547783398151915281565b348015610bc257600080fd5b506104e37f000000000000000000000000000000000000000000000000000000000000000081565b60006001600160e01b03198216637965db0b60e01b1480610c1b57506301ffc9a760e01b6001600160e01b03198316145b92915050565b600080516020615477833981519152610c398161253f565b610c516000805160206154be83398151915283612549565b5050565b61013d54600090610c646111c4565b610c6e9190614dbf565b905090565b61013754600160601b900460ff16610c9e576040516369973f2560e11b815260040160405180910390fd5b610c518282612629565b61013354610146546001600160a01b039091169163ffffffff90911690565b6001600160a01b0381166000908152609860209081526040808320815160608101835281548152600190910154600b81900b938201849052600160601b90046001600160801b031691810191909152908203610d24575192915050565b6040810151610d3c906001600160801b031642614dbf565b81602001516001600160601b0316610d549190614dd2565b8151610d609190614de9565b9392505050565b6000610d716111c4565b61013a54148015610d84575061013b5415155b15610dda576101445463ffffffff1615801590610daf57506101445461013f5463ffffffff90911611155b15610dbc57506000919050565b610dc582611cc7565b610dd25761013b54610c1b565b600092915050565b610c1b6121e6565b606082336001600160a01b03821614801590610e275750336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614155b15610e50573360405163087231bf60e31b8152600401610e4791906148bc565b60405180910390fd5b6097546040516358c0dacb60e01b815273__$0d78a42341742155da77b97d7f993534c7$__916358c0dacb91610eb8917f0000000000000000000000000000000000000000000000000000000000000000918a916001600160a01b0316908a90600401614e41565b602060405180830381865af4158015610ed5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ef99190614e7c565b5091949350505050565b60606000610f1387890189614e95565b509050600080610f2587890189614ed2565b91509150610f378d8484848a8a6128ce565b93505050505b9998505050505050505050565b60009081526065602052604090206001015490565b61013754600090600160201b900463ffffffff16610f7b6111c4565b610f859190614de9565b610f929062015180614dd2565b610c6e9061a8c0614de9565b610fa782610f4a565b610fb08161253f565b610fba8383612915565b505050565b6060336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461100a57604051632f2d36a760e01b815260040160405180910390fd5b61101387612a3b565b6110365750604080518082019091526002815261060f60f31b6020820152611077565b61103f88611cb3565b61105c57604051631ea25bab60e31b815260040160405180910390fd5b50604080518082019091526002815261060f60f31b60208201525b979650505050505050565b6001600160a01b03811633146110f25760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b6064820152608401610e47565b610c518282612549565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036111445760405162461bcd60e51b8152600401610e4790614efe565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316611176612aef565b6001600160a01b03161461119c5760405162461bcd60e51b8152600401610e4790614f38565b6111a581612b0b565b604080516000808252602082019092526111c191839190612b16565b50565b6000620151806111d661a8c042614dbf565b610c6e9190614f72565b600054610100900460ff16158080156112005750600054600160ff909116105b80611221575061120f30612c81565b158015611221575060005460ff166001145b6112845760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610e47565b6000805460ff1916600117905580156112a7576000805461ff0019166101001790555b61014380546001600160a01b03199081166001600160a01b038581169190911790925586516101338054831691841691909117905560208088015161013480548416918516919091179055604080890151610135805485169186169190911790556060808a0151610136805490951695169490941790925586516101378054898401518a860151968b015163ffffffff9485166001600160401b031990931692909217600160201b91851682021764ffffffffff60401b1916600160401b9785169790970260ff60601b191696909617600160601b9115159190910217905560808801516101385560a0880151610139805460c08b015192841664ffffffffff1990911617911515909502179093558551610144805463ffffffff19908116928616929092179055908601516101455590850151610146805490921692169190911790556113f485612c90565b6113fd84612ce6565b611408600033612d3d565b6114246000805160206154778339815191528660000151612d3d565b6101365461143a906001600160a01b0316612d47565b8015611480576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b611492336001612629565b565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036114dc5760405162461bcd60e51b8152600401610e4790614efe565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661150e612aef565b6001600160a01b0316146115345760405162461bcd60e51b8152600401610e4790614f38565b61153d82612b0b565b610c5182826001612b16565b6000306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146115e45760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c6044820152771b1959081d1a1c9bdd59da0819195b1959d85d1958d85b1b60421b6064820152608401610e47565b5060008051602061545783398151915290565b6060336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016141580611637575061163589612a3b565b155b8061164857506116468a611cb3565b155b1561168c5782828080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929350610f3d92505050565b60008061169b888a018a614e95565b90925090506000806116af888a018a614f94565b915091506116c28e858584868c8c612e6c565b9e9d5050505050505050505050505050565b6000805160206154778339815191526116ec8161253f565b6116f582612c90565b6101335482516001600160a01b0390811691161461174f576101335461173390600080516020615477833981519152906001600160a01b0316612549565b61174f6000805160206154778339815191528360000151612d3d565b815161013380546001600160a01b03199081166001600160a01b03938416908117909255602080860180516101348054851691871691909117905560408088018051610135805487169189169190911790556060808a0180516101368054909816908a161790965582519687529251871693860193909352915185168483015291519093169082015290517fc5e56c36231b7247b96ddd6a7e47b60748a332bcb3a514d016fd2e74d9159351916080908290030190a15050565b610143546001600160a01b031690565b6000806118246111c4565b6101375461013a5491925061184791600160201b90910463ffffffff1690614de9565b81106119c857600080600061185a612ebf565b925092509250801561194357610136546040516370a0823160e01b81526000916001600160a01b0316906370a08231906118989030906004016148bc565b602060405180830381865afa1580156118b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118d99190614e7c565b61013c8590556101375463ffffffff1661013e81905561013d879055604080518881526020810184905290810191909152606081018690529091507f83e0d535b9e84324e0a25922406398d6ff5f96d0c686204ee490e16d7670566f9060800160405180910390a1505b61013a84905561013b82905561014554821161196057600061013b555b61013b5461013f5461014054604080518881526020810194909452438482015260608401929092526080830152517fdd2b882b89647cd6c5641ce6ab9d46f1c17865d2b22f065850f30f83cc7d8cf89181900360a00190a15050600061013f81905561014055505b505061013b5490565b6060336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016141580611a115750611a0f87612a3b565b155b80611a225750611a2088611cb3565b155b15611a465750604080518082019091526002815261060f60f31b6020820152611077565b600080611a5586880188614e95565b9092509050600080611a716001600160a01b038d168585613071565b5050915091508181604051602001611a96929190918252600b0b602082015260400190565b604051602081830303815290604052945050505050979650505050505050565b610135546000906001600160a01b031615611b6b57610135546040516316874da360e11b81526000916001600160a01b031690632d0e9b4690611afd9087906004016148bc565b602060405180830381865afa158015611b1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b3e9190614fb9565b90506001600160a01b038116611b695783604051630b7b234960e01b8152600401610e4791906148bc565b505b610134546001600160a01b031615801590611b9b5750611b9960008051602061547783398151915233611ff7565b155b15611c4357610134546040516356a42afd60e11b81526001600160a01b039091169063ad4855fa90611bd7903090339088908890600401614fd6565b6020604051808303816000875af1158015611bf6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c1a9190615014565b1515600003611c3e578260405163130f4a3760e11b8152600401610e4791906148bc565b611c92565b61013954600160201b900460ff168015611c725750611c7060008051602061547783398151915233611ff7565b155b15611c925782604051636f6acad560e01b8152600401610e4791906148bc565b611caa6000805160206154be83398151915284612915565b50600192915050565b6097546001600160a01b0390811691161490565b610135546040516316874da360e11b815260009182916001600160a01b0390911690632d0e9b4690611cfd9086906004016148bc565b602060405180830381865afa158015611d1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d3e9190614fb9565b9050611d486111c4565b6001600160a01b03909116600090815261014160205260409020541492915050565b600080516020615477833981519152611d828161253f565b611d8b83612ce6565b8251610137805460208087015160408089015160608a01511515600160601b0260ff60601b1963ffffffff928316600160401b021664ffffffffff60401b19948316600160201b9081026001600160401b0319909816998416999099179690961793909316949094179190911790935560808701516101385560a0870151610139805460c08a0151151590960264ffffffffff1990961691841691909117949094179093558451610144805491831663ffffffff19928316179055928501516101455584820151610146805491909216931692909217909155517f9c2d0f3e240667c2b704104ff988af37be9eb4befb81fe00424626b088ee757990611eed908590600060e08201905063ffffffff808451168352806020850151166020840152806040850151166040840152606084015115156060840152608084015160808401528060a08501511660a08401525060c0830151151560c083015292915050565b60405180910390a1505050565b6060336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614611f4557604051632f2d36a760e01b815260040160405180910390fd5b611f4e87612a3b565b611f715750604080518082019091526002815261060f60f31b6020820152611077565b611f7a88611cb3565b611f9757604051631ea25bab60e31b815260040160405180910390fd5b6000611fa585870187614e95565b509050600080611fbf6001600160a01b038c168430613071565b505060408051600b9290920b60208301528181019290925281518082038301815260609091019091529b9a5050505050505050505050565b60009182526065602090815260408084206001600160a01b0393909316845291905290205460ff1690565b6000610c6e33610d67565b606083336001600160a01b038216148015906120725750336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614155b15612092573360405163087231bf60e31b8152600401610e4791906148bc565b836000036120b357604051630f6fa54560e41b815260040160405180910390fd5b6097546120cb906001600160a01b0316863087613109565b610ef98585600060405180602001604052806000815250613213565b6097546000906001600160a01b0316331461211557604051630ce706f760e41b815260040160405180910390fd5b8360000361213657604051630f6fa54560e41b815260040160405180910390fd5b6121528585600060405180602001604052806000815250613213565b50600190505b949350505050565b6101435460408051638abf607760e01b815290516000926001600160a01b031691638abf60779160048083019260209291908290030181865afa1580156121ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121cf9190614fb9565b90506121da81612b0b565b610c5181836000612b16565b60006121f0612ebf565b5092915050565b61220082610f4a565b6122098161253f565b610fba8383612549565b6060600061222387890189614e95565b5090506122328b8286866138bb565b9b9a5050505050505050505050565b60975460405163b2f918a160e01b815260009182918291829182918291829173__$0d78a42341742155da77b97d7f993534c7$__9163b2f918a19161229591609b916001600160a01b031690600401615031565b60e060405180830381865af41580156122b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122d691906150bb565b959d949c50929a50909850965094509092509050565b606083336001600160a01b038216148015906123315750336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614155b15612351573360405163087231bf60e31b8152600401610e4791906148bc565b6097546040516370a0823160e01b81526000916001600160a01b0316906370a08231906123829030906004016148bc565b602060405180830381865afa15801561239f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123c39190614e7c565b6097546040516321437a5360e01b815291925073__$0d78a42341742155da77b97d7f993534c7$__916321437a5391612432917f0000000000000000000000000000000000000000000000000000000000000000918a916001600160a01b03909116908c90309060040161512f565b602060405180830381865af415801561244f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124739190614e7c565b506097546040516370a0823160e01b815260009183916001600160a01b03909116906370a08231906124a99030906004016148bc565b602060405180830381865afa1580156124c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124ea9190614e7c565b6124f49190614dbf565b90508060000361251757604051630f6fa54560e41b815260040160405180910390fd5b6125338782600060405180602001604052806000815250613213565b50939695505050505050565b6111c18133613909565b6000805160206154be8339815191528214801561257957506125796000805160206154be83398151915282611ff7565b1561261f5761014280546001919060009061259b90849063ffffffff16615170565b825463ffffffff9182166101009390930a9283029190920219909116179055506101435460405163058e524d60e11b81526001600160a01b0390911690630b1ca49a906125ec9084906004016148bc565b600060405180830381600087803b15801561260657600080fd5b505af115801561261a573d6000803e3d6000fd5b505050505b610c518282613962565b610135546040516316874da360e11b81526000916001600160a01b031690632d0e9b469061265b9086906004016148bc565b602060405180830381865afa158015612678573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061269c9190614fb9565b90506001600160a01b0381166126c75782604051630b7b234960e01b8152600401610e4791906148bc565b6101395463ffffffff16158015906126ea575061013954600160201b900460ff16155b15612707576127076000805160206154be83398151915284612915565b6101395463ffffffff16151580612728575061013954600160201b900460ff165b801561274957506127476000805160206154be83398151915284611ff7565b155b15612769578260405163130f4a3760e11b8152600401610e4791906148bc565b6101445463ffffffff161580159061278f57506101445461013f5463ffffffff90911611155b156127b55761013f54604051635136bc3160e01b81526004810191909152602401610e47565b60006127bf611819565b61013a546001600160a01b0384166000908152610141602052604090205491925090036128015781604051631fc1cabf60e31b8152600401610e4791906148bc565b61013a546001600160a01b0383166000908152610141602052604081209190915561013f805460019290612836908490614de9565b90915550506101408054829190600090612851908490614de9565b9091555061287b9050836128655784612867565b825b610136546001600160a01b031690836139c9565b836001600160a01b0316826001600160a01b03167f1c0764b87f885ff7e1be5f7c06a0cc99c5bdc0f7b4884440e6ebe5b12bfd511d836040516128c091815260200190565b60405180910390a350505050565b60606110778686600b0b8686868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061321392505050565b6000805160206154be8339815191528214801561294757506129456000805160206154be83398151915282611ff7565b155b15612a31576101395463ffffffff16158015906129735750610139546101425463ffffffff9182169116115b1561299157604051632263c94160e01b815260040160405180910390fd5b6101435460405163329b55b760e21b81526001600160a01b039091169063ca6d56dc906129c29084906004016148bc565b600060405180830381600087803b1580156129dc57600080fd5b505af11580156129f0573d6000803e3d6000fd5b5050610142805460019350909150600090612a1290849063ffffffff1661518d565b92506101000a81548163ffffffff021916908363ffffffff1602179055505b610c518282613a1f565b604051635b69006f60e11b815260008051602061541783398151915260048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063b6d200de90602401602060405180830381865afa158015612ab0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ad49190614fb9565b6001600160a01b0316826001600160a01b0316149050919050565b600080516020615457833981519152546001600160a01b031690565b6000610c518161253f565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff1615612b4957610fba83613aa5565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015612ba3575060408051601f3d908101601f19168201909252612ba091810190614e7c565b60015b612c065760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b6064820152608401610e47565b6000805160206154578339815191528114612c755760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b6064820152608401610e47565b50610fba838383613b3f565b6001600160a01b03163b151590565b80516001600160a01b03161580612cb2575060408101516001600160a01b0316155b80612cc8575060608101516001600160a01b0316155b156111c157604051631e597d8360e11b815260040160405180910390fd5b602081015163ffffffff161580612d025750805163ffffffff16155b80612d155750604081015163ffffffff16155b80612cc8575060808101516111c157604051631e597d8360e11b815260040160405180910390fd5b610c518282612915565b6001600160a01b038116612d6e5760405163538ba4f960e01b815260040160405180910390fd5b609780546001600160a01b0319166001600160a01b03838116919091179091556040805180820182527f00000000000000000000000000000000000000000000000000000000000000009092168083529051635b69006f60e11b8152600080516020615417833981519152600482015260208301919063b6d200de90602401602060405180830381865afa158015612e0a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e2e9190614fb9565b6001600160a01b039081169091528151609980546001600160a01b0319908116928416929092179055602090920151609a8054909316911617905550565b6060612eb38786600b0b8686868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061321392505050565b98975050505050505050565b610136546040516370a0823160e01b81526000918291829182916001600160a01b03909116906370a0823190612ef99030906004016148bc565b602060405180830381865afa158015612f16573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f3a9190614e7c565b61013754909150600090612f549063ffffffff1683614f72565b90506000606461013a600201546069612f6d9190614dd2565b612f779190614f72565b821180612fbb575061013e54612f8b610c55565b11158015612fbb5750612f9c610c55565b61013e54612faa9190614dbf565b61013c54612fb89190614dd2565b83105b61013c5461013e54909750909150612fd1610c55565b612fdc906001614de9565b101580612fe65750805b156130065761013754612fff9063ffffffff1684614f72565b9550600193505b6101385461013f546130569190613047906127109061302790612904614dd2565b6130319190614f72565b61013754600160401b900463ffffffff16613b6a565b6130519089614f72565b613b81565b6101455490955085101561306957600094505b505050909192565b600080600080600061308288613b90565b604051631cd43d1160e31b81529092506001600160a01b038316915063e6a1e888906130b6908b908b908b906004016151aa565b608060405180830381865afa1580156130d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130f791906151cd565b929b919a509850909650945050505050565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b179052915160009283929088169161316d919061520b565b6000604051808303816000865af19150503d80600081146131aa576040519150601f19603f3d011682016040523d82523d6000602084013e6131af565b606091505b50915091508180156131d95750805115806131d95750808060200190518101906131d99190615014565b61320b5760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b6044820152606401610e47565b505050505050565b805181901515600080613224610ca8565b609754919350915073__$0d78a42341742155da77b97d7f993534c7$__9063934e2cce90609b906001600160a01b031661325c611809565b8588613268578c61326b565b60005b6040516001600160e01b031960e088901b16815260048101959095526001600160a01b03938416602486015292909116604484015263ffffffff166064830152608482015260a40160006040518083038186803b1580156132cb57600080fd5b505af41580156132df573d6000803e3d6000fd5b5050609754600092506132fd91506001600160a01b03168a30613cff565b6001600160a01b038a1660009081526098602052604090205490915084156136f257600082600b0b13801561333a57506459df649400600b83900b125b1561335d57604051624963df60e91b8152600b83900b6004820152602401610e47565b6001600160a01b038a16600090815260986020526040902060010180546001600160e01b031916600160601b426001600160801b038116919091026001600160601b031916919091176001600160601b038516179091556133bf908990614dbf565b6133c9908a614dd2565b6001600160a01b038b16600090815260986020526040812080549091906133f1908490614de9565b9091555060009050613401611809565b6001600160a01b0316146135c457613417611809565b6001600160a01b031663469048406040518163ffffffff1660e01b8152600401602060405180830381865afa158015613454573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134789190614fb9565b9350613482611809565b6001600160a01b03166324a9d8536040518163ffffffff1660e01b8152600401602060405180830381865afa1580156134bf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134e39190615227565b925073__$0d78a42341742155da77b97d7f993534c7$__634d167a906099609760009054906101000a90046001600160a01b0316609b60030160009054906101000a90046001600160a01b031688888f8961353e9190615244565b8d6040518863ffffffff1660e01b81526004016135619796959493929190615271565b600060405180830381865af415801561357e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526135a691908101906152c1565b609e80546001600160a01b0319166001600160a01b03871617905595505b6135cc610ca8565b809450819550505073__$0d78a42341742155da77b97d7f993534c7$__634d167a906099609760009054906101000a90046001600160a01b0316609b60040160009054906101000a90046001600160a01b031688888f8961362d9190615244565b8d6040518863ffffffff1660e01b81526004016136509796959493929190615271565b600060405180830381865af415801561366d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261369591908101906152c1565b609f80546001600160a01b0319166001600160a01b03878116919091179091556097549197506136c6911630613d8d565b609e80546001600160601b0392909216600160a01b026001600160a01b03909216919091179055613831565b60006136fc611809565b6001600160a01b0316146137eb57613712611809565b6001600160a01b031663469048406040518163ffffffff1660e01b8152600401602060405180830381865afa15801561374f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137739190614fb9565b935061377d611809565b6001600160a01b03166324a9d8536040518163ffffffff1660e01b8152600401602060405180830381865afa1580156137ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137de9190615227565b92506137eb84848b613e0c565b6137f3610ca8565b909450925061380384848b613e0c565b6001600160a01b038a16600090815260986020526040812080548b929061382b908490614de9565b90915550505b6001600160a01b038a166000818152609860205260409020547f6342e11b65ccb38a3bb259be9cda846c74ad52b36b62a2ee4799dc3db63a04a39083908861387a57600061387c565b8c5b604080519384526020840192909252600b90810b8383015286900b60608301528815156080830152519081900360a00190a25050505050949350505050565b60606139008460008086868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061321392505050565b95945050505050565b6139138282611ff7565b610c515761392081613e58565b61392b836020613e6a565b60405160200161393c92919061532e565b60408051601f198184030181529082905262461bcd60e51b8252610e479160040161477e565b61396c8282611ff7565b15610c515760008281526065602090815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b610fba8363a9059cbb60e01b84846040516024016139e892919061539d565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152614005565b613a298282611ff7565b610c515760008281526065602090815260408083206001600160a01b03851684529091529020805460ff19166001179055613a613390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b613aae81612c81565b613b105760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b6064820152608401610e47565b60008051602061545783398151915280546001600160a01b0319166001600160a01b0392909216919091179055565b613b48836140d7565b600082511180613b555750805b15610fba57613b648383614117565b50505050565b600081831015613b7a5781610d60565b5090919050565b6000818310613b7a5781610d60565b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a546001600160a01b038116613cce576001600160a01b038216613c5557826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa158015613c2e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613c529190614fb9565b91505b604051635b69006f60e11b815260008051602061541783398151915260048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015613ca7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ccb9190614fb9565b90505b6001600160a01b038216613ce457613ce46153b6565b6001600160a01b038116613cfa57613cfa6153b6565b915091565b600080613d0b85613b90565b604051631cd43d1160e31b81529092506001600160a01b038316915063e6a1e88890613d3f908890889088906004016151aa565b608060405180830381865afa158015613d5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613d8091906151cd565b5090979650505050505050565b600080613d9984613b90565b60405163e8e7e2d160e01b81529092506001600160a01b038316915063e8e7e2d190613dcb9087908790600401614d31565b602060405180830381865afa158015613de8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061215891906153cc565b6001600160a01b038316613e1f57505050565b6000612710613e3463ffffffff851684614dd2565b613e3e9190614f72565b609754909150613b64906001600160a01b03168583614200565b6060610c1b6001600160a01b03831660145b60606000613e79836002614dd2565b613e84906002614de9565b6001600160401b03811115613e9b57613e9b61455c565b6040519080825280601f01601f191660200182016040528015613ec5576020820181803683370190505b509050600360fc1b81600081518110613ee057613ee06153e9565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110613f0f57613f0f6153e9565b60200101906001600160f81b031916908160001a9053506000613f33846002614dd2565b613f3e906001614de9565b90505b6001811115613fb6576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110613f7257613f726153e9565b1a60f81b828281518110613f8857613f886153e9565b60200101906001600160f81b031916908160001a90535060049490941c93613faf816153ff565b9050613f41565b508315610d605760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610e47565b600061405a826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166143039092919063ffffffff16565b805190915015610fba57808060200190518101906140789190615014565b610fba5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610e47565b6140e081613aa5565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b606061412283612c81565b61417d5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b6064820152608401610e47565b600080846001600160a01b031684604051614198919061520b565b600060405180830381855af49150503d80600081146141d3576040519150601f19603f3d011682016040523d82523d6000602084013e6141d8565b606091505b5091509150613900828260405180606001604052806027815260200161549760279139614312565b600080846001600160a01b031663a9059cbb60e01b858560405160240161422892919061539d565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b0319909416939093179092529051614266919061520b565b6000604051808303816000865af19150503d80600081146142a3576040519150601f19603f3d011682016040523d82523d6000602084013e6142a8565b606091505b50915091508180156142d25750805115806142d25750808060200190518101906142d29190615014565b6114805760405162461bcd60e51b815260206004820152600260248201526114d560f21b6044820152606401610e47565b6060612158848460008561432b565b60608315614321575081610d60565b610d6083836143fb565b60608247101561438c5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610e47565b600080866001600160a01b031685876040516143a8919061520b565b60006040518083038185875af1925050503d80600081146143e5576040519150601f19603f3d011682016040523d82523d6000602084013e6143ea565b606091505b509150915061107787838387614425565b81511561440b5781518083602001fd5b8060405162461bcd60e51b8152600401610e47919061477e565b6060831561449257825160000361448b5761443f85612c81565b61448b5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610e47565b5081612158565b61215883836143fb565b6000602082840312156144ae57600080fd5b81356001600160e01b031981168114610d6057600080fd5b6001600160a01b03811681146111c157600080fd5b6000602082840312156144ed57600080fd5b8135610d60816144c6565b80151581146111c157600080fd5b8035614511816144f8565b919050565b6000806040838503121561452957600080fd5b8235614534816144c6565b91506020830135614544816144f8565b809150509250929050565b6001600160a01b03169052565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b038111828210171561459a5761459a61455c565b604052919050565b60006001600160401b038211156145bb576145bb61455c565b50601f01601f191660200190565b600082601f8301126145da57600080fd5b81356145ed6145e8826145a2565b614572565b81815284602083860101111561460257600080fd5b816020850160208301376000918101602001919091529392505050565b600060a0828403121561463157600080fd5b60405160a081016001600160401b0380821183831017156146545761465461455c565b8160405282935084359150614668826144c6565b818352602085013560208401526040850135604084015260608501356060840152608085013591508082111561469d57600080fd5b506146aa858286016145c9565b6080830152505092915050565b6000806000606084860312156146cc57600080fd5b83356001600160401b03808211156146e357600080fd5b6146ef8783880161461f565b945060208601359150614701826144c6565b9092506040850135908082111561471757600080fd5b50614724868287016145c9565b9150509250925092565b60005b83811015614749578181015183820152602001614731565b50506000910152565b6000815180845261476a81602086016020860161472e565b601f01601f19169290920160200192915050565b602081526000610d606020830184614752565b60008083601f8401126147a357600080fd5b5081356001600160401b038111156147ba57600080fd5b6020830191508360208285010111156147d257600080fd5b9250929050565b600080600080600080600080600060c08a8c0312156147f757600080fd5b8935614802816144c6565b985060208a0135614812816144c6565b975060408a0135965060608a01356001600160401b038082111561483557600080fd5b6148418d838e01614791565b909850965060808c013591508082111561485a57600080fd5b6148668d838e01614791565b909650945060a08c013591508082111561487f57600080fd5b5061488c8c828d01614791565b915080935050809150509295985092959850929598565b6000602082840312156148b557600080fd5b5035919050565b6001600160a01b0391909116815260200190565b600080604083850312156148e357600080fd5b823591506020830135614544816144c6565b600080600080600080600060a0888a03121561491057600080fd5b873561491b816144c6565b9650602088013561492b816144c6565b95506040880135945060608801356001600160401b038082111561494e57600080fd5b61495a8b838c01614791565b909650945060808a013591508082111561497357600080fd5b506149808a828b01614791565b989b979a50959850939692959293505050565b6000608082840312156149a557600080fd5b604051608081016001600160401b03811182821017156149c7576149c761455c565b60405290508082356149d8816144c6565b815260208301356149e8816144c6565b602082015260408301356149fb816144c6565b60408201526060830135614a0e816144c6565b6060919091015292915050565b63ffffffff811681146111c157600080fd5b803561451181614a1b565b600060e08284031215614a4a57600080fd5b60405160e081016001600160401b0381118282101715614a6c57614a6c61455c565b6040529050808235614a7d81614a1b565b81526020830135614a8d81614a1b565b60208201526040830135614aa081614a1b565b60408201526060830135614ab3816144f8565b606082015260808381013590820152614ace60a08401614a2d565b60a0820152614adf60c08401614506565b60c08201525092915050565b600060608284031215614afd57600080fd5b604051606081016001600160401b0381118282101715614b1f57614b1f61455c565b6040529050808235614b3081614a1b565b8152602083810135908201526040830135614b4a81614a1b565b6040919091015292915050565b6000806000806101e08587031215614b6e57600080fd5b614b788686614993565b9350614b878660808701614a38565b9250614b97866101608701614aeb565b91506101c0850135614ba8816144c6565b939692955090935050565b60008060408385031215614bc657600080fd5b8235614bd1816144c6565b915060208301356001600160401b03811115614bec57600080fd5b614bf8858286016145c9565b9150509250929050565b600060808284031215614c1457600080fd5b610d608383614993565b6000806101408385031215614c3257600080fd5b614c3c8484614a38565b9150614c4b8460e08501614aeb565b90509250929050565b600080600060608486031215614c6957600080fd5b8335614c74816144c6565b92506020840135915060408401356001600160401b03811115614c9657600080fd5b614724868287016145c9565b60008060008060608587031215614cb857600080fd5b8435614cc3816144c6565b93506020850135925060408501356001600160401b03811115614ce557600080fd5b614cf187828801614791565b95989497509550505050565b600060208284031215614d0f57600080fd5b81356001600160401b03811115614d2557600080fd5b612158848285016145c9565b6001600160a01b0392831681529116602082015260400190565b600080600060608486031215614d6057600080fd5b8335614d6b816144c6565b925060208401356001600160401b0380821115614d8757600080fd5b614d938783880161461f565b9350604086013591508082111561471757600080fd5b634e487b7160e01b600052601160045260246000fd5b81810381811115610c1b57610c1b614da9565b8082028115828204841417610c1b57610c1b614da9565b80820180821115610c1b57610c1b614da9565b60018060a01b0381511682526020810151602083015260408101516040830152606081015160608301526000608082015160a0608085015261215860a0850182614752565b600060018060a01b03808716835260806020840152614e636080840187614dfc565b9481166040840152929092166060909101525092915050565b600060208284031215614e8e57600080fd5b5051919050565b60008060408385031215614ea857600080fd5b8235614eb3816144c6565b91506020830135614544816144c6565b80600b0b81146111c157600080fd5b60008060408385031215614ee557600080fd5b8235614ef081614ec3565b946020939093013593505050565b6020808252602c9082015260008051602061543783398151915260408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c9082015260008051602061543783398151915260408201526b6163746976652070726f787960a01b606082015260800190565b600082614f8f57634e487b7160e01b600052601260045260246000fd5b500490565b60008060408385031215614fa757600080fd5b82359150602083013561454481614ec3565b600060208284031215614fcb57600080fd5b8151610d60816144c6565b6001600160a01b03858116825284811660208301528316604082015260806060820181905260009061500a90830184614752565b9695505050505050565b60006020828403121561502657600080fd5b8151610d60816144f8565b825481526001830154602082015260028301546040820152600383015461012082019061506a606084016001600160a01b03831661454f565b61507c608084018260a01d600b0b9052565b5060048401546001600160a01b031661509860a084018261454f565b50600584015460c0830152600684015460e0830152610d6061010083018461454f565b600080600080600080600060e0888a0312156150d657600080fd5b8751965060208801519550604088015194506060880151935060808801516150fd81614ec3565b60a089015190935061510e81614ec3565b60c089015190925061511f81614ec3565b8091505092959891949750929550565b600060018060a01b03808816835260a0602084015261515160a0840188614dfc565b9581166040840152938416606083015250911660809091015292915050565b63ffffffff8281168282160390808211156121f0576121f0614da9565b63ffffffff8181168382160190808211156121f0576121f0614da9565b6001600160a01b0393841681529183166020830152909116604082015260600190565b600080600080608085870312156151e357600080fd5b8451935060208501516151f581614ec3565b6040860151606090960151949790965092505050565b6000825161521d81846020870161472e565b9190910192915050565b60006020828403121561523957600080fd5b8151610d6081614a1b565b600b82810b9082900b0360016001605f1b0319811260016001605f1b0382131715610c1b57610c1b614da9565b8781526001600160a01b03878116602083015286811660408301528516606082015263ffffffff84166080820152600b83900b60a082015260e060c08201819052600090610f3d90830184614752565b6000602082840312156152d357600080fd5b81516001600160401b038111156152e957600080fd5b8201601f810184136152fa57600080fd5b80516153086145e8826145a2565b81815285602083850101111561531d57600080fd5b61390082602083016020860161472e565b76020b1b1b2b9b9a1b7b73a3937b61d1030b1b1b7bab73a1604d1b81526000835161536081601785016020880161472e565b7001034b99036b4b9b9b4b733903937b6329607d1b601791840191820152835161539181602884016020880161472e565b01602801949350505050565b6001600160a01b03929092168252602082015260400190565b634e487b7160e01b600052600160045260246000fd5b6000602082840312156153de57600080fd5b8151610d6081614ec3565b634e487b7160e01b600052603260045260246000fd5b60008161540e5761540e614da9565b50600019019056fea9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd346756e6374696f6e206d7573742062652063616c6c6564207468726f75676820360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564829b824e2329e205435d941c9f13baf578548505283d29261236d8e6596d4636a26469706673582212202027bee3227ca3087d63c709f33bf82f06c231fe331f6c012104a28220589f9e64736f6c63430008130033",
  "libraries": {
    "HelperLibrary": "0x85608a0f804D0a9A72C022c812125AA25fA5B9bf"
  },
  "devdoc": {
    "errors": {
      "NotAcceptedSuperToken()": [
        {
          "details": "Thrown when SuperTokens not accepted by the SuperApp are streamed to it"
        }
      ],
      "NotImplemented()": [
        {
          "details": "Thrown if a required callback wasn't implemented (overridden by the SuperApp)"
        }
      ],
      "UnauthorizedHost()": [
        {
          "details": "Thrown when the callback caller is not the host."
        }
      ]
    },
    "events": {
      "AdminChanged(address,address)": {
        "details": "Emitted when the admin account has changed."
      },
      "BeaconUpgraded(address)": {
        "details": "Emitted when the beacon is changed."
      },
      "Initialized(uint8)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      },
      "RoleAdminChanged(bytes32,bytes32,bytes32)": {
        "details": "Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"
      },
      "RoleGranted(bytes32,address,address)": {
        "details": "Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."
      },
      "RoleRevoked(bytes32,address,address)": {
        "details": "Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"
      },
      "SupporterUpdated(address,uint256,uint256,int96,int96,bool)": {
        "details": "Emitted when a supporter's contribution or flow rate is updated",
        "params": {
          "contribution": "The new total contribution amount",
          "flowRate": "The new flow rate",
          "isFlowUpdate": "True if the update was a flow rate update, false if it was a single contribution update",
          "previousContribution": "The previous total contribution amount",
          "previousFlowRate": "The previous flow rate if isFlowUpdate otherwise 0",
          "supporter": "The address of the supporter"
        }
      },
      "Upgraded(address)": {
        "details": "Emitted when the implementation is upgraded."
      }
    },
    "kind": "dev",
    "methods": {
      "addMember(address,bytes)": {
        "details": "Adds a member to the contract.",
        "params": {
          "extraData": "Additional data to validate the member.",
          "member": "The address of the member to add."
        }
      },
      "checkEntitlement(address)": {
        "details": "Checks the amount which the sender address is eligible to claim for, regardless if they have been whitelisted or not. In case the user is active, then the current day must be equal to the actual day, i.e. claim or fish has already been executed today.",
        "returns": {
          "_0": "The amount of GD tokens the address can claim."
        }
      },
      "claim()": {
        "details": "Claims UBI"
      },
      "constructor": {
        "custom:oz-upgrades-unsafe-allow": "constructor"
      },
      "currentDayInCycle()": {
        "details": "returns the day count since start of current cycle"
      },
      "distributionFormula()": {
        "details": "The claim calculation formula. Divide the daily pool with the sum of the active users. the daily balance is determined by dividing current pool by the cycle length",
        "returns": {
          "_0": "The amount of GoodDollar the user can claim"
        }
      },
      "getRoleAdmin(bytes32)": {
        "details": "Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."
      },
      "grantRole(bytes32,address)": {
        "details": "Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."
      },
      "handleSwap((address,uint256,uint256,uint256,bytes),address,bytes)": {
        "details": "Handles the swap of tokens using the SwapData struct",
        "params": {
          "_ctx": "The context of the transaction for superfluid",
          "_customData": "The SwapData struct containing information about the swap",
          "_sender": "The address of the sender of the transaction"
        },
        "returns": {
          "_0": "Returns the context of the transaction"
        }
      },
      "hasRole(bytes32,address)": {
        "details": "Returns `true` if `account` has been granted `role`."
      },
      "initialize((address,address,address,address),(uint32,uint32,uint32,bool,uint256,uint32,bool),(uint32,uint256,uint32),address)": {
        "details": "Initializes the contract with the given settings and limits.",
        "params": {
          "_settings": "The PoolSettings struct containing pool settings.",
          "_ubiSettings": "The UBISettings struct containing safety limits."
        }
      },
      "onTokenTransfer(address,uint256,bytes)": {
        "details": "This function is called when a token transfer occurs",
        "params": {
          "_amount": "The amount of tokens being transferred",
          "_sender": "The address of the sender"
        },
        "returns": {
          "_0": "bool Returns true to indicate that the transfer was successful"
        }
      },
      "proxiableUUID()": {
        "details": "Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."
      },
      "renounceRole(bytes32,address)": {
        "details": "Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."
      },
      "revokeRole(bytes32,address)": {
        "details": "Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."
      },
      "setPoolSettings((address,address,address,address))": {
        "details": "Sets the settings for the pool.",
        "params": {
          "_settings": "The new pool settings."
        }
      },
      "setUBISettings((uint32,uint32,uint32,bool,uint256,uint32,bool),(uint32,uint256,uint32))": {
        "details": "Sets the safety limits for the pool.",
        "params": {
          "_ubiSettings": "The new safety limits."
        }
      },
      "support(address,uint256,bytes)": {
        "details": "allow single contribution. user needs to approve tokens first. can be used in superfluid batch actions.",
        "params": {
          "_amount": "The amount of tokens being contributed.",
          "_ctx": "The context of the transaction for superfluid in case this was used in superfluid batch. otherwise can be empty.",
          "_sender": "The address of the sender who is contributing tokens."
        },
        "returns": {
          "_0": "Returns the context of the transaction."
        }
      },
      "supportWithSwap(address,(address,uint256,uint256,uint256,bytes),bytes)": {
        "details": "allow single contribution. user needs to approve tokens first. can be used in superfluid batch actions.",
        "params": {
          "_ctx": "The context of the transaction for superfluid in case this was used in superfluid batch. otherwise can be empty.",
          "_customData": "The SwapData struct containing information about the swap",
          "_sender": "The address of the sender who is contributing tokens."
        },
        "returns": {
          "_0": "Returns the context of the transaction."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "upgradeTo(address)": {
        "details": "Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      },
      "upgradeToAndCall(address,bytes)": {
        "details": "Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1989,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 1992,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 4120,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 4399,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "__gap",
        "offset": 0,
        "slot": "51",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 1217,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "_roles",
        "offset": 0,
        "slot": "101",
        "type": "t_mapping(t_bytes32,t_struct(RoleData)1212_storage)"
      },
      {
        "astId": 1512,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 17144,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "superToken",
        "offset": 0,
        "slot": "151",
        "type": "t_contract(ISuperToken)13220"
      },
      {
        "astId": 17149,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "supporters",
        "offset": 0,
        "slot": "152",
        "type": "t_mapping(t_address,t_struct(SupporterData)17141_storage)"
      },
      {
        "astId": 17152,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "cfaV1",
        "offset": 0,
        "slot": "153",
        "type": "t_struct(InitData)6837_storage"
      },
      {
        "astId": 17155,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "stats",
        "offset": 0,
        "slot": "155",
        "type": "t_struct(Stats)17995_storage"
      },
      {
        "astId": 17159,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "_reserved",
        "offset": 0,
        "slot": "162",
        "type": "t_array(t_uint256)45_storage"
      },
      {
        "astId": 1971,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "__gap",
        "offset": 0,
        "slot": "207",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 2286,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "__gap",
        "offset": 0,
        "slot": "257",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 18686,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "settings",
        "offset": 0,
        "slot": "307",
        "type": "t_struct(PoolSettings)18535_storage"
      },
      {
        "astId": 18689,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "ubiSettings",
        "offset": 0,
        "slot": "311",
        "type": "t_struct(UBISettings)18655_storage"
      },
      {
        "astId": 18692,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "status",
        "offset": 0,
        "slot": "314",
        "type": "t_struct(PoolStatus)18676_storage"
      },
      {
        "astId": 18695,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "registry",
        "offset": 0,
        "slot": "323",
        "type": "t_contract(UBIPoolFactory)20424"
      },
      {
        "astId": 18698,
        "contract": "contracts/UBI/UBIPool.sol:UBIPool",
        "label": "extendedSettings",
        "offset": 0,
        "slot": "324",
        "type": "t_struct(ExtendedSettings)18683_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)45_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[45]",
        "numberOfBytes": "1440"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IConstantFlowAgreementV1)11565": {
        "encoding": "inplace",
        "label": "contract IConstantFlowAgreementV1",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20Upgradeable)2365": {
        "encoding": "inplace",
        "label": "contract IERC20Upgradeable",
        "numberOfBytes": "20"
      },
      "t_contract(IIdentityV2)18523": {
        "encoding": "inplace",
        "label": "contract IIdentityV2",
        "numberOfBytes": "20"
      },
      "t_contract(IMembersValidator)18515": {
        "encoding": "inplace",
        "label": "contract IMembersValidator",
        "numberOfBytes": "20"
      },
      "t_contract(ISuperToken)13220": {
        "encoding": "inplace",
        "label": "contract ISuperToken",
        "numberOfBytes": "20"
      },
      "t_contract(ISuperfluid)13893": {
        "encoding": "inplace",
        "label": "contract ISuperfluid",
        "numberOfBytes": "20"
      },
      "t_contract(UBIPoolFactory)20424": {
        "encoding": "inplace",
        "label": "contract UBIPoolFactory",
        "numberOfBytes": "20"
      },
      "t_int96": {
        "encoding": "inplace",
        "label": "int96",
        "numberOfBytes": "12"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_struct(SupporterData)17141_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct GoodCollectiveSuperApp.SupporterData)",
        "numberOfBytes": "32",
        "value": "t_struct(SupporterData)17141_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_struct(RoleData)1212_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct AccessControlUpgradeable.RoleData)",
        "numberOfBytes": "32",
        "value": "t_struct(RoleData)1212_storage"
      },
      "t_struct(ExtendedSettings)18683_storage": {
        "encoding": "inplace",
        "label": "struct UBIPool.ExtendedSettings",
        "members": [
          {
            "astId": 18678,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "maxPeriodClaimers",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18680,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "minClaimAmount",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 18682,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "managerFeeBps",
            "offset": 0,
            "slot": "2",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(InitData)6837_storage": {
        "encoding": "inplace",
        "label": "struct CFAv1Library.InitData",
        "members": [
          {
            "astId": 6833,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "host",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(ISuperfluid)13893"
          },
          {
            "astId": 6836,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "cfa",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(IConstantFlowAgreementV1)11565"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(PoolSettings)18535_storage": {
        "encoding": "inplace",
        "label": "struct PoolSettings",
        "members": [
          {
            "astId": 18525,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "manager",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 18528,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "membersValidator",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(IMembersValidator)18515"
          },
          {
            "astId": 18531,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "uniquenessValidator",
            "offset": 0,
            "slot": "2",
            "type": "t_contract(IIdentityV2)18523"
          },
          {
            "astId": 18534,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "rewardToken",
            "offset": 0,
            "slot": "3",
            "type": "t_contract(IERC20Upgradeable)2365"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(PoolStatus)18676_storage": {
        "encoding": "inplace",
        "label": "struct UBIPool.PoolStatus",
        "members": [
          {
            "astId": 18657,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "currentDay",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 18659,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "dailyUbi",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 18661,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "dailyCyclePool",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 18663,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "startOfCycle",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 18665,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "currentCycleLength",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 18667,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "periodClaimers",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 18669,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "periodDistributed",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 18673,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "lastClaimed",
            "offset": 0,
            "slot": "7",
            "type": "t_mapping(t_address,t_uint256)"
          },
          {
            "astId": 18675,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "membersCount",
            "offset": 0,
            "slot": "8",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "288"
      },
      "t_struct(RoleData)1212_storage": {
        "encoding": "inplace",
        "label": "struct AccessControlUpgradeable.RoleData",
        "members": [
          {
            "astId": 1209,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "members",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 1211,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "adminRole",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Stats)17995_storage": {
        "encoding": "inplace",
        "label": "struct IGoodCollectiveSuperApp.Stats",
        "members": [
          {
            "astId": 17980,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "netIncome",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 17982,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "totalFees",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 17984,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "lastUpdate",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 17986,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "lastFeeRecipient",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 17988,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "lastIncomeRate",
            "offset": 20,
            "slot": "3",
            "type": "t_int96"
          },
          {
            "astId": 17990,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "lastManagerFeeRecipient",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 17992,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "protocolFees",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 17994,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "managerFees",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(SupporterData)17141_storage": {
        "encoding": "inplace",
        "label": "struct GoodCollectiveSuperApp.SupporterData",
        "members": [
          {
            "astId": 17136,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "contribution",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 17138,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "flowRate",
            "offset": 0,
            "slot": "1",
            "type": "t_int96"
          },
          {
            "astId": 17140,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "lastUpdated",
            "offset": 12,
            "slot": "1",
            "type": "t_uint128"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(UBISettings)18655_storage": {
        "encoding": "inplace",
        "label": "struct UBIPool.UBISettings",
        "members": [
          {
            "astId": 18642,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "cycleLengthDays",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18644,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "claimPeriodDays",
            "offset": 4,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18646,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "minActiveUsers",
            "offset": 8,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18648,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "claimForEnabled",
            "offset": 12,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 18650,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "maxClaimAmount",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 18652,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "maxMembers",
            "offset": 0,
            "slot": "2",
            "type": "t_uint32"
          },
          {
            "astId": 18654,
            "contract": "contracts/UBI/UBIPool.sol:UBIPool",
            "label": "onlyMembers",
            "offset": 4,
            "slot": "2",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}
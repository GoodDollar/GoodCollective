# TODO
# get total donated from correct field
# handling of generated pools from factory contract
# update nft with stewards on claim
# per collective donor/steward record
    # each collective needs to know donors and stewards
    # each donor and steward needs top know per-collective data (e.g. how much did I donate to this collective)
# How to know if steward is verified?
# Is Donor unique by "supporter" or by "id"? If by id, do we need timestamps to know the current donation status?
# Need recent collective transactions and list of all transactions

type Steward @entity {
  "{ user address} "
  id: String!
  " Number of actions performed "
  actions: Int!
  totalEarned: BigInt!
  " NFT's minted to steward"
  nfts: [ProvableNFT!]! @derivedFrom(field: "steward")
  " Collectives the steward is apart of "
  collectives: [Collective!]! @derivedFrom(field: "stewards")
}

type Donor @entity {
  id: String! # This will be the contract address from which the transaction originated
  supporter: Bytes! # Address of the supporter
  joined: Int!
  totalDonated: BigInt!
  previousContribution: BigInt
  contribution: BigInt
  previousFlowRate: BigInt
  flowRate: BigInt
  isFlowUpdate: Boolean
  collectives: [Collective!]!
}

type CollectiveDonor @entity {
  id: String! #collective_donor
  totalDonated: BigInt!
  flowRate: BigInt
}

type CollectiveSteward @entity {
  id: String! #collective_steward
  actions: Int!
  totalEarned: BigInt!
  nft: [ProvableNFT!]!
}

type Collective @entity {
  "This is the address source"
  id: String!
  ipfs: String
  nftType: BigInt
  manager: Bytes
  contributions: BigInt!
  membersValidator: Bytes
  uniquenessValidator: String
  donors: [Donor!] @derivedFrom(field: "collectives")
  stewards: [Steward!]!
  rewardToken: String
  projectId: String
  isVerified: Boolean
  limits: SafetyLimits
  nft: ProvableNFT
  poolAddress: String
  timestamp: Int
}

type PoolSettings @entity {
  id: String!
  nftType: BigInt!
  manager: Bytes!
  membersValidator: Bytes!
  uniquenessValidator: Bytes!
  rewardToken: Bytes!
}

type SafetyLimits @entity {
  id: String!
  maxTotalPerMonth: BigInt
  maxMemberPerMonth: BigInt
  maxMemberPerDay: BigInt
}

type ProvableNFT @entity {
  id: ID!
  owner: String!
  hash: String!
  steward: [Steward!]!
  collective: Collective!
}

type EventData @entity {
  id: String!
  eventType: Int!
  timestamp: BigInt!
  quantity: BigInt!
  uri: String!
  rewardPerContributor: BigInt!
  contributors: [Steward!]!
  nft: ProvableNFT!
  claim: Claim
}

type Claim @entity {
  id: String!
  totalRewards: BigInt!
  events: [EventData!] @derivedFrom(field: "claim")
}

type Donor @entity {
  id: String! # The address of the donor
  joined: BigInt!
  totalDonated: BigInt!
  collectives: [DonorCollective!]!
}

"""Represents the relationship between a Donor and a Collective"""
type DonorCollective @entity {
  id: String! # donorAddress + " " + collectiveAddress
  donor: Donor! @derivedFrom(field: "collectives")
  collective: Collective! @derivedFrom(field: "donors")
  totalDonated: BigInt!
  donations: [Donation!]!
}

type Donation @entity {
  id: String! # donorAddress + " " + collectiveAddress + " " + timestamp
  donor: Donor!
  collective: Collective!
  timestamp: BigInt
  originationContract: Bytes! # The contract address from which the transaction originated
  previousContribution: BigInt
  contribution: BigInt
  previousFlowRate: BigInt
  flowRate: BigInt
  isFlowUpdate: Boolean
}

type Steward @entity {
  """{ user address}"""
  id: String!
  """Number of actions performed"""
  actions: Int!
  totalEarned: BigInt!
  """NFT's minted to steward"""
  nfts: [ProvableNFT!]!
  """Collectives the steward is apart of"""
  collectives: [StewardCollective!]!
}

"""Represents the relationship between a Steward and a Collective"""
type StewardCollective @entity {
  id: String! # stewardAddress + " " + collectiveAddress
  steward: Steward! @derivedFrom(field: "collectives")
  collective: Collective! @derivedFrom(field: "stewards")
  actions: Int!
  totalEarned: BigInt!
  rewards: [Reward!]!
}

type Reward @entity {
    id: String! # stewardAddress + " " + collectiveAddress + " " + timestamp
    steward: Steward!
    collective: Collective!
    timestamp: BigInt
    quantity: BigInt
    rewardPerContributor: BigInt
    nft: ProvableNFT!
}

type Collective @entity {
  "This is the address source"
  id: String!
  ipfs: String
  settings: PoolSettings!
  limits: SafetyLimits!
  contributions: BigInt!
  donors: [DonorCollective!]!
  stewards: [StewardCollective!]!
  projectId: String
  isVerified: Boolean
  poolFactory: String
  timestamp: Int
}

type PoolSettings @entity {
  id: String! # collective address
  nftType: BigInt!
  manager: Bytes!
  membersValidator: Bytes!
  uniquenessValidator: Bytes!
  rewardToken: Bytes!
}

type SafetyLimits @entity {
  id: String! # collective address
  maxTotalPerMonth: BigInt!
  maxMemberPerMonth: BigInt!
  maxMemberPerDay: BigInt!
}

type ProvableNFT @entity {
  id: ID!
  owner: String!
  hash: String!
  steward: [Steward!]! @derivedFrom(field: "nfts")
  collective: Collective!
}

type EventData @entity {
  id: String!
  eventType: Int!
  timestamp: BigInt!
  quantity: BigInt!
  uri: String!
  rewardPerContributor: BigInt!
  contributors: [Steward!]!
  nft: ProvableNFT!
  claim: Claim @derivedFrom(field: "event")
}

type Claim @entity {
  id: String!
  totalRewards: BigInt!
  event: EventData!
}
